<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大数据驱动的危废监管新范式：重庆市企业用电量与产废量关联分析及多维度异常检测</title>
    <link href="/2025/08/03/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8D%B1%E5%BA%9F%E7%9B%91%E7%AE%A1%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%94%A8%E7%94%B5%E9%87%8F%E4%B8%8E%E4%BA%A7%E5%BA%9F%E9%87%8F%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%9A%E7%BB%B4%E5%BA%A6%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    <url>/2025/08/03/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%8D%B1%E5%BA%9F%E7%9B%91%E7%AE%A1%EF%BC%9A%E4%BC%81%E4%B8%9A%E7%94%A8%E7%94%B5%E9%87%8F%E4%B8%8E%E4%BA%A7%E5%BA%9F%E9%87%8F%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90%E5%8F%8A%E5%A4%9A%E7%BB%B4%E5%BA%A6%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在“数字重庆”建设持续深入推进的时代背景下，生态环境管理正迈向精细化、智能化新阶段。危险废物作为固体废物管理的重中之重，其全生命周期管理日益精细，大量关键信息已接入“巴渝治废”等数字化管理平台，涵盖企业的危废产生量、类别等核心数据。面对海量的基础数据，如何深入挖掘其潜在价值，赋能精准监管，成为当前亟待解决的课题。本文旨在探索企业用电数据与危险废物产生数据之间的内在关联，并基于此构建智能分析模型，以期精准识别潜在的异常情况，为危废监管提供新的视角与技术支撑。<br><strong>以下观点也是对于环保数据不成熟的思考和尝试，如果读者有更好的想法和实现路径也请留言讨论，关注交流。</strong></p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>本研究的核心目标是利用企业用电量这一高频、实时且具有生产活动指示性的数据，结合危险废物产生量数据，构建多维度分析模型，从而有效识别危废产生量中可能存在的异常波动或数据偏差，为生态环境部门实现精准监管、风险预警及资源优化配置提供数据驱动的决策依据。</p><h2 id="技术路线"><a href="#技术路线" class="headerlink" title="技术路线"></a>技术路线</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E7%94%B5%E5%BA%9F%E6%A8%A1%E5%9E%8B%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF.png" alt="电废模型技术路线.png"></p><h2 id="基础数据分析"><a href="#基础数据分析" class="headerlink" title="基础数据分析"></a>基础数据分析</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803101709918.png" alt="所有企业相关性"></p><p>纳入分析的企业共计 718 家，涵盖 43 个不同行业，涉及 224 个不同危废类别。其中，年产废量大于 50 吨的企业有 490 家。在全部企业中，用电量与产废量相关性达到 0.6 以上的企业占比为 20.6%。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803101757574.png" alt=" "></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803101807207.png" alt=" "></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803101818187.png" alt=" "></p><p>在对纳入分析的 718 家企业（涵盖 43 个不同行业、涉及 224 个危废类别）进行基础数据分析时，我们发现，尽管年产废量大于 50 吨的企业占比高达 490 家，但整体而言，用电量与产废量相关性达到 0.6 以上的企业仅占 20.6%。进一步从行业和产废类别维度进行聚合分析，我们观察到，当行业或产废类别数量增多时，整体相关性趋于弱化甚至不相关。这与实际生产经验相符，即不同企业在生产效率和废物产出模式上存在显著差异。这一发现也明确指出，简单地从宏观行业或产废类别层面推导单个企业的用电量与产废量关联性是不可行的。因此，本研究的重点必须聚焦于<strong>单个企业自身的历史数据分析</strong>，以捕捉其独特的生产规律和异常模式。</p><h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>鉴于企业生产模式的复杂性和数据特征的多样性，本研究并未采用单一的异常检测方法，而是根据不同的业务场景和数据特性，综合运用了五种核心算法，以期从多维度、多视角捕捉潜在的异常行为。这些算法包括：单位用电量产废量 MAD 分析、线性回归残差分析、归一化差异分析、突变趋势分析以及波动性同步性检验。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803102401162.png" alt=" "></p><h3 id="1-单位用电量产废量-MAD-分析-FeatureEngineeringDetector"><a href="#1-单位用电量产废量-MAD-分析-FeatureEngineeringDetector" class="headerlink" title="1. 单位用电量产废量 MAD 分析 (FeatureEngineeringDetector)"></a><strong>1. 单位用电量产废量 MAD 分析 (FeatureEngineeringDetector)</strong></h3><ul><li><p><strong>核心思路</strong>：<br>该方法关注企业的<strong>生产效率</strong>。它假设在正常生产状态下，单位用电量所对应的产废量（即生产效率）应保持相对稳定。通过计算“单位用电量产废量”这一比率，并应用对异常值鲁棒的 MAD（中位数绝对偏差）方法，来识别那些生产效率显著偏离历史水平的异常点。例如，一个企业突然出现“高耗电、低产出”或“低耗电、高产出”的情况，可能预示着数据问题或生产状态异常。</p></li><li><p><strong>核心公式</strong>：</p><ol><li><strong>归一化 (避免除零)</strong>:<ul><li><code>waste_norm_1_2 = normalize_series(waste) + 1.0</code> (归一化到 $[1, 2]$)</li><li><code>elec_norm_1_2 = normalize_series(elec) + 1.0</code> (归一化到 $[1, 2]$)</li></ul></li><li><strong>计算单位用电量产废量</strong>:<ul><li><code>unit_waste = waste_norm_1_2 / elec_norm_1_2</code></li></ul></li><li><strong>MAD 异常检测</strong>:<ul><li><code>median = median(unit_waste)</code></li><li><code>mad = median(|unit_waste - median|)</code></li><li><code>mad_score = |unit_waste - median| / mad</code> (若 <code>mad</code> !&#x3D; 0)</li><li><strong>异常判定</strong>: <code>mad_score &gt; threshold</code> (默认阈值为 3.0)</li></ul></li></ol></li><li><p><strong>主要特点</strong>：</p><ul><li><strong>适用场景</strong>：适用于产废量和用电量均有一定规模，且历史效率相对稳定的企业。</li></ul></li></ul><hr><h4 id="2-线性回归残差分析-LinearRegressionDetector-RegressionDetector"><a href="#2-线性回归残差分析-LinearRegressionDetector-RegressionDetector" class="headerlink" title="2. 线性回归残差分析 (LinearRegressionDetector &amp; RegressionDetector)"></a><strong>2. 线性回归残差分析 (LinearRegressionDetector &amp; RegressionDetector)</strong></h4><ul><li><p><strong>核心思路</strong>：<br>该方法基于<strong>历史数据建立数学模型</strong>。它假设企业的产废量（W）与用电量（E）之间存在一个稳定的线性关系 <code>W = β₀ + β₁E</code>。对于新的数据点，模型会预测其“应有的”产废量，实际值与预测值之间的差值（残差）即为分析对象。如果残差过大，说明该点严重偏离了历史规律，应被标记为异常。</p></li><li><p><strong>核心公式</strong>：</p><ol><li><strong>模型拟合</strong>:<ul><li><code>W_pred = β₀ + β₁ * E</code> (使用最小二乘法估计 <code>β₀</code> 和 <code>β₁</code>)</li></ul></li><li><strong>计算残差</strong>:<ul><li><code>residual = W_actual - W_pred</code></li></ul></li><li><strong>异常判定</strong>:<ul><li><strong><code>LinearRegressionDetector</code></strong>: <code>|residual| &gt; k * se</code><ul><li><code>se</code> 是回归模型的标准误差，衡量模型预测的平均精度。</li><li><code>k</code> 是置信系数（默认 0.8）。</li></ul></li><li><strong><code>RegressionDetector</code></strong>: <code>|residual| &gt; threshold * std_residuals</code><ul><li><code>std_residuals</code> 是残差序列自身的标准差。</li><li><code>threshold</code> 为 3.0，即经典的<strong>3σ原则</strong>。</li></ul></li></ul></li></ol></li><li><p><strong>主要特点</strong>：</p><ul><li><strong>模型驱动</strong>：拥有明确的统计学模型基础，理论严谨。</li><li><strong>预测性强</strong>：不仅能判断异常，还能给出“正常值”应该是多少（预测值）。</li><li><strong>两种策略</strong>：<ul><li><code>LinearRegressionDetector</code> 更关注<strong>模型的预测能力</strong>（<code>se</code>），并具备<strong>数据不足时的回退机制</strong>（比率法），鲁棒性更强。</li><li><code>RegressionDetector</code> 遵循<strong>经典统计学原则</strong>（3σ），逻辑简洁明了。</li></ul></li><li><strong>适用场景</strong>：适用于产废量与用电量有明显线性相关性的企业，且历史数据点充足（通常&gt;&#x3D;3 个）。</li></ul></li></ul><hr><h3 id="3-归一化差异分析-NormalizedDifferenceDetector"><a href="#3-归一化差异分析-NormalizedDifferenceDetector" class="headerlink" title="3. 归一化差异分析 (NormalizedDifferenceDetector)"></a><strong>3. 归一化差异分析 (NormalizedDifferenceDetector)</strong></h3><ul><li><p><strong>核心思路</strong>：<br>该方法采用<strong>最直观的比较方式</strong>。它认为，在正常情况下，企业的产废量和用电量的变化趋势应当是同步的。通过将两个指标分别归一化到 $[0,1]$ 区间，消除了量纲和企业规模的影响，然后直接计算它们在同一时间点的数值差异。如果这个差异超过了预设的阈值，就认为两者的变化趋势出现了严重脱节，该点为异常。</p></li><li><p><strong>核心公式</strong>：</p><ol><li><strong>归一化</strong>:<ul><li><code>waste_norm = (waste - min(waste)) / (max(waste) - min(waste))</code></li><li><code>elec_norm = (elec - min(elec)) / (max(elec) - min(elec))</code></li></ul></li><li><strong>计算差异</strong>:<ul><li><code>normalized_diff = |waste_norm - elec_norm|</code></li></ul></li><li><strong>异常判定</strong>:<ul><li><code>normalized_diff &gt; diff_threshold</code> (默认阈值为 0.35)</li></ul></li></ol></li><li><p><strong>主要特点</strong>：</p><ul><li><strong>适用场景</strong>：作为一种快速、基础的筛查工具，适用于所有企业，尤其适合对趋势同步性要求高的场景。</li></ul></li></ul><hr><h3 id="4-突变趋势分析-TrendCrossDetector"><a href="#4-突变趋势分析-TrendCrossDetector" class="headerlink" title="4. 突变趋势分析 (TrendCrossDetector)"></a><strong>4. 突变趋势分析 (TrendCrossDetector)</strong></h3><ul><li><p><strong>核心思路</strong>：<br>该方法具有<strong>前瞻性</strong>，它不直接分析当前值，而是监测两者<strong>变化趋势的“交叉”</strong>。当产废量的趋势（上升&#x2F;下降）与用电量的趋势发生逆转（即一个在上升而另一个在下降）时，系统认为企业的生产模式可能正在发生转变。这种转变本身可能不是异常，但它预示着后续的数据点可能不稳定。因此，该方法会检查趋势交叉<strong>发生后的下一个时间点</strong>，如果此时的归一化差异也很大，则将该后续点标记为异常。</p></li><li><p><strong>核心公式</strong>：</p><ol><li><strong>归一化</strong>:<ul><li><code>waste_norm = normalize_series(waste)</code></li><li><code>elec_norm = normalize_series(elec)</code></li></ul></li><li><strong>计算趋势符号</strong>:<ul><li><code>waste_trend = sign(waste_norm.diff())</code> (上升&#x3D;1, 下降&#x3D;-1, 不变&#x3D;0)</li><li><code>elec_trend = sign(elec_norm.diff())</code></li></ul></li><li><strong>识别交叉点</strong>:<ul><li><code>cross_point[i] = (waste_trend[i] != elec_trend[i])</code></li></ul></li><li><strong>标记异常点</strong>:<ul><li>如果 <code>cross_point[i]</code> 为 <code>True</code>，则检查 <code>i+1</code> 时刻的归一化差异。</li><li><strong>异常判定</strong>: <code>|waste_norm[i+1] - elec_norm[i+1]| &gt; diff_threshold</code> (默认阈值为 0.4)</li></ul></li></ol></li><li><p><strong>主要特点</strong>：</p><ul><li><strong>适用场景</strong>：适用于生产流程可能发生调整、或数据可能存在滞后性问题的企业，用于发现模式切换的信号。</li></ul></li></ul><hr><h3 id="5-波动性同步性检验-VolatilityDetector"><a href="#5-波动性同步性检验-VolatilityDetector" class="headerlink" title="5. 波动性同步性检验 (VolatilityDetector)"></a><strong>5. 波动性同步性检验 (VolatilityDetector)</strong></h3><ul><li><p><strong>核心思路</strong>：<br>该方法关注的是<strong>剧烈变化的同步性</strong>。它认为，在正常生产中，重大的生产活动（如开&#x2F;停机、批次生产）会同时导致用电量和产废量的剧烈波动。如果一个指标发生了剧烈变化（变化率超过 50%），而另一个指标没有相应的响应（变化方向相反或变化极小），则这种“不同步”的剧烈波动很可能是数据异常或生产问题的信号。</p></li><li><p><strong>核心公式</strong>：</p><ol><li><strong>归一化</strong>:<ul><li><code>waste_norm = normalize_series (waste)</code></li><li><code>elec_norm = normalize_series (elec)</code></li></ul></li><li><strong>计算变化率</strong>:<ul><li><code>elec_change = elec_norm. Pct_change ()</code> (百分比变化)</li><li><code>waste_change = waste_norm. Pct_change ()</code></li></ul></li><li><strong>定义异常条件</strong>:<ul><li><strong>条件 1 (电变废不变)</strong>:<ul><li><code>elec_big = |elec_change| &gt; 0.5</code></li><li><code>waste_unsync = (sign (elec_change) != sign (waste_change)) OR (|waste_change| &lt; 0.01)</code></li><li><code>condition 1 = elec_big AND waste_unsync</code></li></ul></li><li><strong>条件 2 (废变电不变)</strong>:<ul><li><code>waste_big = |waste_change| &gt; 0.5</code></li><li><code>elec_unsync = (sign (waste_change) != sign (elec_change)) OR (|elec_change| &lt; 0.01)</code></li><li><code>condition 2 = waste_big AND elec_unsync</code></li></ul></li></ul></li><li><strong>综合判定与过滤</strong>:<ul><li><code>is_outlier = (condition 1 OR condition 2) AND (original_waste_value &gt; 50.0)</code></li></ul></li></ol></li><li><p><strong>主要特点</strong>：</p><ul><li><strong>适用场景</strong>：特别适用于生产活动具有间歇性、波动性大的企业，用于发现数据录入错误或生产计划外的活动。</li></ul></li></ul><h2 id="模型结果"><a href="#模型结果" class="headerlink" title="模型结果"></a>模型结果</h2><p>通过上述多算法模型的构建与应用，我们成功识别出历史月份中用电量与产废量可能存在异常的月份，并进行了直观的可视化呈现。从分析结果来看，对于用电量与产废量具有较高相关性的企业，不同算法识别出的异常点往往具有高度一致性，这印证了模型在捕捉稳定生产模式下异常的有效性。然而，对于相关性较差的企业，模型识别出的异常点则呈现出数量更多且算法间差异显著的特点。这并非模型失效，而是恰恰反映了这类企业用电量与产废量之间可能不存在显著的线性或稳定关联，其生产模式更为复杂或数据本身存在更多不确定性。在这种情况下，不同算法从各自的侧重点（如效率、趋势、波动性等）出发，自然会捕捉到不同的“异常”表现，甚至可能将大部分数据点标记为异常，这提示我们在解释和应用模型结果时，必须充分考虑企业自身的生产特性和数据质量。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803102723895.png" alt="相关性好的企业分析案例"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803102655048.png" alt="相关性差的企业分析案例"></p><h2 id="企业反馈"><a href="#企业反馈" class="headerlink" title="企业反馈"></a>企业反馈</h2><p>为了验证模型的实际效用并获取业务层面的反馈，我们选取了部分被识别为异常的企业进行问题推送。企业反馈为模型优化提供了宝贵的洞察，主要集中在以下几个方面，这些反馈也揭示了模型在实际应用中面临的挑战与局限性：</p><ol><li><strong>生产状态异常影响数据可比性：</strong> 如设备检修、停产、搬迁或生产线调整等非正常生产状态，导致用电量与产废量在特定时期内失去可比性。</li><li><strong>生产运行模式影响用电与产废的匹配性：</strong> 间歇性生产、季节性生产、或产废环节与主要用电环节不完全同步等，使得用电量与产废量之间的时间匹配性变差。</li><li><strong>总用电数据颗粒度不足：</strong> 企业总用电量数据未能区分生产用电与非生产用电，或未能细化到具体产废工艺环节，导致关联分析的精度受限。</li><li><strong>产废与填报信息不匹配：</strong> 实际产废量与平台填报数据之间存在滞后、偏差或统计口径不一致等问题，影响了数据真实性与模型判断的准确性。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250803103304073.png" alt=" "></p><h2 id="反思与总结"><a href="#反思与总结" class="headerlink" title="反思与总结"></a>反思与总结</h2><p>本次研究的实践深刻揭示了一个核心洞察：任何数据模型，其“失效”并非必然源于算法本身的缺陷，而更多是由于数据质量、企业生产模式的复杂性与模型预设假设之间存在不匹配。这再次印证了“放之四海而皆准”的单一模型在复杂工业场景中难以奏效。因此，在未来的智能监管实践中，我们必须坚持<strong>结合企业生产实际、明确模型边界、审慎评估适用条件</strong>的原则，进行<strong>分场景、精细化</strong>的分析与应用。这不仅要求技术层面的持续迭代，更需要业务与技术深度融合，共同构建更贴合实际、更具韧性的智能监管体系。</p><h2 id="下一步完善思路"><a href="#下一步完善思路" class="headerlink" title="下一步完善思路"></a>下一步完善思路</h2><p>为进一步提升模型的准确性与实用性，未来的完善工作将聚焦于以下几个关键方向：</p><ol><li><strong>多源数据融合与交叉验证：</strong> 积极探索并整合更多自动化监测数据，如水、气污染物排放数据等，作为用电量与产废量关联分析的佐证，通过多维度数据交叉验证，对识别出的异常点进行二次筛选，提高预警的精准度。</li><li><strong>构建“业务问题池”与精准推送：</strong> 结合企业反馈和专家经验，构建结构化的“业务问题池”，针对性地根据企业实际情况，将异常报告精准推送至试点企业，要求其进行自查自纠并反馈原因。</li><li><strong>建立“识别-反馈-优化”闭环机制：</strong> 基于企业真实的反馈信息，深入分析模型误报（False Positives）和漏报（False Negatives）的原因，针对性地调整算法参数、优化模型结构或引入新的特征工程方法，形成持续迭代优化的智能监管闭环，不断提升模型的适应性和预测能力。</li></ol><h2 id="作者：BY"><a href="#作者：BY" class="headerlink" title="作者：BY"></a>作者：BY</h2><p>个人经验分享，如有收获，欢迎收藏、点赞！<br>尊重原创，如需转载，请注明出处。<br>欢迎留言评论，交流心得，共同进步！</p><h3 id="📬-联系方式："><a href="#📬-联系方式：" class="headerlink" title="📬 联系方式："></a>📬 联系方式：</h3><ul><li>微信公众号：环境猫 er</li><li>CSDN 博客：细节处有神明</li><li>个人博客：<ul><li><code>https://wenmao.xyz</code></li><li><code>https://wenmaochen.netlify.app</code></li><li><code>https://maoyu92.github.io</code></li></ul></li></ul><p>感谢阅读，我们下次再见！ 🌟</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>生态环境</tag>
      
      <tag>大数据分析</tag>
      
      <tag>固体废物</tag>
      
      <tag>危险废物</tag>
      
      <tag>算法设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>敏捷方法</title>
    <link href="/2025/08/03/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/"/>
    <url>/2025/08/03/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%95%8F%E6%8D%B7%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="敏捷宣言的4大核心价值"><a href="#敏捷宣言的4大核心价值" class="headerlink" title="敏捷宣言的4大核心价值"></a>敏捷宣言的4大核心价值</h2><ul><li>个体和互动 高于流程和工具</li><li>可工作的软件 高于详尽的文档</li><li>客户合作 高于合同谈判</li><li>响应变化高于遵循计划</li></ul><h2 id="敏捷宣言的12条原则"><a href="#敏捷宣言的12条原则" class="headerlink" title="敏捷宣言的12条原则"></a>敏捷宣言的12条原则</h2><ul><li>最高优先级是 尽早持续交付有价值的软</li><li>欢迎需求变化，即使开发后期也要适应变化</li><li>频繁交付可工作的软件（周期越短越好）</li><li>业务人员与开发团队每天协作</li><li>激励个体，提供信任和支持</li><li>面对面沟通 是最有效的交流方式</li><li>可工作的软件是衡量进度的首要标准</li><li>可持续开发，保持稳定的开发节奏</li><li>持续追求技术卓越和良好设计</li><li>简单性（最大化不必要工作的减少）</li><li>自组织团队 能产生最佳架构、需求和设计</li><li>定期反思并调整工作方式</li></ul><h2 id="常见的敏捷方法"><a href="#常见的敏捷方法" class="headerlink" title="常见的敏捷方法"></a>常见的敏捷方法</h2><h3 id="Scrum（最流行）"><a href="#Scrum（最流行）" class="headerlink" title="Scrum（最流行）"></a>Scrum（最流行）</h3><ul><li>角色：产品负责人（PO）、Scrum Master、开发团队</li><li>关键会议：Sprint计划会、每日站会、Sprint评审会、Sprint回顾会</li><li>关键工件：产品待办列表（Product Backlog）、Sprint待办列表（Sprint Backlog）、增量（Increment）</li></ul><h3 id="Kanban（看板）"><a href="#Kanban（看板）" class="headerlink" title="Kanban（看板）"></a>Kanban（看板）</h3><ul><li>可视化工作流（To Do、In Progress、Done）</li><li>限制在制品（WIP）数量，优化流程效率</li></ul><h3 id="极限编程（XP）"><a href="#极限编程（XP）" class="headerlink" title="极限编程（XP）"></a>极限编程（XP）</h3><ul><li>强调 测试驱动开发（TDD）、结对编程、持续集成</li></ul><h3 id="DevOps（敏捷的延伸）"><a href="#DevOps（敏捷的延伸）" class="headerlink" title="DevOps（敏捷的延伸）"></a>DevOps（敏捷的延伸）</h3><ul><li>结合开发（Dev）和运维（Ops），实现持续集成（CI）&#x2F;持续交付（CD）</li></ul><h2 id="敏捷方法的注意事项"><a href="#敏捷方法的注意事项" class="headerlink" title="敏捷方法的注意事项"></a>敏捷方法的注意事项</h2><ol><li>避免形式主义<ul><li>敏捷的核心是“个体和互动高于流程和工具”，避免过度依赖工具或僵化的流程，而忽视团队协作和实际价值交付。</li></ul></li><li>确保客户参与<ul><li>客户或业务代表应持续参与项目，及时反馈需求变化，避免开发团队闭门造车。</li></ul></li><li>保持迭代节奏<ul><li>每个迭代（Sprint）应控制在 2-4周，确保快速交付可工作的软件，避免迭代过长导致需求变更滞后。</li></ul></li><li>避免技术债务积累<ul><li>虽然敏捷强调快速交付，但仍需关注代码质量，避免因追求速度而忽视架构优化和测试覆盖。</li></ul></li><li>团队自组织与信任<ul><li>敏捷团队应具备自组织能力，管理者应避免过度干预，信任团队自主决策。</li></ul></li><li>适应变化但避免无序变更<ul><li>敏捷欢迎需求变化，但需通过产品待办列表（Product Backlog） 管理优先级，避免频繁无序变更导致目标模糊。</li></ul></li><li>持续反馈与改进<ul><li>定期进行 Sprint回顾（Retrospective），总结经验教训，持续优化团队协作方式。</li></ul></li><li>避免“伪敏捷”<ul><li>部分组织仅采用Scrum会议形式（如每日站会），但未真正遵循敏捷价值观，导致“形似敏捷，实则瀑布”。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google Gemini CLI 配置简要指南</title>
    <link href="/2025/07/18/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Google%20Gemini%20CLI%20%E9%85%8D%E7%BD%AE%E7%AE%80%E8%A6%81%E6%8C%87%E5%8D%97/"/>
    <url>/2025/07/18/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Google%20Gemini%20CLI%20%E9%85%8D%E7%BD%AE%E7%AE%80%E8%A6%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>AI 技术发展日新月异，令人应接不暇。AI 辅助编程的能力也越来越强，以 Claude Code 为首的国外辅助编程工具层出不穷。其中，Google Gemini CLI 以其开源免费的特性备受青睐。</p><p>然而，仅仅是第一步配置就让我卡壳了一个多小时。为了避免大家踩坑，特此记录一下配置过程。</p><h3 id="第一步：下载与安装"><a href="#第一步：下载与安装" class="headerlink" title="第一步：下载与安装"></a>第一步：下载与安装</h3><p>按照官方介绍，首先需要下载并安装。</p><p>要使用 Gemini CLI，你需要先安装 Node.js 18 或更高版本。然后，通过以下命令进行全局安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">npm install -g @google/gemini-cli<br></code></pre></td></tr></table></figure><p>安装完成后，在终端中运行 <code>gemini</code> 命令即可启动。启动后，会提示选择一个颜色主题。</p><h3 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h3><p>根据个人喜好选择一个喜欢的主题。</p><h3 id="选择登录方式"><a href="#选择登录方式" class="headerlink" title="选择登录方式"></a>选择登录方式</h3><p>Gemini CLI 支持三种登录方式：</p><ul><li>Google 个人认证</li><li>Gemini API</li><li>Vertex AI</li></ul><p>强烈建议选择第一种“Google 个人认证”方式。但我本人也是卡在了这里，主要原因是代理问题。你需要将代理软件的端口告诉终端。</p><h4 id="代理问题解决"><a href="#代理问题解决" class="headerlink" title="代理问题解决"></a>代理问题解决</h4><ol><li><p>从你的代理软件中找到代理端口（通常是 <code>7890</code> 或 <code>1080</code> 等）。</p></li><li><p>在终端（如 CMD 或 PowerShell）中输入以下代码，设置 <code>http_proxy</code> 和 <code>https_proxy</code> 环境变量：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">http_proxy</span>=http://127.0.0.1:7890 &amp; <span class="hljs-built_in">set</span> <span class="hljs-attribute">https_proxy</span>=http://127.0.0.1:7890<br></code></pre></td></tr></table></figure></li></ol><p>请将 <code>7890</code> 替换为你实际的代理端口。</p><h3 id="运行-Gemini-CLI"><a href="#运行-Gemini-CLI" class="headerlink" title="运行 Gemini CLI"></a>运行 Gemini CLI</h3><p>完成以上步骤后，在你的项目目录下输入 <code>gemini</code> 命令，就可以开始使用啦！</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/20250718153238841.png" alt="Gemini CLI 启动成功"></p><p>祝你配置顺利！</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>耗散结构理论：从无序到有序的成长哲学</title>
    <link href="/2025/07/16/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%80%97%E6%95%A3%E7%BB%93%E6%9E%84%E7%90%86%E8%AE%BA%EF%BC%9A%E4%BB%8E%E6%97%A0%E5%BA%8F%E5%88%B0%E6%9C%89%E5%BA%8F%E7%9A%84%E6%88%90%E9%95%BF%E5%93%B2%E5%AD%A6/"/>
    <url>/2025/07/16/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%80%97%E6%95%A3%E7%BB%93%E6%9E%84%E7%90%86%E8%AE%BA%EF%BC%9A%E4%BB%8E%E6%97%A0%E5%BA%8F%E5%88%B0%E6%9C%89%E5%BA%8F%E7%9A%84%E6%88%90%E9%95%BF%E5%93%B2%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>你有没有过这样的经历？</p><p>明明制定了详细的学习计划，却总是难以坚持，最终陷入混乱和焦虑？</p><p>在工作或生活中，偶尔会经历“顿悟”的瞬间，但很快又回归低效和平庸？</p><p>想要养成好习惯，却总是被惰性、拖延和外界干扰打败？</p><p>这些问题，其实可以用一个深奥却极具启发性的科学理论来解释——<strong>耗散结构理论</strong>。这个最初诞生于物理和化学领域的理论，不仅揭示了自然界中“从混乱走向有序”的演化机制，也能深刻解释我们个人成长、习惯养成和自我提升背后的规律。</p><p>今天，我们就来聊聊<strong>耗散结构理论的核心思想</strong>，以及如何用它来指导我们实现持续成长，从“无序”走向“有序”。</p><hr><h2 id="一、什么是耗散结构理论？"><a href="#一、什么是耗散结构理论？" class="headerlink" title="一、什么是耗散结构理论？"></a>一、什么是耗散结构理论？</h2><p>耗散结构理论（Dissipative Structure Theory）由比利时物理化学家<strong>伊利亚·普里戈金</strong>（Ilya Prigogine）于 1969 年提出，并因此荣获 1977 年诺贝尔化学奖。<br>在物理学中，<strong>熵</strong>（Entropy）是衡量系统无序程度的一个基本物理量。<strong>熵增原理</strong>指出：在一个<strong>孤立系统</strong>中，如果没有外界干预，系统的总熵（无序程度）只会增加或保持不变，而不会自发减少。<br>热力学第二定律的数学表达如下：</p><p>$$<br>\Delta S \geq 0<br>$$</p><p>其中，$S$ 表示系统的熵，$\Delta S$ 表示熵的变化量。这个不等式意味着：<strong>孤立系统的熵永远不会减少</strong>。</p><p>更具体地，对于一个<strong>开放系统</strong>（如人类个体），熵的变化可以表示为：</p><p>$$<br>\Delta S &#x3D; \Delta S_{\text{内}} + \Delta S_{\text{外}}<br>$$</p><ul><li>$\Delta S_{\text{内}}$：系统内部产生的熵（通常为正，即系统自身趋向混乱）。</li><li>$\Delta S_{\text{外}}$：系统与外界交换带来的熵流（可以为负，即“负熵”）。</li></ul><p>因此，<strong>只有当系统从外界引入足够的负熵</strong>（$\Delta S_{\text{外}} &lt; 0$），才能抵消甚至逆转系统内部的熵增，从而实现从无序到有序的转变。<br>该理论的核心在于：<strong>在一个开放系统中，当系统远离热力学平衡态时，通过与外界持续交换能量与物质，系统可以自发形成有序结构</strong>。<br>换句话说，系统并非总是趋于混乱（熵增），在特定条件下，它也可以从无序中“自组织”出新的秩序。<br>这为理解自然界、生命系统乃至人类社会的复杂演化提供了强有力的理论工具。</p><h2 id="二、耗散结构的四大关键条件"><a href="#二、耗散结构的四大关键条件" class="headerlink" title="二、耗散结构的四大关键条件"></a>二、耗散结构的四大关键条件</h2><h3 id="1-开放性：与外界交换能量和信息"><a href="#1-开放性：与外界交换能量和信息" class="headerlink" title="1. 开放性：与外界交换能量和信息"></a>1. 开放性：与外界交换能量和信息</h3><p>封闭系统最终会走向熵增（即无序），而开放系统则可以通过引入“负熵流”来维持甚至提升自身的有序性。</p><p>✅ <strong>在个人成长中的应用</strong>：</p><ul><li><strong>保持学习</strong>：阅读、听课、交流，不断吸收新知识。</li><li><strong>接受反馈</strong>：主动向高手请教，听取批评，持续调整行为。</li><li><strong>社交互动</strong>：加入优质社群，与志同道合的人互相激励、共同成长。</li></ul><p>❌ <strong>反面例子</strong>：</p><ul><li>闭门造车，拒绝新知识。</li><li>只待在舒适圈，不接触新环境。</li></ul><h3 id="2-远离平衡态：挑战自我，突破舒适区"><a href="#2-远离平衡态：挑战自我，突破舒适区" class="headerlink" title="2. 远离平衡态：挑战自我，突破舒适区"></a>2. 远离平衡态：挑战自我，突破舒适区</h3><p>系统只有在远离平衡态时，才有可能发生结构的重组与跃迁。长期处于平衡态意味着停滞，也意味着熵增的开始。</p><p>✅ <strong>在个人成长中的应用</strong>：</p><ul><li><strong>主动挑战</strong>：尝试新技能（如编程、写作、演讲）。</li><li><strong>设定更高目标</strong>：不满足于现状，不断突破自我极限。</li><li><strong>接受不确定性</strong>：成长本就不是一帆风顺，波动是常态。</li></ul><p>❌ <strong>反面例子</strong>：</p><ul><li>每天重复同样的工作，没有进步。</li><li>害怕失败，不敢尝试新事物。</li></ul><h3 id="3-非线性耦合：成长不是直线上升的"><a href="#3-非线性耦合：成长不是直线上升的" class="headerlink" title="3. 非线性耦合：成长不是直线上升的"></a>3. 非线性耦合：成长不是直线上升的</h3><p>耗散结构的形成依赖于系统内部的非线性相互作用，即<strong>量变积累到一定程度后，才会引发质变</strong>。这种非线性关系解释了为什么成长往往不是匀速的。</p><p>✅ <strong>在个人成长中的应用</strong>：</p><ul><li><strong>坚持积累</strong>：每天进步 1%，一年后就是 37 倍的成长（复利效应）。</li><li><strong>接受波动</strong>：有时进步快，有时停滞甚至倒退，但整体趋势向上。</li><li><strong>抓住关键突破点</strong>：某些时刻（如顿悟、重大事件）可能带来质的飞跃。</li></ul><p>❌ <strong>反面例子</strong>：</p><ul><li>期待“速成”，放弃长期坚持。</li><li>因为短期看不到效果就半途而废。</li></ul><h3 id="4-涨落现象：波动是成长的触发器"><a href="#4-涨落现象：波动是成长的触发器" class="headerlink" title="4. 涨落现象：波动是成长的触发器"></a>4. 涨落现象：波动是成长的触发器</h3><p>涨落（微小波动）是系统从无序走向有序的起点。在远离平衡态的系统中，微小扰动可能被放大，从而引发新的有序结构。</p><p>✅ <strong>在个人成长中的应用</strong>：</p><ul><li><strong>低谷期是机会</strong>：失败、迷茫往往是突破的前兆。</li><li><strong>利用“顿悟时刻”</strong>：突如其来的灵感或新认知，可能改变成长轨迹。</li><li><strong>调整策略</strong>：当旧方法失效时，尝试新方向。</li></ul><p>❌ <strong>反面例子</strong>：</p><ul><li>遇到挫折就放弃。</li><li>忽视灵感，错过改变的机会。</li></ul><h2 id="三、如何用耗散结构理论指导个人成长？"><a href="#三、如何用耗散结构理论指导个人成长？" class="headerlink" title="三、如何用耗散结构理论指导个人成长？"></a>三、如何用耗散结构理论指导个人成长？</h2><h3 id="1-构建“抗熵增”成长系统"><a href="#1-构建“抗熵增”成长系统" class="headerlink" title="1. 构建“抗熵增”成长系统"></a>1. 构建“抗熵增”成长系统</h3><ul><li><strong>输入负熵</strong>：持续学习、结交优秀的人、接触新领域。</li><li><strong>减少熵增</strong>：减少无意义的娱乐、无效社交、消极情绪。</li></ul><h3 id="2-让成长“自组织”"><a href="#2-让成长“自组织”" class="headerlink" title="2. 让成长“自组织”"></a>2. 让成长“自组织”</h3><ul><li><strong>建立习惯</strong>：每天固定时间学习、运动、复盘。</li><li><strong>优化环境</strong>：加入学习社群、使用效率工具、减少干扰。</li></ul><h3 id="3-利用“涨落”突破瓶颈"><a href="#3-利用“涨落”突破瓶颈" class="headerlink" title="3. 利用“涨落”突破瓶颈"></a>3. 利用“涨落”突破瓶颈</h3><ul><li><strong>低谷期</strong>：调整策略，寻找新方法。</li><li><strong>高峰期</strong>：加速学习，巩固优势。</li></ul><h2 id="四、我的个人感悟"><a href="#四、我的个人感悟" class="headerlink" title="四、我的个人感悟"></a>四、我的个人感悟</h2><p>成长从来不是匀速的，有时快，有时慢，关键是<strong>长期趋势向上</strong>。</p><p>波动是正常的，<strong>低谷可能是突破的前兆</strong>。</p><p>比起盲目努力，<strong>保持开放的心态更为重要</strong>。封闭自己只会让熵增更快。</p><p><strong>习惯的力量不可小觑</strong>。看似微小的坚持，最终会带来质的飞跃。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>耗散结构理论告诉我们：<strong>混乱不是终点，而是新秩序的开始</strong>。</p><p>只要我们保持开放、远离平衡、接受非线性成长，并善于利用涨落突破瓶颈，就能从“无序”走向“有序”，实现真正的持续成长。</p><p>你的生活，是一个耗散结构吗？你是否在主动引入“负熵流”？</p><p>欢迎在评论区分享你的成长心得！🚀</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI 应用 视频摄像头秒变智慧水尺</title>
    <link href="/2025/07/15/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/AI%20%E5%BA%94%E7%94%A8%E4%B9%8B%20%E8%A7%86%E9%A2%91%E6%91%84%E5%83%8F%E5%A4%B4%E7%A7%92%E5%8F%98%E6%99%BA%E6%85%A7%E6%B0%B4%E5%B0%BA/"/>
    <url>/2025/07/15/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/AI%20%E5%BA%94%E7%94%A8%E4%B9%8B%20%E8%A7%86%E9%A2%91%E6%91%84%E5%83%8F%E5%A4%B4%E7%A7%92%E5%8F%98%E6%99%BA%E6%85%A7%E6%B0%B4%E5%B0%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h3 id="告别高昂成本：AI-如何将普通摄像头变为智慧“水尺”"><a href="#告别高昂成本：AI-如何将普通摄像头变为智慧“水尺”" class="headerlink" title="告别高昂成本：AI 如何将普通摄像头变为智慧“水尺”"></a>告别高昂成本：AI 如何将普通摄像头变为智慧“水尺”</h3><p>在水资源管理和防汛抗旱的战线上，对河道、水库水位的实时精准监控至关重要。长久以来，我们依赖超声波、雷达或压力式水位计等传统监测手段，但它们普遍存在建设成本高、维护复杂、易受恶劣环境影响等问题。如今，随着人工智能（AI）技术的飞速发展，一场颠覆性的变革正在悄然发生——我们完全可以利用无处不在的视频摄像头，以极低的成本“顺便”获取精确的水位信息。</p><p>这篇博客将深入探讨如何利用 AI 视频识别技术，将您现有的或低成本新装的摄像头，打造成一个全天候、高精度、免维护的智能“水尺”。</p><hr><h4 id="传统水位监测的痛点"><a href="#传统水位监测的痛点" class="headerlink" title="传统水位监测的痛点"></a>传统水位监测的痛点</h4><p>在介绍 AI 新方法之前，我们先快速回顾一下传统水位监测方式的局限性：</p><ul><li><strong>超声波&#x2F;雷达水位计</strong>：虽然是非接触式测量，相对先进，但设备本身价格不菲，且对安装角度、波束范围有严格要求，后期的专业维护亦是一笔不小的开销。</li><li><strong>压力式&#x2F;浮子式水位计</strong>：这类接触式设备需要建设测井，土建成本高昂。此外，它们极易受到泥沙淤积、水中漂浮物、冬季结冰等因素的干扰，导致故障频发，数据失准，需要频繁的人工清理和校准。</li><li><strong>人工读尺</strong>：最原始的方式，依赖人工定时定点观察实体水尺。这种方法不仅效率低下、数据实时性差，而且在洪水、暴雨等恶劣天气下，观测人员的安全也面临巨大风险。</li></ul><p>显然，传统方法在成本、效率和安全性上都存在明显的短板。而 AI 视频分析技术的出现，为解决这些痛点提供了全新的、极具吸引力的思路。</p><h4 id="AI-视频水位监测：便捷、经济、高效的新范式"><a href="#AI-视频水位监测：便捷、经济、高效的新范式" class="headerlink" title="AI 视频水位监测：便捷、经济、高效的新范式"></a>AI 视频水位监测：便捷、经济、高效的新范式</h4><p>其核心思想非常巧妙：<strong>利用计算机视觉技术，让 AI 学会像人一样“读取”水尺上的刻度</strong>。更进一步，即使没有实体水尺，AI 也能通过识别固定参照物，建立起一把虚拟的水尺来完成测量。这一过程几乎是全自动的，可以 7 x 24 小时不间断工作。</p><p><strong>实现这一“黑科技”，主要分三步走：</strong></p><p><strong>第一步：架设“眼睛”—— 摄像头与物理标尺</strong></p><p>系统只需要一个固定的“眼睛”—— 一个能够清晰拍摄到水面的普通高清摄像头。为了给 AI 一个可靠的参照基准，我们需要在岸边设置一个物理标尺。</p><ul><li><strong>实体水尺</strong>：最直接的方式是安装一把传统的物理水尺。这是 AI 学习和识别的直接对象。</li><li><strong>固定标线&#x2F;参照物</strong>：在没有条件安装水尺的地方，可以利用桥墩、堤坝、甚至是一根固定的杆子作为参照。只要这个物体的位置是固定的，我们就可以通过初始标定，赋予它“水尺”的功能。</li></ul><p>这种方式的优势在于硬件投入极低，很多场景甚至可以利旧改造，直接利用已有的安防监控摄像头。</p><p><strong>第二步：创建“虚拟标尺”—— 图像处理与 AI 算法</strong></p><p>这是将“看见”转化为“读懂”的关键一步，也是 AI 大显身手的环节。</p><ol><li><p><strong>图像采集与预处理</strong>：系统从视频流中抓取图像。为了应对光照变化、雨雾天气等干扰，AI 会首先对图像进行增强、去噪、校正等预处理。</p></li><li><p><strong>水尺定位与识别</strong>：AI 视觉模型（如基于 YOLOv 7 等深度学习框架的模型）会自动在画面中找到水尺或预设的参照物。这一步利用了目标检测技术，能够精准锁定“测量工具”的位置。</p></li><li><p><strong>水面线检测</strong>：这是核心技术之一。AI 通过语义分割等算法，精确地将图像分割成“水体”和“非水体”两个区域。这条分割线，就是至关重要的“水位线”。相较于传统图像处理方法，深度学习模型能够更好地应对水面反光、波纹、倒影等复杂情况。</p></li><li><p><strong>读数计算</strong>：在定位了水尺并识别出水位线后，系统会将像素坐标与实际物理高度进行换算。这个换算关系在系统初次部署时通过“相机标定”一次性建立。无论是实体水尺还是虚拟标尺，AI 都能根据水位线落在标尺上的相对位置，精确计算出当前的水位数值。</p></li></ol><p><strong>第三步：智能分析与预警</strong></p><p>获取水位数据只是开始。AI 系统还能：</p><ul><li><strong>实时预警</strong>：当监测到水位超过预设的安全阈值时，系统会立即自动报警，并通过平台、短信、APP 等多种方式通知管理人员。</li><li><strong>数据可视化与趋势分析</strong>：所有数据被记录下来，形成历史曲线，管理人员可以清晰地看到水位变化的趋势，为防汛调度和水资源管理提供决策依据。</li><li><strong>提供视觉佐证</strong>：与传统传感器只能提供一个冰冷的数字不同，AI 视频方案保留了现场的影像。管理人员可以随时查看实时视频或历史录像，直观了解现场情况，判断高水位是由降雨引起还是由漂浮物堵塞造成，为决策提供更丰富的信息。</li></ul><hr><h4 id="AI-方案的压倒性优势"><a href="#AI-方案的压倒性优势" class="headerlink" title="AI 方案的压倒性优势"></a>AI 方案的压倒性优势</h4><p>相较于传统方法，AI 视频监测的优势是全方位的：</p><ul><li><strong>极低的建设与维护成本</strong>：主要成本就是一个摄像头和一台边缘计算设备或云服务器。无需昂贵的专业传感器，无需复杂的土建工程。后期维护也极为简便，基本实现了“无人值守”。</li><li><strong>一机多能，价值倍增</strong>：摄像头除了监测水位，其视频流还可以被复用。例如，通过加载不同的 AI 算法，同一个摄像头还能同时实现对水面漂浮物、非法排污、船只闯入、人员落水、岸边垃圾堆放等的智能识别与预警，最大化投资效益。</li><li><strong>高适应性与稳定性</strong>：非接触式的测量方式使其不受泥沙、水质污染的影响。先进的 AI 算法能有效克服光照、天气、水波等环境干扰，保证了数据的准确性和系统的鲁棒性（即稳定性）。</li><li><strong>安全便捷，远程管控</strong>：管理人员足不出户，通过电脑或手机即可实时查看水位数据和现场视频，极大地提升了工作效率，并避免了恶劣天气下人工巡查的风险。</li></ul><p>目前，这项技术已经不再是实验室里的概念，在长江航道治理、城市内涝监测等众多场景中都已有了成功的应用案例。天地伟业、新华三等科技公司也推出了相关的智慧水利解决方案。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>利用移动物理标尺和 AI 视频分析来获取水位信息的想法，完全切中了当前智慧水利发展的脉搏。它将昂贵的专业监测任务，转化为 AI 视频监控系统的一个“顺便”即可完成的增值功能。这不仅是技术的创新，更是管理思维的革新。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
      <tag>AIGC</tag>
      
      <tag>AI应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零成本实现AI视频监控识别方案 以河道水质监控为例</title>
    <link href="/2025/07/11/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E9%9B%B6%E6%88%90%E6%9C%AC%E5%AE%9E%E7%8E%B0AI%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E8%AF%86%E5%88%AB%E6%96%B9%E6%A1%88%20%E4%BB%A5%E6%B2%B3%E9%81%93%E6%B0%B4%E8%B4%A8%E7%9B%91%E6%8E%A7%E4%B8%BA%E4%BE%8B/"/>
    <url>/2025/07/11/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E9%9B%B6%E6%88%90%E6%9C%AC%E5%AE%9E%E7%8E%B0AI%E8%A7%86%E9%A2%91%E7%9B%91%E6%8E%A7%E8%AF%86%E5%88%AB%E6%96%B9%E6%A1%88%20%E4%BB%A5%E6%B2%B3%E9%81%93%E6%B0%B4%E8%B4%A8%E7%9B%91%E6%8E%A7%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>之前曾写过利用阿里开源视觉模型构建 AI 视频识别的文章，最近发现硅基流动最近发布了免费视觉模型 THUDM&#x2F;GLM-4.1 V-9 B-Thinking，就想把之前的想法进行落地，于是有了今天的这篇。</p><p>本方案旨在通过调用硅基流动的免费视觉模型 API，截取监控视频流图片，并结合特定的提示词，实现视频监控的智能化识别功能。</p><h2 id="一、背景介绍"><a href="#一、背景介绍" class="headerlink" title="一、背景介绍"></a>一、背景介绍</h2><h3 id="1-行业与政策背景"><a href="#1-行业与政策背景" class="headerlink" title="1. 行业与政策背景"></a>1. 行业与政策背景</h3><p>近年来，随着国家对生态文明建设和水环境治理的高度重视，流域水质监测已成为生态环境保护工作的重中之重。《水污染防治行动计划》《长江保护法》《“十四五”生态环境保护规划》等文件相继出台，明确提出要加强水环境自动监测能力，推动智能化、数字化监管手段的应用。</p><p>在这一背景下，河道视频监控、水库视频监控、排污口视频监控以及污水处理厂视频监控系统已广泛部署，而针对视频内容进行自动化分析的需求也日益增长。</p><h3 id="2-现实痛点"><a href="#2-现实痛点" class="headerlink" title="2. 现实痛点"></a>2. 现实痛点</h3><p>尽管视频监控系统已在环保领域广泛应用，但在实际操作中仍存在诸多挑战：</p><ul><li><strong>人工巡查难以覆盖全面</strong>：河道、湖泊、污水处理厂等区域点多面广，传统人工巡查效率低、成本高。</li><li><strong>数据获取滞后与主观性强</strong>：目前多数为定期采样检测，无法实时发现突发污染事件，且依赖人员经验判断，结果易受主观因素影响。</li><li><strong>异常事件响应不及时</strong>：污水溢流、漂浮物堆积、藻类爆发等问题往往不能第一时间被发现，延误应急处置。</li><li><strong>监管压力大</strong>：环保部门人手有限，面对日益增长的监管需求，亟需借助新技术提升监管效能。</li></ul><h3 id="3-AI-技术带来的新机遇"><a href="#3-AI-技术带来的新机遇" class="headerlink" title="3. AI 技术带来的新机遇"></a>3. AI 技术带来的新机遇</h3><p>随着计算机视觉与多模态大模型的快速发展，AI 技术为水环境监测带来了全新的解决方案：</p><ul><li>利用视觉大模型实现全天候、标准化、客观化的水质异常识别；</li><li>充分挖掘现有视频资源的价值，提升监控系统的智能化水平；</li><li>自动化识别典型问题（如污水溢流、漂浮物、藻类爆发），辅助决策与预警。</li></ul><h2 id="二、系统实现路径"><a href="#二、系统实现路径" class="headerlink" title="二、系统实现路径"></a>二、系统实现路径</h2><h3 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1. 需求分析"></a>1. 需求分析</h3><p>本项目以“智能识别+自动分析”为核心目标，旨在通过 AI 模型对视频监控画面进行持续解析，识别潜在的水质异常问题，包括但不限于：</p><ul><li>疑似污水溢流</li><li>疑似漂浮物</li><li>疑似藻类爆发</li><li>疑似排污口排污</li><li>疑似农业污染源</li></ul><p>同时要求输出明确的问题分类、位置描述、严重程度评估及初步建议，形成标准化报告。</p><h3 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2. 系统设计"></a>2. 系统设计</h3><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>系统采用前后端分离架构，模块化设计，便于扩展和维护，支持多站点接入、多设备兼容。</p><h4 id="数据流转流程"><a href="#数据流转流程" class="headerlink" title="数据流转流程"></a>数据流转流程</h4><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507111636069.png" alt="流程"></p><h4 id="用户界面设计"><a href="#用户界面设计" class="headerlink" title="用户界面设计"></a>用户界面设计</h4><p>前端使用 Streamlit 快速搭建可视化 Web 界面，支持图片上传测试、视频流展示、历史记录查看等功能。</p><h3 id="3-开发与测试"><a href="#3-开发与测试" class="headerlink" title="3. 开发与测试"></a>3. 开发与测试</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>整理各地监控点台账，清洗并统一主键标识，确保数据一致性。</p><h4 id="核心功能开发"><a href="#核心功能开发" class="headerlink" title="核心功能开发"></a>核心功能开发</h4><ul><li>实现视频流地址获取、视频帧截取、图像上传与模型调用；</li><li>支持手动上传图片进行模型验证；</li><li>提供定时任务机制，实现自动化分析。</li></ul><h4 id="大模型集成"><a href="#大模型集成" class="headerlink" title="大模型集成"></a>大模型集成</h4><p>接入硅基流动平台提供的免费视觉模型 <strong>THUDM&#x2F;GLM-4.1 V-9 B-Thinking</strong>，结合提示词工程优化，提高识别准确率。</p><h4 id="联调测试"><a href="#联调测试" class="headerlink" title="联调测试"></a>联调测试</h4><p>与多个真实监控点对接，反复测试各类典型场景，确保系统稳定性与识别效果。</p><hr><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><h3 id="1-城市河道智能监管"><a href="#1-城市河道智能监管" class="headerlink" title="1. 城市河道智能监管"></a>1. 城市河道智能监管</h3><ul><li>对城市主要河流断面进行实时视频监控；</li><li>自动识别污水直排、垃圾漂浮、藻类异常等现象；</li><li>与智慧水务平台联动，实现跨部门协同监管。</li></ul><h3 id="2-农村水体与小微水域监测"><a href="#2-农村水体与小微水域监测" class="headerlink" title="2. 农村水体与小微水域监测"></a>2. 农村水体与小微水域监测</h3><ul><li>针对农村沟渠、池塘等分散水体部署低成本摄像头；</li><li>AI 自动识别异常，辅助乡镇环保人员日常巡查；</li><li>提升农村地区水环境治理水平。</li></ul><h3 id="3-工业园区与污水处理厂监管"><a href="#3-工业园区与污水处理厂监管" class="headerlink" title="3. 工业园区与污水处理厂监管"></a>3. 工业园区与污水处理厂监管</h3><ul><li>实时监控工业园区排污口、污水处理厂进出水情况；</li><li>发现异常排放、设备故障等问题，及时告警；</li><li>可与企业自查、第三方运维系统整合，提升监管覆盖面。</li></ul><h3 id="4-应急与专项监测"><a href="#4-应急与专项监测" class="headerlink" title="4. 应急与专项监测"></a>4. 应急与专项监测</h3><ul><li>在汛期、突发污染事件期间临时布控摄像头，AI 辅助应急指挥；</li><li>重大节假日、专项整治行动期间提升监管频次与响应速度。</li></ul><hr><h2 id="四、实施效果与价值"><a href="#四、实施效果与价值" class="headerlink" title="四、实施效果与价值"></a>四、实施效果与价值</h2><h3 id="1-监管效率显著提升"><a href="#1-监管效率显著提升" class="headerlink" title="1. 监管效率显著提升"></a>1. 监管效率显著提升</h3><ul><li>实现 7×24 小时不间断自动监控；</li><li>异常事件可在秒级被识别，大幅减少人工巡查频次；</li><li>降低人力成本，提升工作效率。</li></ul><h3 id="2-监管精度与客观性提升"><a href="#2-监管精度与客观性提升" class="headerlink" title="2. 监管精度与客观性提升"></a>2. 监管精度与客观性提升</h3><ul><li>AI 模型标准化识别流程，避免人为疏漏与误判；</li><li>所有分析过程与结果均可追溯，便于责任认定；</li><li>支持多维度对比分析，提升数据可信度。</li></ul><h3 id="3-响应速度与应急能力增强"><a href="#3-响应速度与应急能力增强" class="headerlink" title="3. 响应速度与应急能力增强"></a>3. 响应速度与应急能力增强</h3><ul><li>对污水溢流、漂浮物、藻类爆发等突发事件实现快速响应；</li><li>支持自动推送告警信息，触发联动处置机制；</li><li>提高应急管理效率，缩短响应时间。</li></ul><hr><h2 id="五、功能演示图示"><a href="#五、功能演示图示" class="headerlink" title="五、功能演示图示"></a>五、功能演示图示</h2><p>下图为系统核心功能截图：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507111609857.png"></p><blockquote><p>上传图片进行模型测试与提示词调试：</p></blockquote><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507111610867.png"></p><blockquote><p>截取视频流图片进行自动分析，输出识别结果：</p></blockquote><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507111611598.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/%E4%B8%8A%E4%BC%A0%E8%AF%84%E4%BC%B0%E7%A4%BA%E4%BE%8B.png"></p><h2 id="六、未来展望"><a href="#六、未来展望" class="headerlink" title="六、未来展望"></a>六、未来展望</h2><h3 id="1-持续优化-AI-模型"><a href="#1-持续优化-AI-模型" class="headerlink" title="1. 持续优化 AI 模型"></a>1. 持续优化 AI 模型</h3><ul><li>探索更多视觉大模型，提升复杂场景下的识别准确率；</li><li>优化推理速度，适应边缘计算场景。</li></ul><h3 id="2-提升提示词工程能力"><a href="#2-提升提示词工程能力" class="headerlink" title="2. 提升提示词工程能力"></a>2. 提升提示词工程能力</h3><ul><li>细化识别类别，拓展应用场景；</li><li>丰富输出格式，提高报告实用性。</li></ul><h3 id="3-推进硬件集成"><a href="#3-推进硬件集成" class="headerlink" title="3. 推进硬件集成"></a>3. 推进硬件集成</h3><ul><li>与轻量级摄像头、边缘计算设备集成，打造低成本 AI 视频装置；</li><li>实现现场识别与本地处理，降低网络依赖。</li></ul><h3 id="4-拓展识别指标"><a href="#4-拓展识别指标" class="headerlink" title="4. 拓展识别指标"></a>4. 拓展识别指标</h3><ul><li>探索水色、水位、流速等更多水质相关参数的智能识别。</li></ul><h2 id="七、结语"><a href="#七、结语" class="headerlink" title="七、结语"></a>七、结语</h2><p>本项目基于硅基流动平台提供的免费视觉大模型 <strong>THUDM&#x2F;GLM-4.1 V-9 B-Thinking</strong>，实现了对视频监控画面的智能识别与分析，为流域水质监管提供了新的技术支撑。系统具备良好的扩展性与落地性，已在多个实际场景中得到验证，具备向更广泛区域推广的基础条件。</p><p>如果你也在探索 AI + 视频监控在环保领域的应用，欢迎交流探讨，共同推进生态环保的智能化转型！</p><h3 id="硅基流动邀请链接"><a href="#硅基流动邀请链接" class="headerlink" title="硅基流动邀请链接"></a>硅基流动邀请链接</h3><p>最近硅基流动在做推广活动，用下面的链接注册，就可以获得 2000 万 Tokens（14 元平台配额），如果需要，就用下面的链接注册吧。<br>模型邀请链接：<br><a href="https://cloud.siliconflow.cn/i/p61lgKxB">https://cloud.siliconflow.cn/i/p61lgKxB</a><br>邀请码：p 61 lgKxB</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>AIGC</tag>
      
      <tag>大模型</tag>
      
      <tag>视觉模型</tag>
      
      <tag>模型应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于连续地表水水质自动站的流速与降解系数自动识别算法</title>
    <link href="/2025/07/07/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E5%9F%BA%E4%BA%8E%E8%BF%9E%E7%BB%AD%E5%9C%B0%E8%A1%A8%E6%B0%B4%E6%B0%B4%E8%B4%A8%E8%87%AA%E5%8A%A8%E7%AB%99%E7%9A%84%E6%B5%81%E9%80%9F%E4%B8%8E%E9%99%8D%E8%A7%A3%E7%B3%BB%E6%95%B0%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/"/>
    <url>/2025/07/07/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E5%9F%BA%E4%BA%8E%E8%BF%9E%E7%BB%AD%E5%9C%B0%E8%A1%A8%E6%B0%B4%E6%B0%B4%E8%B4%A8%E8%87%AA%E5%8A%A8%E7%AB%99%E7%9A%84%E6%B5%81%E9%80%9F%E4%B8%8E%E9%99%8D%E8%A7%A3%E7%B3%BB%E6%95%B0%E8%87%AA%E5%8A%A8%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文提出了一种基于自动站数据的多波峰自动配对与参数反演算法，旨在解决流域水质模型中流速与降解系数难以自动识别的问题。该算法兼顾学术理论与工程应用，能够在复杂水文条件下，自动、批量、稳健地反推出河流区间的流速与降解系数。在重庆 XX 流域的应用中，该算法相比传统方法，模型精度有明显提升。实验结果表明，该方法能够为水环境管理和污染溯源提供有力支撑，并为流域污染物排放控制和应急响应提供决策支持。</p><h2 id="1-研究背景与意义"><a href="#1-研究背景与意义" class="headerlink" title="1. 研究背景与意义"></a>1. 研究背景与意义</h2><ul><li><strong>自动站数据价值</strong>：地表水自动站可实现高频、连续、时空分布广的水质监测，为流域水质模型，如一维水动力-水质模型，提供了丰富的数据基础。</li><li><strong>参数识别难点</strong>：传统流速和降解系数多依赖人工实验或经验估算，这些方法耗时耗力、主观性强，难以反映动态变化和多事件场景。</li><li><strong>自动化需求</strong>：亟需一种能自动适应不同水文期、自动识别污染事件、批量反演参数的智能算法。</li></ul><hr><h2 id="2-算法原理与流程"><a href="#2-算法原理与流程" class="headerlink" title="2. 算法原理与流程"></a>2. 算法原理与流程</h2><h3 id="2-1-一维河流降解模型"><a href="#2-1-一维河流降解模型" class="headerlink" title="2.1 一维河流降解模型"></a>2.1 一维河流降解模型</h3><p>污染物在河道中的一阶降解模型：该模型适用于均匀河流，忽略了横向和垂向的浓度差异。</p><p>$$</p><p>C(x) &#x3D; C_0 \cdot e^{-\frac{kx}{v}}</p><p>$$</p><ul><li>$C(x)$：下游浓度，mg&#x2F;L;</li><li>$C_0$：上游浓度，mg&#x2F;L;</li><li>$k$：降解系数 1&#x2F;d;</li><li>$v$：流速（迁移速度）km&#x2F;d;</li><li>$x$：区间距离，km。</li></ul><h3 id="2-2-多波峰自动配对与参数反演"><a href="#2-2-多波峰自动配对与参数反演" class="headerlink" title="2.2 多波峰自动配对与参数反演"></a>2.2 多波峰自动配对与参数反演</h3><ol><li><p><strong>数据预处理</strong>：对自动站数据按站点、因子、时间进行清洗、对齐，并采用线性插值法处理缺失值，对超出合理范围的数值进行剔除。</p></li><li><p><strong>波峰识别</strong>：采用滑动窗口极大值+prominence 算法，自动识别每月的局部波峰，适应不同水文期。其中，prominence 参数表示波峰的显著程度，根据经验，设置为 0.1，以滤除噪声干扰。</p></li><li><p><strong>相关性配对</strong>：对每个上游波峰，在下游自适应时间窗口内，截取波形片段，计算皮尔逊相关系数，筛选相关性大于 0.6 的配对。相关性阈值 0.6 是根据大量实验数据统计分析得到的经验值，可能存在一定的误差，需要根据具体情况进行调整。</p></li><li><p><strong>参数反演</strong>：对每对配对波峰，根据时间差 $\Delta t$ 和浓度变化，自动反推出流速 $v$ 和降解系数 $k$。</p><p>流速 $v$ 的计算公式为：$v &#x3D; x &#x2F; \Delta t$</p><p>降解系数 $k$ 的计算公式为：$k &#x3D; -v \cdot ln(C(x) &#x2F; C_0) &#x2F; x$</p></li><li><p><strong>批量输出</strong>：所有站点对、所有因子的参数结果自动拼接汇总，便于后续建模和统计。</p></li></ol><hr><h2 id="3-算法实现与工程细节"><a href="#3-算法实现与工程细节" class="headerlink" title="3. 算法实现与工程细节"></a>3. 算法实现与工程细节</h2><ul><li><strong>Python 实现</strong>：基于 pandas、numpy、scipy、matplotlib 等主流科学计算库，代码结构清晰，易于扩展。</li><li><strong>健壮性处理</strong>：自动跳过无数据或异常数据的站点对与因子组合，保证批量运行稳定。其中，异常数据的判断采用 3σ原则，当数据超出平均值 3 倍标准差范围时，则被认为是异常值。</li><li><strong>参数自适应</strong>：每对站点可单独配置匹配窗口，适应丰&#x2F;枯水期差异。丰水期采用较短的匹配窗口，枯水期采用较长的匹配窗口，具体窗口长度根据历史数据统计分析确定。</li><li><strong>可视化辅助</strong>：自动生成每月波峰识别与配对结果图，直观展示算法效果，用于人工审核和问题诊断。</li><li><strong>结果标准化</strong>：输出字段包含起点、终点、距离、因子、k、v、时间差、相关性等，便于后续自动化调用。</li></ul><hr><h2 id="4-应用案例"><a href="#4-应用案例" class="headerlink" title="4. 应用案例"></a>4. 应用案例</h2><p>以重庆 XX 流域自动站数据为例，选取 XX 站点和 YY 站点之间的数据区间（数据时间范围为 2024 年 1 月 1 日至 2024 年 6 月 30 日），自动识别高锰酸盐指数、总磷等多因子的流速与降解系数。算法可自动适应 180 天历史数据，批量输出多组参数，从输出结果图标看出，峰值关联性识别效果非常好。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071644121.png" alt="自动识别相互关联的波峰"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071645028.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071645474.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071653765.png" alt="image.png">  </p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071656827.png" alt="image.png">  </p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071646473.png" alt="自动识别波峰数量"><br>自动识别波峰数量</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202507071649543.png" alt="自动识别相互关联的波峰"><br>自动批量求 k v 。</p><h2 id="5-优势与创新点"><a href="#5-优势与创新点" class="headerlink" title="5. 优势与创新点"></a>5. 优势与创新点</h2><ul><li><strong>全自动化</strong>：无需人工干预，适合大规模、长时序数据批量处理。</li><li><strong>多事件适应</strong>：可识别多次污染事件，反映真实水文过程。</li><li><strong>相关性配对</strong>：有效排除偶然波峰，提升参数物理意义，通过排除虚假波峰，避免了将随机扰动误判为污染事件。</li></ul><hr><h2 id="6-展望与改进方向"><a href="#6-展望与改进方向" class="headerlink" title="6. 展望与改进方向"></a>6. 展望与改进方向</h2><ul><li><strong>更智能的事件识别</strong>：可引入机器学习、动态规划等方法，进一步提升波峰配对智能化水平，例如，采用 LSTM 神经网络预测波峰的到达时间，提高配对的准确性。</li><li><strong>实时在线应用</strong>：结合实时数据流，实现参数的动态更新与预警，用于突发水污染事件的预警和应急响应。</li><li><strong>分析结果，优化滑动区间</strong>：结合实际案例，说明如何根据分析结果优化滑动区间。</li></ul><h2 id="7-附录：核心代码片段"><a href="#7-附录：核心代码片段" class="headerlink" title="7. 附录：核心代码片段"></a>7. 附录：核心代码片段</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以站点对和因子为循环，自动批量识别K/V参数</span><br><span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> station_links:<br>    s1, s2, x, default_window = link[<span class="hljs-string">&quot;起点&quot;</span>], link[<span class="hljs-string">&quot;终点&quot;</span>], link[<span class="hljs-string">&quot;距离&quot;</span>], link[<span class="hljs-string">&quot;默认滑动窗口(h)&quot;</span>]<br>    <span class="hljs-keyword">for</span> factor <span class="hljs-keyword">in</span> jili_factors:<br>        <span class="hljs-comment"># 调用auto_kv_multi_peaks_corr函数，计算流速和降解系数</span><br>        kv_df = auto_kv_multi_peaks_corr(<br>            df, s1, s2, factor, x,<br>            time_window_dict=<span class="hljs-literal">None</span>,<br>            default_time_window=default_window,<br>            waveform_window=<span class="hljs-number">12</span>,<br>            corr_threshold=<span class="hljs-number">0.6</span><br>        )<br>        <span class="hljs-comment"># ...结果拼接与保存...</span><br></code></pre></td></tr></table></figure><p><strong>本算法已在实际流域水质管理项目中成功应用，欢迎交流与合作！</strong></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫实战 批量下载环评受理公示</title>
    <link href="/2025/06/29/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%20%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E7%8E%AF%E8%AF%84%E5%8F%97%E7%90%86%E5%85%AC%E7%A4%BA/"/>
    <url>/2025/06/29/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%20%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E7%8E%AF%E8%AF%84%E5%8F%97%E7%90%86%E5%85%AC%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>作为环境工程从业者，我经常需要查阅各类环评报告作为学习参考资料。这些报告虽然都是全文公开的，但每次都要手动一个个查找下载非常耗时。最近我终于下定决心要解决这个问题，利用Python开发了一个自动化采集系统，能够批量下载环评公示报告。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>这个爬虫系统主要包含以下几个功能模块：</p><ol><li><strong>分页检测模块</strong>：自动识别公告总页数    </li><li><strong>链接提取模块</strong>：从每页获取所有公告链接    </li><li><strong>内容解析模块</strong>：提取公告标题、日期、正文等关键信息    </li><li><strong>附件处理模块</strong>：智能识别并下载各类附件    </li><li><strong>本地存储模块</strong>：将内容保存为结构化的Markdown格式</li></ol><h3 id="核心功能亮点"><a href="#核心功能亮点" class="headerlink" title="核心功能亮点"></a>核心功能亮点</h3><ol><li><strong>智能分页处理</strong>：采用三重检测机制确保准确获取总页数    <ul><li>解析分页DOM元素        </li><li>匹配页面文本中的页数信息        </li><li>自动探测最后一页</li></ul></li><li><strong>内容增强提取</strong>：通过多选择器组合确保内容获取成功率    </li><li><strong>附件智能命名</strong>：基于公告内容自动生成有意义的附件文件名    </li><li><strong>完善的错误处理</strong>：每个关键步骤都有异常捕获和重试机制</li></ol><h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><p>经过实际测试，该系统能够：</p><ul><li>自动识别22页共计200+条公告    </li><li>准确提取每条公告的完整内容    </li><li>智能下载PDF、Word等各类附件    </li><li>按项目分类存储到本地目录</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250629_214646.png" alt="下载效果截图"></p><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><p>虽然当前版本已经能满足基本需求，但还有不少优化空间：</p><ol><li><strong>信息结构化</strong>：提取建设单位、项目地点等关键字段构建数据库    </li><li><strong>内容分析</strong>：对报告文本进行NLP处理提取关键信息    </li><li><strong>可视化展示</strong>：生成项目地理分布图、时间趋势图等    </li><li><strong>自动化更新</strong>：设置定时任务自动获取最新公告</li></ol><h2 id="法律声明"><a href="#法律声明" class="headerlink" title="法律声明"></a>法律声明</h2><p>需要特别说明的是：</p><ol><li>本工具仅用于个人学习研究    </li><li>请控制采集频率，避免对服务器造成负担    </li><li>不得将采集数据用于商业用途    </li><li>请遵守网站robots.txt的相关规定</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过这个项目，我深刻体会到Python在信息采集处理方面的强大能力。后续我计划继续优化这个工具，也欢迎有兴趣的朋友一起交流探讨。<br>最后需要说明的是每一个城市的网页都是不尽相同的，需要单独进行微调，我的代码也只是某一个城市的，不能通用。为了规避责任我隐去了网址。</p><p>附上完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urljoin, urlparse<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EIAAnnouncementCrawler</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.base_url = <span class="hljs-string">&quot;  网址~脱敏 &quot;</span><br>        self.output_dir = <span class="hljs-string">&quot;环评公告&quot;</span><br>        self.attachments_dir = os.path.join(self.output_dir, <span class="hljs-string">&quot;附件&quot;</span>)<br>        self.headers = &#123;<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&#x27;</span>,<br>            <span class="hljs-string">&#x27;Accept&#x27;</span>: <span class="hljs-string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&#x27;</span>,<br>            <span class="hljs-string">&#x27;Accept-Language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;</span>,<br>            <span class="hljs-string">&#x27;Accept-Encoding&#x27;</span>: <span class="hljs-string">&#x27;gzip, deflate&#x27;</span>,<br>            <span class="hljs-string">&#x27;Connection&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>            <span class="hljs-string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>        &#125;<br>        <br>        <span class="hljs-comment"># 创建目录</span><br>        os.makedirs(self.output_dir, exist_ok=<span class="hljs-literal">True</span>)<br>        os.makedirs(self.attachments_dir, exist_ok=<span class="hljs-literal">True</span>)<br>        <br>        <span class="hljs-comment"># 统计信息</span><br>        self.stats = &#123;<br>            <span class="hljs-string">&#x27;total_pages&#x27;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&#x27;total_announcements&#x27;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&#x27;successful_downloads&#x27;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&#x27;failed_downloads&#x27;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-string">&#x27;attachments_downloaded&#x27;</span>: <span class="hljs-number">0</span><br>        &#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_total_pages</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;第一步：识别公告总共有多少页&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正在获取总页数...&quot;</span>)<br>            response = requests.get(self.base_url, headers=self.headers, timeout=<span class="hljs-number">15</span>)<br>            response.raise_for_status()<br>            response.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>            <br>            soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>            <br>            <span class="hljs-comment"># 方法1：查找分页信息</span><br>            pagination = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;pagination&#x27;</span>) <span class="hljs-keyword">or</span> soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;page&#x27;</span>)<br>            <span class="hljs-keyword">if</span> pagination:<br>                page_links = pagination.find_all(<span class="hljs-string">&#x27;a&#x27;</span>)<br>                <span class="hljs-keyword">if</span> page_links:<br>                    <span class="hljs-comment"># 查找最后一个数字页码</span><br>                    page_numbers = []<br>                    <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> page_links:<br>                        text = link.get_text(strip=<span class="hljs-literal">True</span>)<br>                        <span class="hljs-keyword">if</span> text.isdigit():<br>                            page_numbers.append(<span class="hljs-built_in">int</span>(text))<br>                    <br>                    <span class="hljs-keyword">if</span> page_numbers:<br>                        total_pages = <span class="hljs-built_in">max</span>(page_numbers)<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;通过分页信息找到总页数: <span class="hljs-subst">&#123;total_pages&#125;</span>&quot;</span>)<br>                        <span class="hljs-keyword">return</span> total_pages<br>            <br>            <span class="hljs-comment"># 方法2：查找页面中的总页数文本</span><br>            page_text = soup.find(text=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;共.*页&#x27;</span>))<br>            <span class="hljs-keyword">if</span> page_text:<br>                <span class="hljs-keyword">match</span> = re.search(<span class="hljs-string">r&#x27;共(\d+)页&#x27;</span>, page_text)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>                    total_pages = <span class="hljs-built_in">int</span>(<span class="hljs-keyword">match</span>.group(<span class="hljs-number">1</span>))<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;通过文本匹配找到总页数: <span class="hljs-subst">&#123;total_pages&#125;</span>&quot;</span>)<br>                    <span class="hljs-keyword">return</span> total_pages<br>            <br>            <span class="hljs-comment"># 方法3：尝试访问第二页，看是否存在</span><br>            test_url = urljoin(self.base_url, <span class="hljs-string">&quot;index_1.html&quot;</span>)<br>            response = requests.get(test_url, headers=self.headers, timeout=<span class="hljs-number">10</span>)<br>            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-comment"># 如果第二页存在，继续尝试更多页</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">50</span>):  <span class="hljs-comment"># 最多尝试50页</span><br>                    test_url = urljoin(self.base_url, <span class="hljs-string">f&quot;index_<span class="hljs-subst">&#123;i&#125;</span>.html&quot;</span>)<br>                    response = requests.get(test_url, headers=self.headers, timeout=<span class="hljs-number">5</span>)<br>                    <span class="hljs-keyword">if</span> response.status_code != <span class="hljs-number">200</span>:<br>                        total_pages = i<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;通过测试找到总页数: <span class="hljs-subst">&#123;total_pages&#125;</span>&quot;</span>)<br>                        <span class="hljs-keyword">return</span> total_pages<br>            <br>            <span class="hljs-comment"># 默认返回1页</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无法确定总页数，默认返回1页&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;获取总页数失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_page_url</span>(<span class="hljs-params">self, page_num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成指定页面的URL&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> page_num == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> self.base_url<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> urljoin(self.base_url, <span class="hljs-string">f&quot;index_<span class="hljs-subst">&#123;page_num-<span class="hljs-number">1</span>&#125;</span>.html&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_announcement_links</span>(<span class="hljs-params">self, page_url</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;从页面中提取所有公告链接&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            response = requests.get(page_url, headers=self.headers, timeout=<span class="hljs-number">15</span>)<br>            response.raise_for_status()<br>            response.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>            <br>            soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>            links = []<br>            <br>            <span class="hljs-comment"># 查找公告列表</span><br>            <span class="hljs-comment"># 尝试多种可能的选择器</span><br>            selectors = [<br>                <span class="hljs-string">&#x27;ul.list-unstyled li a[href]&#x27;</span>,<br>                <span class="hljs-string">&#x27;.news_list a[href]&#x27;</span>,<br>                <span class="hljs-string">&#x27;.list a[href]&#x27;</span>,<br>                <span class="hljs-string">&#x27;a[href*=&quot;html&quot;]&#x27;</span>,<br>                <span class="hljs-string">&#x27;a[href*=&quot;hpspgg&quot;]&#x27;</span><br>            ]<br>            <br>            <span class="hljs-keyword">for</span> selector <span class="hljs-keyword">in</span> selectors:<br>                elements = soup.select(selector)<br>                <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elements:<br>                    href = element.get(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).strip()<br>                    <span class="hljs-keyword">if</span> href <span class="hljs-keyword">and</span> (<span class="hljs-string">&#x27;html&#x27;</span> <span class="hljs-keyword">in</span> href <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;hpspgg&#x27;</span> <span class="hljs-keyword">in</span> href):<br>                        <span class="hljs-comment"># 构建完整URL</span><br>                        <span class="hljs-keyword">if</span> href.startswith(<span class="hljs-string">&#x27;http&#x27;</span>):<br>                            full_url = href<br>                        <span class="hljs-keyword">else</span>:<br>                            full_url = urljoin(page_url, href)<br>                        <br>                        <span class="hljs-comment"># 确保是公告链接</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;hpspgg&#x27;</span> <span class="hljs-keyword">in</span> full_url <span class="hljs-keyword">and</span> full_url <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> links:<br>                            links.append(full_url)<br>                <br>                <span class="hljs-keyword">if</span> links:<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">return</span> links<br>            <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;提取公告链接失败 <span class="hljs-subst">&#123;page_url&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> []<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_announcement_content</span>(<span class="hljs-params">self, url</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;提取单个公告的内容&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            response = requests.get(url, headers=self.headers, timeout=<span class="hljs-number">15</span>)<br>            response.raise_for_status()<br>            response.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>            <br>            soup = BeautifulSoup(response.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>            <br>            <span class="hljs-comment"># 提取标题</span><br>            title = <span class="hljs-string">&quot;&quot;</span><br>            title_selectors = [<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;.title&#x27;</span>, <span class="hljs-string">&#x27;.article-title&#x27;</span>, <span class="hljs-string">&#x27;h2&#x27;</span>]<br>            <span class="hljs-keyword">for</span> selector <span class="hljs-keyword">in</span> title_selectors:<br>                title_elem = soup.select_one(selector)<br>                <span class="hljs-keyword">if</span> title_elem:<br>                    title = title_elem.get_text(strip=<span class="hljs-literal">True</span>)<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> title:<br>                title = <span class="hljs-string">&quot;无标题&quot;</span><br>            <br>            <span class="hljs-comment"># 提取发布日期</span><br>            publish_date = <span class="hljs-string">&quot;&quot;</span><br>            date_selectors = [<span class="hljs-string">&#x27;.date&#x27;</span>, <span class="hljs-string">&#x27;.time&#x27;</span>, <span class="hljs-string">&#x27;.publish-date&#x27;</span>, <span class="hljs-string">&#x27;.article-date&#x27;</span>]<br>            <span class="hljs-keyword">for</span> selector <span class="hljs-keyword">in</span> date_selectors:<br>                date_elem = soup.select_one(selector)<br>                <span class="hljs-keyword">if</span> date_elem:<br>                    date_text = date_elem.get_text(strip=<span class="hljs-literal">True</span>)<br>                    <span class="hljs-comment"># 提取日期格式</span><br>                    date_match = re.search(<span class="hljs-string">r&#x27;(\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;|\d&#123;4&#125;/\d&#123;2&#125;/\d&#123;2&#125;|\d&#123;4&#125;\.\d&#123;2&#125;\.\d&#123;2&#125;)&#x27;</span>, date_text)<br>                    <span class="hljs-keyword">if</span> date_match:<br>                        publish_date = date_match.group(<span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> publish_date:<br>                publish_date = datetime.now().strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)<br>            <br>            <span class="hljs-comment"># 提取正文内容</span><br>            content = <span class="hljs-string">&quot;&quot;</span><br>            content_selectors = [<span class="hljs-string">&#x27;.content&#x27;</span>, <span class="hljs-string">&#x27;.article-content&#x27;</span>, <span class="hljs-string">&#x27;.main-content&#x27;</span>, <span class="hljs-string">&#x27;.text&#x27;</span>]<br>            <span class="hljs-keyword">for</span> selector <span class="hljs-keyword">in</span> content_selectors:<br>                content_elem = soup.select_one(selector)<br>                <span class="hljs-keyword">if</span> content_elem:<br>                    content = content_elem.get_text(strip=<span class="hljs-literal">True</span>, separator=<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> content:<br>                <span class="hljs-comment"># 如果没有找到特定内容区域，尝试获取整个body</span><br>                body = soup.find(<span class="hljs-string">&#x27;body&#x27;</span>)<br>                <span class="hljs-keyword">if</span> body:<br>                    content = body.get_text(strip=<span class="hljs-literal">True</span>, separator=<span class="hljs-string">&#x27;\n&#x27;</span>)<br>            <br>            <span class="hljs-comment"># 提取附件 - 优化版本</span><br>            attachments = []<br>            attachment_links = []<br>            <br>            <span class="hljs-comment"># 查找所有可能的附件链接</span><br>            <span class="hljs-keyword">for</span> a_tag <span class="hljs-keyword">in</span> soup.find_all(<span class="hljs-string">&#x27;a&#x27;</span>, href=<span class="hljs-literal">True</span>):<br>                href = a_tag.get(<span class="hljs-string">&#x27;href&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>                text = a_tag.get_text(strip=<span class="hljs-literal">True</span>)<br>                <br>                <span class="hljs-comment"># 检查是否是附件</span><br>                <span class="hljs-keyword">if</span> (href.endswith((<span class="hljs-string">&#x27;.pdf&#x27;</span>, <span class="hljs-string">&#x27;.doc&#x27;</span>, <span class="hljs-string">&#x27;.docx&#x27;</span>, <span class="hljs-string">&#x27;.xls&#x27;</span>, <span class="hljs-string">&#x27;.xlsx&#x27;</span>, <span class="hljs-string">&#x27;.zip&#x27;</span>, <span class="hljs-string">&#x27;.rar&#x27;</span>)) <span class="hljs-keyword">or</span><br>                    <span class="hljs-string">&#x27;下载&#x27;</span> <span class="hljs-keyword">in</span> text <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;附件&#x27;</span> <span class="hljs-keyword">in</span> text <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;文件&#x27;</span> <span class="hljs-keyword">in</span> text):<br>                    attachment_url = urljoin(url, href)<br>                    attachment_links.append(&#123;<br>                        <span class="hljs-string">&#x27;url&#x27;</span>: attachment_url,<br>                        <span class="hljs-string">&#x27;text&#x27;</span>: text,<br>                        <span class="hljs-string">&#x27;href&#x27;</span>: href<br>                    &#125;)<br>            <br>            <span class="hljs-comment"># 智能处理附件信息</span><br>            <span class="hljs-keyword">for</span> i, link_info <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(attachment_links, <span class="hljs-number">1</span>):<br>                attachment_name = self.extract_attachment_name(link_info, title, i)<br>                attachments.append(&#123;<br>                    <span class="hljs-string">&#x27;name&#x27;</span>: attachment_name,<br>                    <span class="hljs-string">&#x27;url&#x27;</span>: link_info[<span class="hljs-string">&#x27;url&#x27;</span>],<br>                    <span class="hljs-string">&#x27;filename&#x27;</span>: os.path.basename(link_info[<span class="hljs-string">&#x27;href&#x27;</span>]),<br>                    <span class="hljs-string">&#x27;index&#x27;</span>: i<br>                &#125;)<br>            <br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-string">&#x27;title&#x27;</span>: title,<br>                <span class="hljs-string">&#x27;publish_date&#x27;</span>: publish_date,<br>                <span class="hljs-string">&#x27;content&#x27;</span>: content,<br>                <span class="hljs-string">&#x27;attachments&#x27;</span>: attachments,<br>                <span class="hljs-string">&#x27;url&#x27;</span>: url<br>            &#125;<br>            <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;提取公告内容失败 <span class="hljs-subst">&#123;url&#125;</span>: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_attachment_name</span>(<span class="hljs-params">self, link_info, announcement_title, index</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;智能提取附件名称&quot;&quot;&quot;</span><br>        text = link_info[<span class="hljs-string">&#x27;text&#x27;</span>]<br>        href = link_info[<span class="hljs-string">&#x27;href&#x27;</span>]<br>        original_filename = os.path.basename(href)<br>        <br>        <span class="hljs-comment"># 方法1：从链接文本中提取有意义的名称</span><br>        <span class="hljs-keyword">if</span> text <span class="hljs-keyword">and</span> text != original_filename <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(text) &gt; <span class="hljs-number">2</span>:<br>            <span class="hljs-comment"># 清理文本，移除常见的无用词汇</span><br>            clean_text = re.sub(<span class="hljs-string">r&#x27;[下载|附件|文件|点击|查看]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, text).strip()<br>            <span class="hljs-keyword">if</span> clean_text <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(clean_text) &gt; <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> clean_text<br>        <br>        <span class="hljs-comment"># 方法2：从原始文件名中提取（去除扩展名）</span><br>        <span class="hljs-keyword">if</span> original_filename:<br>            name_without_ext = os.path.splitext(original_filename)[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> name_without_ext <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(name_without_ext) &gt; <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> name_without_ext<br>        <br>        <span class="hljs-comment"># 方法3：从公告标题中提取关键词作为附件名称</span><br>        keywords = self.extract_keywords_from_title(announcement_title)<br>        <span class="hljs-keyword">if</span> keywords:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;keywords&#125;</span>_附件<span class="hljs-subst">&#123;index&#125;</span>&quot;</span><br>        <br>        <span class="hljs-comment"># 方法4：默认命名</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;附件<span class="hljs-subst">&#123;index&#125;</span>&quot;</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">extract_keywords_from_title</span>(<span class="hljs-params">self, title</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;从公告标题中提取关键词&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 移除常见的无意义词汇</span><br>        stop_words = [<span class="hljs-string">&#x27;关于&#x27;</span>, <span class="hljs-string">&#x27;的&#x27;</span>, <span class="hljs-string">&#x27;项目&#x27;</span>, <span class="hljs-string">&#x27;环评&#x27;</span>, <span class="hljs-string">&#x27;审批&#x27;</span>, <span class="hljs-string">&#x27;决定&#x27;</span>, <span class="hljs-string">&#x27;公告&#x27;</span>, <span class="hljs-string">&#x27;公示&#x27;</span>, <span class="hljs-string">&#x27;信息&#x27;</span>, <span class="hljs-string">&#x27;通知&#x27;</span>]<br>        <br>        <span class="hljs-comment"># 提取可能的关键词（公司名、项目名等）</span><br>        keywords = []<br>        <br>        <span class="hljs-comment"># 查找公司名称模式</span><br>        company_patterns = [<br>            <span class="hljs-string">r&#x27;([^有限公司]+有限公司)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^公司]+公司)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^集团]+集团)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^科技]+科技)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^发展]+发展)&#x27;</span><br>        ]<br>        <br>        <span class="hljs-keyword">for</span> pattern <span class="hljs-keyword">in</span> company_patterns:<br>            matches = re.findall(pattern, title)<br>            <span class="hljs-keyword">if</span> matches:<br>                keywords.extend(matches)<br>        <br>        <span class="hljs-comment"># 查找项目名称模式</span><br>        project_patterns = [<br>            <span class="hljs-string">r&#x27;([^项目]+项目)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^工程]+工程)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^建设]+建设)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^制造]+制造)&#x27;</span>,<br>            <span class="hljs-string">r&#x27;([^加工]+加工)&#x27;</span><br>        ]<br>        <br>        <span class="hljs-keyword">for</span> pattern <span class="hljs-keyword">in</span> project_patterns:<br>            matches = re.findall(pattern, title)<br>            <span class="hljs-keyword">if</span> matches:<br>                keywords.extend(matches)<br>        <br>        <span class="hljs-comment"># 清理和过滤关键词</span><br>        clean_keywords = []<br>        <span class="hljs-keyword">for</span> keyword <span class="hljs-keyword">in</span> keywords:<br>            <span class="hljs-comment"># 移除停用词</span><br>            clean_keyword = keyword<br>            <span class="hljs-keyword">for</span> stop_word <span class="hljs-keyword">in</span> stop_words:<br>                clean_keyword = clean_keyword.replace(stop_word, <span class="hljs-string">&#x27;&#x27;</span>)<br>            <br>            <span class="hljs-keyword">if</span> clean_keyword <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(clean_keyword) &gt; <span class="hljs-number">1</span>:<br>                clean_keywords.append(clean_keyword)<br>        <br>        <span class="hljs-comment"># 返回最长的关键词（通常最有意义）</span><br>        <span class="hljs-keyword">if</span> clean_keywords:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(clean_keywords, key=<span class="hljs-built_in">len</span>)<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_attachment_filename</span>(<span class="hljs-params">self, attachment_info, announcement_title, publish_date</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;生成有意义的附件文件名&quot;&quot;&quot;</span><br>        attachment_name = attachment_info[<span class="hljs-string">&#x27;name&#x27;</span>]<br>        original_filename = attachment_info[<span class="hljs-string">&#x27;filename&#x27;</span>]<br>        index = attachment_info[<span class="hljs-string">&#x27;index&#x27;</span>]<br>        <br>        <span class="hljs-comment"># 获取文件扩展名</span><br>        file_ext = os.path.splitext(original_filename)[<span class="hljs-number">1</span>].lower()<br>        <br>        <span class="hljs-comment"># 从公告标题中提取简短标识</span><br>        title_identifier = self.get_title_identifier(announcement_title)<br>        <br>        <span class="hljs-comment"># 生成文件名格式：日期_标题标识_附件名称_序号.扩展名</span><br>        safe_attachment_name = re.sub(<span class="hljs-string">r&#x27;[&lt;&gt;:&quot;/\\|?*]&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, attachment_name)<br>        safe_title_identifier = re.sub(<span class="hljs-string">r&#x27;[&lt;&gt;:&quot;/\\|?*]&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, title_identifier)<br>        <br>        <span class="hljs-comment"># 如果附件名称太长，截取前20个字符</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(safe_attachment_name) &gt; <span class="hljs-number">20</span>:<br>            safe_attachment_name = safe_attachment_name[:<span class="hljs-number">20</span>]<br>        <br>        filename = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;publish_date&#125;</span>_<span class="hljs-subst">&#123;safe_title_identifier&#125;</span>_<span class="hljs-subst">&#123;safe_attachment_name&#125;</span>_<span class="hljs-subst">&#123;index:02d&#125;</span><span class="hljs-subst">&#123;file_ext&#125;</span>&quot;</span><br>        <br>        <span class="hljs-keyword">return</span> filename<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_title_identifier</span>(<span class="hljs-params">self, title</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;从标题中提取简短标识&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 提取公司名称或项目名称的前几个字符</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;有限公司&#x27;</span> <span class="hljs-keyword">in</span> title:<br>            <span class="hljs-comment"># 提取公司名称</span><br>            company_match = re.search(<span class="hljs-string">r&#x27;([^有限公司]+)有限公司&#x27;</span>, title)<br>            <span class="hljs-keyword">if</span> company_match:<br>                company_name = company_match.group(<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(company_name) &lt;= <span class="hljs-number">10</span>:<br>                    <span class="hljs-keyword">return</span> company_name<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> company_name[:<span class="hljs-number">10</span>]<br>        <br>        <span class="hljs-comment"># 如果没有公司名称，提取前几个字符</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(title) &lt;= <span class="hljs-number">15</span>:<br>            <span class="hljs-keyword">return</span> title<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> title[:<span class="hljs-number">15</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">download_attachment</span>(<span class="hljs-params">self, attachment_info, announcement_title, publish_date</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;下载附件并保存到本地&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            url = attachment_info[<span class="hljs-string">&#x27;url&#x27;</span>]<br>            <br>            <span class="hljs-comment"># 生成有意义的文件名</span><br>            filename = self.generate_attachment_filename(attachment_info, announcement_title, publish_date)<br>            <br>            <span class="hljs-comment"># 创建以公告标题命名的子文件夹</span><br>            safe_title = re.sub(<span class="hljs-string">r&#x27;[&lt;&gt;:&quot;/\\|?*]&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, announcement_title)<br>            attachment_folder = os.path.join(self.attachments_dir, safe_title)<br>            os.makedirs(attachment_folder, exist_ok=<span class="hljs-literal">True</span>)<br>            <br>            filepath = os.path.join(attachment_folder, filename)<br>            <br>            <span class="hljs-comment"># 如果文件已存在，跳过下载</span><br>            <span class="hljs-keyword">if</span> os.path.exists(filepath):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;附件已存在，跳过: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            response = requests.get(url, headers=self.headers, timeout=<span class="hljs-number">10</span>, stream=<span class="hljs-literal">True</span>)<br>            <br>            <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:<br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response.iter_content(chunk_size=<span class="hljs-number">8192</span>):<br>                        f.write(chunk)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已下载附件: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>                self.stats[<span class="hljs-string">&#x27;attachments_downloaded&#x27;</span>] += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;附件下载失败: <span class="hljs-subst">&#123;url&#125;</span> (状态码: <span class="hljs-subst">&#123;response.status_code&#125;</span>)&quot;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;下载附件出错: <span class="hljs-subst">&#123;url&#125;</span> | 错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_as_markdown</span>(<span class="hljs-params">self, announcement_data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;保存公告内容为markdown格式&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">try</span>:<br>            title = announcement_data[<span class="hljs-string">&#x27;title&#x27;</span>]<br>            publish_date = announcement_data[<span class="hljs-string">&#x27;publish_date&#x27;</span>]<br>            content = announcement_data[<span class="hljs-string">&#x27;content&#x27;</span>]<br>            url = announcement_data[<span class="hljs-string">&#x27;url&#x27;</span>]<br>            attachments = announcement_data[<span class="hljs-string">&#x27;attachments&#x27;</span>]<br>            <br>            <span class="hljs-comment"># 清理文件名</span><br>            safe_title = re.sub(<span class="hljs-string">r&#x27;[&lt;&gt;:&quot;/\\|?*]&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, title)<br>            filename = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;publish_date&#125;</span>_<span class="hljs-subst">&#123;safe_title&#125;</span>.md&quot;</span><br>            filepath = os.path.join(self.output_dir, filename)<br>            <br>            <span class="hljs-comment"># 如果文件已存在，跳过</span><br>            <span class="hljs-keyword">if</span> os.path.exists(filepath):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;文件已存在，跳过: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                <span class="hljs-comment"># 写入markdown格式</span><br>                f.write(<span class="hljs-string">f&quot;# <span class="hljs-subst">&#123;title&#125;</span>\n\n&quot;</span>)<br>                f.write(<span class="hljs-string">f&quot;**发布日期:** <span class="hljs-subst">&#123;publish_date&#125;</span>\n\n&quot;</span>)<br>                f.write(<span class="hljs-string">f&quot;**原文链接:** [<span class="hljs-subst">&#123;url&#125;</span>](<span class="hljs-subst">&#123;url&#125;</span>)\n\n&quot;</span>)<br>                f.write(<span class="hljs-string">&quot;---\n\n&quot;</span>)<br>                f.write(<span class="hljs-string">&quot;## 公告内容\n\n&quot;</span>)<br>                f.write(content)<br>                f.write(<span class="hljs-string">&quot;\n\n&quot;</span>)<br>                <br>                <span class="hljs-keyword">if</span> attachments:<br>                    f.write(<span class="hljs-string">&quot;## 附件\n\n&quot;</span>)<br>                    <span class="hljs-keyword">for</span> i, attachment <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(attachments, <span class="hljs-number">1</span>):<br>                        f.write(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;i&#125;</span>. [<span class="hljs-subst">&#123;attachment[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>](<span class="hljs-subst">&#123;attachment[<span class="hljs-string">&#x27;url&#x27;</span>]&#125;</span>)\n&quot;</span>)<br>                    f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>            <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;已保存为markdown: <span class="hljs-subst">&#123;filename&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;保存markdown失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">crawl_all_pages</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;爬取所有页面的公告&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始爬取环评公告...&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;基础URL: <span class="hljs-subst">&#123;self.base_url&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;输出目录: <span class="hljs-subst">&#123;self.output_dir&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;附件目录: <span class="hljs-subst">&#123;self.attachments_dir&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">50</span>)<br>        <br>        <span class="hljs-comment"># 第一步：获取总页数</span><br>        total_pages = self.get_total_pages()<br>        self.stats[<span class="hljs-string">&#x27;total_pages&#x27;</span>] = total_pages<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;总页数: <span class="hljs-subst">&#123;total_pages&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">50</span>)<br>        <br>        all_announcements = []<br>        <br>        <span class="hljs-comment"># 第二步和第三步：从第一页开始依次处理</span><br>        <span class="hljs-keyword">for</span> page_num <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, total_pages + <span class="hljs-number">1</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n正在处理第 <span class="hljs-subst">&#123;page_num&#125;</span>/<span class="hljs-subst">&#123;total_pages&#125;</span> 页...&quot;</span>)<br>            <br>            <span class="hljs-comment"># 获取当前页面的URL</span><br>            page_url = self.get_page_url(page_num)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;页面URL: <span class="hljs-subst">&#123;page_url&#125;</span>&quot;</span>)<br>            <br>            <span class="hljs-comment"># 提取当前页面的所有公告链接</span><br>            announcement_links = self.extract_announcement_links(page_url)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;本页找到 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(announcement_links)&#125;</span> 个公告链接&quot;</span>)<br>            <br>            <span class="hljs-comment"># 处理每个公告</span><br>            <span class="hljs-keyword">for</span> i, link <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(announcement_links, <span class="hljs-number">1</span>):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n  处理公告 <span class="hljs-subst">&#123;i&#125;</span>/<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(announcement_links)&#125;</span>: <span class="hljs-subst">&#123;link&#125;</span>&quot;</span>)<br>                <br>                <span class="hljs-comment"># 提取公告内容</span><br>                announcement_data = self.extract_announcement_content(link)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> announcement_data:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  提取内容失败，跳过&quot;</span>)<br>                    self.stats[<span class="hljs-string">&#x27;failed_downloads&#x27;</span>] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">continue</span><br>                <br>                <span class="hljs-comment"># 保存为markdown格式</span><br>                <span class="hljs-keyword">if</span> self.save_as_markdown(announcement_data):<br>                    self.stats[<span class="hljs-string">&#x27;successful_downloads&#x27;</span>] += <span class="hljs-number">1</span><br>                    all_announcements.append(announcement_data)<br>                <span class="hljs-keyword">else</span>:<br>                    self.stats[<span class="hljs-string">&#x27;failed_downloads&#x27;</span>] += <span class="hljs-number">1</span><br>                <br>                <span class="hljs-comment"># 下载附件</span><br>                <span class="hljs-keyword">if</span> announcement_data[<span class="hljs-string">&#x27;attachments&#x27;</span>]:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;  发现 <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(announcement_data[<span class="hljs-string">&#x27;attachments&#x27;</span>])&#125;</span> 个附件&quot;</span>)<br>                    <span class="hljs-keyword">for</span> attachment <span class="hljs-keyword">in</span> announcement_data[<span class="hljs-string">&#x27;attachments&#x27;</span>]:<br>                        self.download_attachment(attachment, announcement_data[<span class="hljs-string">&#x27;title&#x27;</span>], announcement_data[<span class="hljs-string">&#x27;publish_date&#x27;</span>])<br>                <br>                <span class="hljs-comment"># 礼貌爬取，添加延迟</span><br>                time.sleep(<span class="hljs-number">2</span>)<br>            <br>            <span class="hljs-comment"># 页面间延迟</span><br>            <span class="hljs-keyword">if</span> page_num &lt; total_pages:<br>                time.sleep(<span class="hljs-number">3</span>)<br>        <br>        <span class="hljs-comment"># 保存统计信息</span><br>        self.save_statistics(all_announcements)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n&quot;</span> + <span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;爬取完成！&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;总页数: <span class="hljs-subst">&#123;self.stats[<span class="hljs-string">&#x27;total_pages&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功下载: <span class="hljs-subst">&#123;self.stats[<span class="hljs-string">&#x27;successful_downloads&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;失败下载: <span class="hljs-subst">&#123;self.stats[<span class="hljs-string">&#x27;failed_downloads&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;附件下载: <span class="hljs-subst">&#123;self.stats[<span class="hljs-string">&#x27;attachments_downloaded&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">50</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_statistics</span>(<span class="hljs-params">self, announcements</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;保存统计信息&quot;&quot;&quot;</span><br>        stats_file = os.path.join(self.output_dir, <span class="hljs-string">&quot;爬取统计.json&quot;</span>)<br>        <br>        stats_data = &#123;<br>            <span class="hljs-string">&#x27;crawl_time&#x27;</span>: datetime.now().isoformat(),<br>            <span class="hljs-string">&#x27;statistics&#x27;</span>: self.stats,<br>            <span class="hljs-string">&#x27;announcements&#x27;</span>: [<br>                &#123;<br>                    <span class="hljs-string">&#x27;title&#x27;</span>: ann[<span class="hljs-string">&#x27;title&#x27;</span>],<br>                    <span class="hljs-string">&#x27;publish_date&#x27;</span>: ann[<span class="hljs-string">&#x27;publish_date&#x27;</span>],<br>                    <span class="hljs-string">&#x27;url&#x27;</span>: ann[<span class="hljs-string">&#x27;url&#x27;</span>],<br>                    <span class="hljs-string">&#x27;attachments_count&#x27;</span>: <span class="hljs-built_in">len</span>(ann[<span class="hljs-string">&#x27;attachments&#x27;</span>])<br>                &#125;<br>                <span class="hljs-keyword">for</span> ann <span class="hljs-keyword">in</span> announcements<br>            ]<br>        &#125;<br>        <br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(stats_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            json.dump(stats_data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">2</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;统计信息已保存到: <span class="hljs-subst">&#123;stats_file&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    crawler = EIAAnnouncementCrawler()<br>    crawler.crawl_all_pages()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main() <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> WPS演示催化剂：让PPT演示支持HTML网页的神器插件</title>
    <link href="/2025/06/20/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/WPS%E6%BC%94%E7%A4%BA%E5%82%AC%E5%8C%96%E5%89%82%EF%BC%9A%E8%AE%A9PPT%E6%BC%94%E7%A4%BA%E6%94%AF%E6%8C%81HTML%E7%BD%91%E9%A1%B5%E7%9A%84%E7%A5%9E%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    <url>/2025/06/20/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/WPS%E6%BC%94%E7%A4%BA%E5%82%AC%E5%8C%96%E5%89%82%EF%BC%9A%E8%AE%A9PPT%E6%BC%94%E7%A4%BA%E6%94%AF%E6%8C%81HTML%E7%BD%91%E9%A1%B5%E7%9A%84%E7%A5%9E%E5%99%A8%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="WPS演示催化剂：让PPT演示支持HTML网页的神器插件"><a href="#WPS演示催化剂：让PPT演示支持HTML网页的神器插件" class="headerlink" title="WPS演示催化剂：让PPT演示支持HTML网页的神器插件"></a>WPS演示催化剂：让PPT演示支持HTML网页的神器插件</h1><p>作为一名经常需要制作演示文稿的工作者，我一直有个痛点：如何在PPT中优雅地展示HTML内容？传统的方法要么是截图贴图，要么是跳转浏览器，都会打断演示的连贯性。直到我发现了WPS演示催化剂这个神器插件，这个问题终于得到了完美解决。</p><h2 id="什么是WPS演示催化剂？"><a href="#什么是WPS演示催化剂？" class="headerlink" title="什么是WPS演示催化剂？"></a>什么是WPS演示催化剂？</h2><p>WPS演示催化剂是一款专为WPS演示（WPS版PowerPoint）开发的免费插件，它最大的亮点就是能够在幻灯片中直接嵌入并运行HTML网页内容。这意味着你可以在演示过程中无缝展示：</p><ul><li>在线数据可视化图表</li><li>交互式网页应用</li><li>实时网站内容</li><li>HTML5动画效果</li><li>在线工具和演示</li></ul><h2 id="核心功能特色"><a href="#核心功能特色" class="headerlink" title="核心功能特色"></a>核心功能特色</h2><h3 id="1-原生HTML支持"><a href="#1-原生HTML支持" class="headerlink" title="1. 原生HTML支持"></a>1. 原生HTML支持</h3><p>通过WPS的WebShape网页控件接口，插件能够将真实的HTML页面嵌入到幻灯片中，而不是简单的截图或链接。这样观众可以直接在PPT中与网页内容进行交互。</p><h3 id="2-无缝演示体验"><a href="#2-无缝演示体验" class="headerlink" title="2. 无缝演示体验"></a>2. 无缝演示体验</h3><p>在幻灯片放映过程中，你可以直接操作嵌入的网页，无需跳转到浏览器或中断演示流程。这对于需要现场演示在线工具、数据仪表盘或交互内容的场景特别有用。</p><h3 id="3-完全免费使用"><a href="#3-完全免费使用" class="headerlink" title="3. 完全免费使用"></a>3. 完全免费使用</h3><p>作为WPSJS插件家族的一员，WPS演示催化剂承诺永久免费使用，这对于个人用户和企业用户来说都是一个重大福利。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="商业汇报"><a href="#商业汇报" class="headerlink" title="商业汇报"></a>商业汇报</h3><ul><li>展示实时数据仪表盘</li><li>演示在线业务系统</li><li>展示网站用户体验流程</li></ul><h3 id="教学培训"><a href="#教学培训" class="headerlink" title="教学培训"></a>教学培训</h3><ul><li>直接在课件中打开教学网站</li><li>展示在线学习平台</li><li>演示Web开发成果</li></ul><h3 id="产品演示"><a href="#产品演示" class="headerlink" title="产品演示"></a>产品演示</h3><ul><li>展示Web应用功能</li><li>演示响应式网站设计</li><li>展示在线工具使用</li></ul><h2 id="技术背景与发展"><a href="#技术背景与发展" class="headerlink" title="技术背景与发展"></a>技术背景与发展</h2><p>WPS演示催化剂的开发得益于WPS演示版本的不断更新。早期版本中，WPS演示并未开放WebShape网页控件接口，这限制了HTML内容的集成。随着WPS个人版对WebShape的支持，开发者才得以实现这一创新功能。</p><p>值得一提的是，这款插件还曾荣获WPS信创大比武大赛二等奖，体现了其在技术创新和实用价值方面的优秀表现。</p><h2 id="版本更新与维护"><a href="#版本更新与维护" class="headerlink" title="版本更新与维护"></a>版本更新与维护</h2><p>最新的2.0版本主要解决了因WPS升级导致的兼容性问题。开发者在发现WPS版本更新影响插件核心功能后，及时进行了修复和优化，确保用户能够正常使用插入网页的功能。</p><p>虽然开发者坦言这款插件目前知名度不高，使用者相对较少，但其独特的功能价值不容忽视。对于有HTML内容展示需求的用户来说，这确实是一个”偷着乐”的神器工具。</p><h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><ol><li><strong>兼容性检查</strong>：确保你的WPS演示版本支持WebShape控件</li><li><strong>内容优化</strong>：嵌入的HTML内容应该针对演示场景进行优化，确保在不同分辨率下都能良好显示</li><li><strong>网络环境</strong>：由于需要加载网络内容，建议在网络稳定的环境下使用</li><li><strong>备用方案</strong>：为重要演示准备截图备用方案，以防网络问题</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WPS演示催化剂填补了国产办公软件在HTML内容展示方面的空白，为用户提供了一个简单而强大的解决方案。虽然它可能不像其他热门插件那样广为人知，但对于有特定需求的用户来说，这确实是一个值得收藏的神器工具。</p><p>如果你也有在PPT中展示HTML内容的需求，不妨试试这款免费的WPS演示催化剂插件。它可能会让你的演示体验发生质的改变。</p><h2 id="工具获取"><a href="#工具获取" class="headerlink" title="工具获取"></a>工具获取</h2><p>可通过开发者提供的语雀文档链接下载安装。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.yuque.com<span class="hljs-regexp">/cuihuajihome/</span>wpsjs/fuwfir<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有了它们，文稿审核变得非常轻松</title>
    <link href="/2025/06/11/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%89%E4%BA%86%E5%AE%83%E4%BB%AC%EF%BC%8C%E6%96%87%E7%A8%BF%E5%AE%A1%E6%A0%B8%E5%8F%98%E5%BE%97%E9%9D%9E%E5%B8%B8%E8%BD%BB%E6%9D%BE/"/>
    <url>/2025/06/11/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%89%E4%BA%86%E5%AE%83%E4%BB%AC%EF%BC%8C%E6%96%87%E7%A8%BF%E5%AE%A1%E6%A0%B8%E5%8F%98%E5%BE%97%E9%9D%9E%E5%B8%B8%E8%BD%BB%E6%9D%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>大家好，今天想和大家聊聊一个在内容创作和编辑工作中老大难的问题——文稿审核。无论是工作报告、学术论文，还是新媒体稿件，细致的审核都是非常重要的，我自己属于那种比较粗心大意的人，往往喜欢尽快完成稿件，但是稿子的质量却难以保证，所以我对如何提高升高能力做了很多尝试。</p><p>今天就介绍我自己实践很久的文件审稿工作流。</p><p>省流版本就是 wps 文本校对+AI 大模型。</p><h2 id="wps-文本校对"><a href="#wps-文本校对" class="headerlink" title="wps 文本校对"></a>wps 文本校对</h2><p>其中 wps 文本校对负责解决文字表述问题，比如重复表述，错字漏字等，非常高效，这里顺便批评性微软的文本校对功能简直就是一坨。</p><p>使用方法：在审核选项卡点击校对-通用校对。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202506111717657.png" alt="image.png"><br>注意这是付费功能，但他确实香，如果有更好的办法也请留言。</p><h2 id="AI-大模型文稿审核"><a href="#AI-大模型文稿审核" class="headerlink" title="AI 大模型文稿审核"></a>AI 大模型文稿审核</h2><p>大语言模型模型主要解决逻辑，前后一致等问题。</p><p>大模型文稿审核主要是提示词优化以及具体工具的选择，我自己尝试多款应用，甚至编写代码做了小工具，但是最后常用的是 Google notebookLM 。<br>他的优势就是引用非常准，幻觉比较少，可以根据知识库相互对照检查问题，只要提示词合理基本上就能达到想要的效果。需要注意的是 notebookLM 不支持 word 需要转为 pdf。</p><p>我常用的提示词是：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">你作为<span class="hljs-strong">**专家，具备**</span>等方面的专业知识。<br>请按照以下要求审核报告。<br>一、通用问题<br>1.是否有错别字<br>2.序号是否正确<br>3.上下文是否对应，描述是否一致<br>4.数字逻辑是否正确<br>5.段落描述是否流畅，是否有语病。<br>二、专业问题<br>1.所提主要观点逻辑是否正确<br>2.所提措施是否具备可行性，符合法律法规<br></code></pre></td></tr></table></figure><p>思路非常简单，但是真的有用。</p><p>以上的方法也不是能够检查出所有问题，因为他们目前都是将 pdf 进行文字分段，无法很好的识别表格，图片等信息，对于多模态的内容还是比较弱。还是需要自己后期再仔细检查下。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Google NotebookLM：主题阅读的神</title>
    <link href="/2025/05/23/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Google%20NotebookLM%EF%BC%9A%E4%B8%BB%E9%A2%98%E9%98%85%E8%AF%BB%E7%9A%84%E7%A5%9E/"/>
    <url>/2025/05/23/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Google%20NotebookLM%EF%BC%9A%E4%B8%BB%E9%A2%98%E9%98%85%E8%AF%BB%E7%9A%84%E7%A5%9E/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在信息爆炸的数字时代，我们每天都被海量的内容所淹没——学术论文、行业报告、新闻资讯、播客视频……如何高效地吸收、整合这些信息成为现代人面临的核心挑战。作为谷歌实验室推出的革命性 AI 笔记工具，NotebookLM 正以其独特的多模态处理能力和智能知识整合功能，重新定义主题阅读与知识管理的方式。本文将深入剖析 NotebookLM 的核心优势、功能特性以及实用技巧，展示它如何成为数字时代学习者和知识工作者的”第二大脑”。</p><p>NotebookLM 是谷歌实验室基于 Gemini 大模型开发的 AI 驱动笔记和研究助手，它从根本上重新构想了在 AI 时代知识管理工具应该具备的能力。与传统的笔记应用不同，NotebookLM 不是简单地将 AI 功能附加到现有笔记工具中，而是从零开始设计，将大型语言模型深度集成到笔记体验的核心。这种”AI 优先”的设计理念使其超越了 Evernote、Notion 等传统工具，成为真正意义上的”智能知识伙伴”。</p><p>与传统笔记工具相比，NotebookLM 在<strong>主题阅读</strong>方面展现出独特优势。主题阅读是指围绕特定主题系统地收集、分析和整合多源信息的过程，是学术研究、商业分析和内容创作的基础。NotebookLM 通过智能摘要、多模态内容处理和结构化输出等功能，将原本耗时数周的主题阅读过程压缩到几天甚至几小时内完成，同时保持甚至提升研究成果的质量。</p><p><em>表：NotebookLM 与传统笔记工具在主题阅读中的对比</em></p><table><thead><tr><th><strong>功能维度</strong></th><th><strong>传统笔记工具</strong></th><th><strong>NotebookLM</strong></th></tr></thead><tbody><tr><td><strong>信息处理方式</strong></td><td>手动摘录与整理</td><td>AI 自动摘要与结构化</td></tr><tr><td><strong>知识连接能力</strong></td><td>依赖用户自行建立链接</td><td>自动识别跨文档关联</td></tr><tr><td><strong>多模态支持</strong></td><td>有限，主要处理文本</td><td>全面支持文本、音频、视频、PDF 等</td></tr><tr><td><strong>输出形式</strong></td><td>静态笔记</td><td>动态报告、播客、视频等多种形式</td></tr><tr><td><strong>知识验证</strong></td><td>用户自行核查</td><td>提供引用来源，便于核实</td></tr></tbody></table><p>NotebookLM 的<strong>多模态处理能力</strong>使其成为主题阅读的理想平台。它支持处理包括 PDF、Google Docs、网页内容、YouTube 视频、MP 3 音频等在内的多种信息形式。用户可以将与研究主题相关的所有材料——无论是学术论文、行业报告、访谈录音还是教学视频——集中上传到一个笔记本中，由 NotebookLM 进行统一分析和交叉引用。这种能力打破了传统主题阅读中信息形式单一的限制，使研究者能够从更丰富的维度理解主题。</p><h3 id="多源知识库构建：主题研究的基石"><a href="#多源知识库构建：主题研究的基石" class="headerlink" title="多源知识库构建：主题研究的基石"></a>多源知识库构建：主题研究的基石</h3><p>NotebookLM 支持构建包含<strong>多达 50 个来源</strong>的知识库，为深度主题研究提供了坚实基础。用户可上传包括 PDF、Google Docs、纯文本、Markdown、网页链接、YouTube 视频链接 (无需字幕) 以及 MP 3 音频文件等多种格式的内容。这种广泛的格式支持意味着研究者几乎可以将任何与研究主题相关的材料纳入分析范围，打破传统主题阅读中信息形式单一的限制。<br>还可以只输入主题，会根据互联网上的内容搜索相关内容，形成主题文档。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250523_213049.png" alt="支持多种数据来源"></p><h3 id="智能问答与知识提取：深度互动式学习"><a href="#智能问答与知识提取：深度互动式学习" class="headerlink" title="智能问答与知识提取：深度互动式学习"></a>智能问答与知识提取：深度互动式学习</h3><p>基于构建的知识库，NotebookLM 提供<strong>精准的问答功能</strong>，允许用户以对话形式深入探索主题。与通用聊天机器人不同，NotebookLM 的回答严格基于用户上传的资料，并<strong>提供引用来源</strong>，确保信息的准确性和可验证性。这一特性对于学术研究和专业分析尤为重要，因为它保持了学术严谨性，避免了 AI 常见的”幻觉”问题。</p><p>NotebookLM 的问答功能支持<strong>多层次的认知互动</strong>。用户可以从基础的事实性问题 (如”这份报告中提到的主要挑战有哪些？”) 逐步深入到分析性、综合性的问题 (如”比较这三篇论文中使用的方法论有何异同？”)。这种渐进式的提问策略能够引导用户系统性地构建对复杂主题的理解，特别适合学术文献综述或竞争情报分析等场景。</p><p><strong>创意激发</strong>是 NotebookLM 问答功能的另一重要维度。用户可要求 AI 基于研究材料提出新观点、假设或应用场景。例如，一位产品经理上传了几份市场研究报告后，可以询问：”基于这些趋势分析，我们的产品可以开发哪些新功能来满足未来需求？”。NotebookLM 会综合文档内容，生成富有创意的建议，这种能力使工具不仅限于信息整理，更延伸到创新构思阶段。</p><h3 id="结构化输出：从杂乱信息到系统知识"><a href="#结构化输出：从杂乱信息到系统知识" class="headerlink" title="结构化输出：从杂乱信息到系统知识"></a>结构化输出：从杂乱信息到系统知识</h3><p>NotebookLM 提供多种<strong>预设的内容模板</strong>，能够将杂乱的信息转化为结构化的知识产品。这些模板包括但不限于：</p><ul><li>**常见问题解答 (FAQ)**：自动提取文档中的关键问题并提供简明答案，适合制作产品文档或学习材料</li><li><strong>学习指南</strong>：将复杂主题分解为逻辑连贯的学习模块，附带重点摘要和示例，对教育工作者和学生特别有用</li><li><strong>时间轴</strong>：识别事件或发展的时序关系，以可视化形式呈现历史演进或项目进程</li><li><strong>简报文档</strong>：浓缩大量信息为执行摘要，突出关键发现和建议，方便决策者快速掌握核心内容</li><li><strong>目录大纲</strong>：为长篇内容创建层次分明的导航结构，便于后续深入研究和写作</li></ul><p>这些结构化输出不仅提高了信息利用率，还显著<strong>降低了知识分享的门槛</strong>。一位法学研究者可以将数百页的案例资料转化为清晰的时间轴和关键判决要点；一位市场分析师能把分散的行业数据整合成具有执行洞察力的简报；一位学生能将复杂的教科书内容重组为易于消化学习指南。这种从信息到知识的转化能力，正是 NotebookLM 区别于普通笔记工具的核心价值。</p><p>NotebookLM 的<strong>引用功能</strong>进一步增强了其作为研究工具的可靠性。每当 AI 生成回答或总结时，都会标注信息的具体来源，用户可随时点击查看原文上下文。这种透明性不仅便于核实信息，还保留了学术研究必需的引证链条，使 NotebookLM 生成的内容可以直接作为学术写作的素材。<br>觉得满意的答复可以生成笔记，笔记内容会详细标注出处。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250523_213353.png" alt=" 自动生成笔记"></p><p>NotebookLM 的强大功能使其能够服务于多样化的主题阅读需求，从学术研究到商业分析，从内容创作到个人学习。本部分将深入探讨 NotebookLM 在不同场景下的具体应用策略，帮助读者根据自身需求定制高效的知识整理流程。</p><p>总之，NotebookLM 是我目前用过的最好的主题阅读 AI 工具。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI生成技术路线图：告别手绘时代的效率革命</title>
    <link href="/2025/05/22/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE%EF%BC%9A%E5%91%8A%E5%88%AB%E6%89%8B%E7%BB%98%E6%97%B6%E4%BB%A3%E7%9A%84%E6%95%88%E7%8E%87%E9%9D%A9%E5%91%BD/"/>
    <url>/2025/05/22/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%E7%94%9F%E6%88%90%E6%8A%80%E6%9C%AF%E8%B7%AF%E7%BA%BF%E5%9B%BE%EF%BC%9A%E5%91%8A%E5%88%AB%E6%89%8B%E7%BB%98%E6%97%B6%E4%BB%A3%E7%9A%84%E6%95%88%E7%8E%87%E9%9D%A9%E5%91%BD/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="🚀-写在前面"><a href="#🚀-写在前面" class="headerlink" title="🚀 写在前面"></a>🚀 写在前面</h2><p>还在为制作复杂的技术路线图而苦恼吗？传统的手工绘制流程图不仅耗时耗力，而且往往难以达到专业水准。今天就来分享一个颠覆性的解决方案——<strong>AI + Visio 组合拳</strong>，让你在几分钟内就能创建出可二次编辑的专业级技术路线图！</p><h2 id="🎯-为什么选择AI生成？"><a href="#🎯-为什么选择AI生成？" class="headerlink" title="🎯 为什么选择AI生成？"></a>🎯 为什么选择AI生成？</h2><p>传统绘制技术路线图的痛点相信大家都深有体会：</p><ul><li>⏰ <strong>时间成本高</strong>：复杂图表往往需要数小时甚至数天</li><li>🎨 <strong>美观度不足</strong>：缺乏设计经验很难做出专业效果</li><li>🔄 <strong>修改困难</strong>：一旦需要调整，几乎要重新开始</li><li>📊 <strong>格式不统一</strong>：团队协作时风格各异</li></ul><p>而AI生成技术路线图的优势显而易见：</p><ul><li>⚡ <strong>效率提升100倍</strong>：从小时级降至分钟级</li><li>🎨 <strong>专业级美观度</strong>：AI自带设计美感</li><li>📝 <strong>可编辑性强</strong>：SVG格式支持无损编辑</li><li>🔧 <strong>标准化输出</strong>：统一的专业风格</li></ul><h2 id="🧪-五大主流AI模型实测对比"><a href="#🧪-五大主流AI模型实测对比" class="headerlink" title="🧪 五大主流AI模型实测对比"></a>🧪 五大主流AI模型实测对比</h2><p>为了给大家提供最客观的参考，我对目前最热门的几款AI模型进行了全面测试。测试标准包括：生成速度、图表质量、可编辑性、易用性等维度。</p><h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ad-quote">请生成一个swmm河流预测模型构建的技术路线图，符合论文要求，要求保存为svg格式，使用svg语法<br></code></pre></td></tr></table></figure><h3 id="🏆-Claude-3-7-Sonnet-王者级表现"><a href="#🏆-Claude-3-7-Sonnet-王者级表现" class="headerlink" title="🏆 Claude 3.7 Sonnet - 王者级表现"></a>🏆 Claude 3.7 Sonnet - 王者级表现</h3><p><strong>测试结果：★★★★★</strong></p><p>Claude 3.7 Sonnet 在本次测试中表现最为出色，堪称完美级别：</p><p><strong>突出优势：</strong></p><ul><li>🎯 <strong>即时预览</strong>：生成后可直接在界面查看效果</li><li>📥 <strong>一键下载</strong>：支持直接下载SVG格式，无需转换</li><li>🎨 <strong>设计精美</strong>：色彩搭配和布局都达到专业水准</li><li>📐 <strong>结构清晰</strong>：逻辑层次分明，信息组织合理</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250522_065313.png" alt="Claude问题回答界面"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250522_065510.png" alt="Claude生成效果展示"></p><h3 id="🥈-Gemini-2-5-Pro-实力派选手"><a href="#🥈-Gemini-2-5-Pro-实力派选手" class="headerlink" title="🥈 Gemini 2.5 Pro - 实力派选手"></a>🥈 Gemini 2.5 Pro - 实力派选手</h3><p><strong>测试结果：★★★★☆</strong></p><p>Google的Gemini 2.5 Pro整体表现不错，生成质量很高：</p><p><strong>主要特点：</strong></p><ul><li>✅ <strong>内容丰富</strong>：生成的技术路线图信息完整</li><li>✅ <strong>逻辑清晰</strong>：流程步骤安排合理</li><li>⚠️ <strong>格式处理</strong>：需要手动保存为txt后修改后缀名为svg</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250522_065540.png" alt="Gemini 2.5 Pro生成效果"></p><h3 id="🥉-Qwen-3-稳定发挥"><a href="#🥉-Qwen-3-稳定发挥" class="headerlink" title="🥉 Qwen 3 - 稳定发挥"></a>🥉 Qwen 3 - 稳定发挥</h3><p><strong>测试结果：★★★☆☆</strong></p><p>阿里的Qwen 3表现中规中矩，能够满足基本需求：</p><p><strong>基本评价：</strong></p><ul><li>✅ <strong>功能完备</strong>：基础的流程图生成功能齐全</li><li>✅ <strong>中文友好</strong>：对中文内容处理较好</li><li>⚠️ <strong>操作略繁琐</strong>：同样需要txt格式转换</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250522_070507.png" alt="Qwen 3效果展示"></p><h3 id="🤖-Grok-新星表现"><a href="#🤖-Grok-新星表现" class="headerlink" title="🤖 Grok - 新星表现"></a>🤖 Grok - 新星表现</h3><p><strong>测试结果：★★★☆☆</strong></p><p>X平台的Grok作为新兴AI，表现可圈可点：</p><p><strong>整体印象：</strong></p><ul><li>✅ <strong>创新思维</strong>：在创意方面有独特表现</li><li>⚠️ <strong>稳定性待提升</strong>：偶有生成质量不稳定的情况</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250522_070616.png" alt="Grok效果展示"></p><h2 id="🔧-实操指南：从AI到Visio的完美工作流"><a href="#🔧-实操指南：从AI到Visio的完美工作流" class="headerlink" title="🔧 实操指南：从AI到Visio的完美工作流"></a>🔧 实操指南：从AI到Visio的完美工作流</h2><h3 id="Step-1-AI生成SVG文件"><a href="#Step-1-AI生成SVG文件" class="headerlink" title="Step 1: AI生成SVG文件"></a>Step 1: AI生成SVG文件</h3><ol><li>选择合适的AI工具（推荐Claude 3.7 Sonnet）</li><li>输入详细的需求描述</li><li>获取SVG格式的技术路线图</li></ol><h3 id="Step-2-导入Visio进行二次编辑"><a href="#Step-2-导入Visio进行二次编辑" class="headerlink" title="Step 2: 导入Visio进行二次编辑"></a>Step 2: 导入Visio进行二次编辑</h3><ol><li>打开Microsoft Visio</li><li>直接拖拽SVG文件到Visio画布</li><li>开始个性化编辑和调整</li></ol><h3 id="Step-3-完善和优化"><a href="#Step-3-完善和优化" class="headerlink" title="Step 3: 完善和优化"></a>Step 3: 完善和优化</h3><ul><li>调整色彩方案</li><li>修改文字内容</li><li>添加公司Logo</li><li>统一字体风格</li></ul><h2 id="💡-实用技巧分享"><a href="#💡-实用技巧分享" class="headerlink" title="💡 实用技巧分享"></a>💡 实用技巧分享</h2><h3 id="提示词优化技巧"><a href="#提示词优化技巧" class="headerlink" title="提示词优化技巧"></a>提示词优化技巧</h3><ul><li><strong>具体化描述</strong>：详细说明技术路线图的用途和要求</li><li><strong>结构化输入</strong>：明确各个阶段和步骤</li><li><strong>格式要求</strong>：明确指定需要SVG格式输出</li></ul><h3 id="后期编辑建议"><a href="#后期编辑建议" class="headerlink" title="后期编辑建议"></a>后期编辑建议</h3><ul><li><strong>保持一致性</strong>：统一色彩和字体风格</li><li><strong>突出重点</strong>：用不同颜色标识关键节点</li><li><strong>添加细节</strong>：补充必要的说明文字和图标</li></ul><h2 id="🎊-总结与展望"><a href="#🎊-总结与展望" class="headerlink" title="🎊 总结与展望"></a>🎊 总结与展望</h2><p>AI技术的发展正在深刻改变我们的工作方式，技术路线图的制作从此告别手工时代。通过本次测试，<strong>Claude 3.7 Sonnet</strong>以其卓越的表现成为首选方案，而其他AI工具也各有特色，可以根据具体需求选择。</p><p>这种AI+传统软件的组合使用模式，不仅大幅提升了工作效率，更重要的是让专业级的设计变得触手可及。相信随着AI技术的不断进步，未来还会有更多令人惊喜的应用场景等待我们去探索。</p><hr><blockquote><p>💬 <strong>互动时间</strong>：你在工作中还遇到过哪些可以用AI优化的场景？欢迎在评论区分享你的经验和想法！</p></blockquote><blockquote><p>🔔 <strong>关注我</strong>，获取更多AI工具实测和效率提升技巧！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI打造个性化审稿专家</title>
    <link href="/2025/05/14/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%E6%89%93%E9%80%A0%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%A1%E7%A8%BF%E4%B8%93%E5%AE%B6/"/>
    <url>/2025/05/14/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%E6%89%93%E9%80%A0%E4%B8%AA%E6%80%A7%E5%8C%96%E5%AE%A1%E7%A8%BF%E4%B8%93%E5%AE%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="我的文稿审核工作流，AI打造个性化审稿专家"><a href="#我的文稿审核工作流，AI打造个性化审稿专家" class="headerlink" title="我的文稿审核工作流，AI打造个性化审稿专家"></a>我的文稿审核工作流，AI打造个性化审稿专家</h1><p>大家好，今天想和大家聊聊一个在内容创作和编辑工作中老大难的问题——文稿审核。无论是工作报告、学术论文，还是新媒体稿件，细致的审核都不可或缺。传统的AI审稿工具，要么只能给个大概的建议，要么受限于输入长度（Token限制），面对长篇大论就束手无策，更别提满足我们五花八门的个性化审核需求了。</p><p>最近，我捣鼓出了一套全新的AI文稿审核工作流，可以说是给自己打造了一位“个性化审稿专家”。它不仅能搞定长文件，还能根据我的具体要求进行深度“刨析”，今天就来和大家分享一下这套方案。</p><h2 id="现有AI审稿的“痛点”与我的“痒点”"><a href="#现有AI审稿的“痛点”与我的“痒点”" class="headerlink" title="现有AI审稿的“痛点”与我的“痒点”"></a>现有AI审稿的“痛点”与我的“痒点”</h2><p>相信不少朋友都用过AI工具辅助审稿，但体验下来，总有那么些不尽如人意的地方：</p><ol><li><strong>浅尝辄止</strong>：很多AI应用对于文稿的理解和反馈偏于表面，说不到点子上，难以进行深度优化。</li><li><strong>“Token焦虑”</strong>：AI模型处理文本有长度限制（Token数）。一篇几千上万字的文档，想让AI一次性完整细致地看完并给出反馈？几乎不可能。结果往往是头重脚轻，或者干脆罢工。</li></ol><p>面对这些问题，我一直在思考：有没有一种方法，能让AI更“懂”我的稿件，更“贴合”我的需求呢？</p><h2 id="我的解决方案：AI审稿工作流详解"><a href="#我的解决方案：AI审稿工作流详解" class="headerlink" title="我的解决方案：AI审稿工作流详解"></a>我的解决方案：AI审稿工作流详解</h2><p>针对以上痛点，我设计并实现了一套基于Streamlit的Word审稿助手。它的核心思路就是“化整为零、逐个击破、按需定制”。</p><p><strong>核心流程图（示意）：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[上传 Word 文档]</span> --&gt; <span class="hljs-comment">[智能解析与分块]</span> --&gt; <span class="hljs-comment">[循环调用 AI 审稿]</span> --&gt; <span class="hljs-comment">[整合反馈与输出]</span><br>                      |                            |<br>                      |                            +-- <span class="hljs-comment">[自定义提示词模块]</span><br>                      +-- <span class="hljs-comment">[Token 计算与控制]</span><br></code></pre></td></tr></table></figure><p>下面我们一步步拆解这个工作流：</p><h3 id="1-Word文档解析与分块"><a href="#1-Word文档解析与分块" class="headerlink" title="1.Word文档解析与分块"></a>1.Word文档解析与分块</h3><p>一切始于源文件。我的工具首先会“接纳”用户上传的 <code>.docx</code> 格式的Word文档。</p><ul><li><p><strong>文档读取</strong>：通过 <code>python-docx</code> 这样的库，我们可以轻松提取文档中的所有段落内容。</p></li><li><p><strong>Token 精算与智能分块</strong>：这是解决长文档审核的关键！在将文本送给AI之前，利用 <code>tiktoken</code>（OpenAI出品的工具，也能适配很多其他模型）精确计算每个段落乃至整个文档的Token数量。然后，根据AI模型（比如我集成的DeepSeek, GLM, Qwen, Gemini等）的Token处理上限（这个上限用户可以在界面上灵活设置，比如4000 tokens），将整个文档智能地分割成若干个“小文本块”（chunks）。</p><p>这样做的好处显而易见：</p><ol><li><strong>突破长度限制</strong>：再长的文档，也能被拆解成AI可以从容处理的小单元。</li><li><strong>保证处理深度</strong>：每个小块都能得到AI的“全力关注”，而不是因为总字数太多而被AI“敷衍了事”。</li></ol></li></ul><h3 id="2-AI循环审稿"><a href="#2-AI循环审稿" class="headerlink" title="2.AI循环审稿"></a>2.AI循环审稿</h3><p>文档被切分成块后，就进入了核心的AI审稿环节。</p><ul><li><strong>循环处理</strong>：程序会遍历每一个文本块，将它们依次发送给选定的大语言模型。</li><li><strong>API调用</strong>：我集成了多种API，比如硅基流动（它代理了众多优秀国产模型）和Gemini。用户可以根据自己的偏好和API Key选择。</li><li><strong>实时反馈</strong>：为了提升用户体验，每当AI完成对一小块文本的审阅，结果就会立刻显示在界面上，并配有进度条，让用户能实时追踪审稿进度。</li></ul><h3 id="3-高度自定义的提示词（Prompt）"><a href="#3-高度自定义的提示词（Prompt）" class="headerlink" title="3.高度自定义的提示词（Prompt）"></a>3.高度自定义的提示词（Prompt）</h3><p>这绝对是整个工作流的“点睛之笔”，也是实现“个性化审稿专家”的核心。</p><ul><li><p><strong>强大的默认提示词</strong>：我内置了一套精心设计的默认提示词，它会引导AI从语法、标点、表达清晰度、逻辑连贯性、术语规范、格式序号等多个维度对文本进行细致入微的分析，并要求AI按照特定格式（如“原句”、“问题分析”、“修改建议”）输出结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 节选一部分默认提示词结构</span><br>default_prompt = <span class="hljs-string">&#x27;&#x27;&#x27;你是一位经验丰富的公文写作专家，请对以下段落进行详细审阅...</span><br><span class="hljs-string">【原文】：</span><br><span class="hljs-string">&quot;&#123;chunk&#125;&quot; # 这里就是文本块的占位符</span><br><span class="hljs-string">请从以下几个方面提出具体修改建议：</span><br><span class="hljs-string">1. **语法与标点**...</span><br><span class="hljs-string">2. **表达清晰度**...</span><br><span class="hljs-string">...</span><br><span class="hljs-string">请以以下格式输出结果：</span><br><span class="hljs-string">📌 原句：...</span><br><span class="hljs-string">🔍 问题分析：...</span><br><span class="hljs-string">🛠 修改建议：...</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>用户自定义提示词管理</strong>：更强大的是，我开发了一个独立的“提示词管理”页面。用户可以创建、编辑、保存和删除自己的提示词模板！这意味着：</p><ul><li>如果你在审核法律合同，可以设计一套专门检查条款严谨性、法律术语准确性的提示词。</li><li>如果你在打磨营销文案，可以创建一套引导AI评估吸引力、情感共鸣和CTA效果的提示词。</li><li>学术论文、技术手册、甚至是小说创作，都可以拥有自己专属的“审稿模式”。</li></ul><p>这些自定义提示词会保存在一个 <code>saved_prompts.json</code> 文件中，方便随时调用。在主审稿界面，用户可以轻松切换使用默认提示词或自己保存的任一模板。</p></li></ul><h3 id="4-多格式审稿报告输出"><a href="#4-多格式审稿报告输出" class="headerlink" title="4.多格式审稿报告输出"></a>4.多格式审稿报告输出</h3><p>AI审稿完成后，工具会提供两种实用的输出：</p><ol><li><strong>完整的Markdown审稿报告</strong>：将所有文本块的原文片段和AI的修改建议整合到一个Markdown文件中。结构清晰，方便查阅和二次编辑。</li><li><strong>带批注的Word文档</strong>：这是一个非常赞的功能！利用 <code>python-docx</code>，可以将AI的每一条修改建议作为“批注”直接添加到原始Word文档的相应段落。这样，用户就能在熟悉的Word环境中直观地看到问题所在和修改意见，极大提升了修改效率。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>AI的发展日新月异，它不再仅仅是“玩具”或“助手”，更可以成为我们工作流程中不可或缺的“专家伙伴”。我这套AI审稿工作流，正是基于这样的理念，通过巧妙的流程设计和对AI能力的深度挖掘，成功解决了我个人在文稿审核中的诸多痛点。</p><p>如果你也面临类似的困扰，不妨借鉴这个思路，尝试打造属于你自己的AI生产力工具。让AI不再只是“大概说说”，而是成为你信赖的“个性化审稿专家”！</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手搓第一个 MCP Server：实现水质在线数据查询</title>
    <link href="/2025/05/02/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%20MCP%20Server%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%B0%B4%E8%B4%A8%E5%9C%A8%E7%BA%BF%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
    <url>/2025/05/02/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%20MCP%20Server%EF%BC%9A%E5%AE%9E%E7%8E%B0%E6%B0%B4%E8%B4%A8%E5%9C%A8%E7%BA%BF%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>随着人工智能技术的快速发展，如何将大语言模型（LLM）与实际业务场景结合，提供精准、可控的服务成为一个热门话题。MCP（Model Context Protocol）作为一种开放协议，为应用程序向 LLM 提供标准化的上下文接口，极大地简化了这一过程。本文将以构建一个水质在线查询 MCP 服务为例，手把手带你从零开始实现一个功能强大且实用的 MCP Server。通过这个过程，你将深入理解 MCP 的核心机制，并掌握如何将其应用于实际场景。</p><hr><h2 id="什么是-MCP？"><a href="#什么是-MCP？" class="headerlink" title="什么是 MCP？"></a>什么是 MCP？</h2><p>MCP（Model Context Protocol）是一个为人工智能应用程序设计的标准化协议，旨在为大语言模型（LLM）提供统一的上下文输入和工具调用接口。可以将 MCP 比喻为 AI 世界的“USB-C 接口”：正如 USB-C 为设备连接外设提供了通用标准，MCP 为 AI 模型连接数据源、工具和业务逻辑提供了规范化的桥梁。</p><p>通过 MCP，开发者可以定义结构化的工具（Tools），让 LLM 根据用户需求智能调用这些工具，获取实时数据或执行特定任务。相比直接依赖 LLM 的生成能力，MCP 能够显著减少模型“幻觉”（生成不准确或虚构内容），提供更可靠的结果。</p><h3 id="MCP-的核心优势"><a href="#MCP-的核心优势" class="headerlink" title="MCP 的核心优势"></a>MCP 的核心优势</h3><ul><li><strong>标准化</strong>：提供统一的输入输出规范，兼容多种 LLM 和工具。</li><li><strong>灵活性</strong>：支持从本地数据查询到远程 API 调用的各种场景。</li><li><strong>可控性</strong>：通过工具调用，开发者可以精确控制模型的行为和输出。</li><li><strong>可扩展性</strong>：便于将服务部署到本地或云端，供个人或团队使用。</li></ul><p>官方文档：<a href="https://mcp-docs.cn/introduction">MCP 简介 - MCP 中文文档</a></p><hr><h2 id="从天气查询示例学习-MCP"><a href="#从天气查询示例学习-MCP" class="headerlink" title="从天气查询示例学习 MCP"></a>从天气查询示例学习 MCP</h2><p>为了更好地理解 MCP 的工作原理，我们先来看一个简单的天气查询 MCP 示例。这个示例通过调用美国国家气象服务（NWS）的 API，实现了天气预报和警报查询功能。以下是核心代码和逻辑分析：</p><h3 id="示例代码：天气查询-MCP"><a href="#示例代码：天气查询-MCP" class="headerlink" title="示例代码：天气查询 MCP"></a>示例代码：天气查询 MCP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span><br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">from</span> mcp.server.fastmcp <span class="hljs-keyword">import</span> FastMCP<br><br><span class="hljs-comment"># 初始化 FastMCP 服务</span><br>mcp = FastMCP(<span class="hljs-string">&quot;weather&quot;</span>)<br><br><span class="hljs-comment"># 常量定义</span><br>NWS_API_BASE = <span class="hljs-string">&quot;https://api.weather.gov&quot;</span><br>USER_AGENT = <span class="hljs-string">&quot;weather-app/1.0&quot;</span><br><br><span class="hljs-comment"># 辅助函数：发送请求并格式化数据</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_nws_request</span>(<span class="hljs-params">url: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>] | <span class="hljs-literal">None</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;向 NWS API 发送请求，并进行错误处理。&quot;&quot;&quot;</span><br>    headers = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>: USER_AGENT, <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/geo+json&quot;</span>&#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>        <span class="hljs-keyword">try</span>:<br>            response = <span class="hljs-keyword">await</span> client.get(url, headers=headers, timeout=<span class="hljs-number">30.0</span>)<br>            response.raise_for_status()<br>            <span class="hljs-keyword">return</span> response.json()<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">format_alert</span>(<span class="hljs-params">feature: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;将警报数据格式化为可读字符串。&quot;&quot;&quot;</span><br>    props = feature[<span class="hljs-string">&quot;properties&quot;</span>]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string">事件: <span class="hljs-subst">&#123;props.get(<span class="hljs-string">&#x27;event&#x27;</span>, <span class="hljs-string">&#x27;Unknown&#x27;</span>)&#125;</span></span><br><span class="hljs-string">区域: <span class="hljs-subst">&#123;props.get(<span class="hljs-string">&#x27;areaDesc&#x27;</span>, <span class="hljs-string">&#x27;Unknown&#x27;</span>)&#125;</span></span><br><span class="hljs-string">严重性: <span class="hljs-subst">&#123;props.get(<span class="hljs-string">&#x27;severity&#x27;</span>, <span class="hljs-string">&#x27;Unknown&#x27;</span>)&#125;</span></span><br><span class="hljs-string">描述: <span class="hljs-subst">&#123;props.get(<span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-string">&#x27;No description available&#x27;</span>)&#125;</span></span><br><span class="hljs-string">指示: <span class="hljs-subst">&#123;props.get(<span class="hljs-string">&#x27;instruction&#x27;</span>, <span class="hljs-string">&#x27;No specific instructions provided&#x27;</span>)&#125;</span></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 工具定义</span><br><span class="hljs-meta">@mcp.tool()</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_alerts</span>(<span class="hljs-params">state: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;获取美国州的天气警报。&quot;&quot;&quot;</span><br>    url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;NWS_API_BASE&#125;</span>/alerts/active/area/<span class="hljs-subst">&#123;state&#125;</span>&quot;</span><br>    data = <span class="hljs-keyword">await</span> make_nws_request(url)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;features&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;无法获取警报或未找到警报。&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data[<span class="hljs-string">&quot;features&quot;</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;该州没有活跃的警报。&quot;</span><br>    alerts = [format_alert(feature) <span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> data[<span class="hljs-string">&quot;features&quot;</span>]]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n---\n&quot;</span>.join(alerts)<br><br><span class="hljs-meta">@mcp.tool()</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_forecast</span>(<span class="hljs-params">latitude: <span class="hljs-built_in">float</span>, longitude: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;获取指定位置的天气预报。&quot;&quot;&quot;</span><br>    points_url = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;NWS_API_BASE&#125;</span>/points/<span class="hljs-subst">&#123;latitude&#125;</span>,<span class="hljs-subst">&#123;longitude&#125;</span>&quot;</span><br>    points_data = <span class="hljs-keyword">await</span> make_nws_request(points_url)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> points_data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;无法获取此位置的预报数据。&quot;</span><br>    forecast_url = points_data[<span class="hljs-string">&quot;properties&quot;</span>][<span class="hljs-string">&quot;forecast&quot;</span>]<br>    forecast_data = <span class="hljs-keyword">await</span> make_nws_request(forecast_url)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> forecast_data:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;无法获取详细预报。&quot;</span><br>    periods = forecast_data[<span class="hljs-string">&quot;properties&quot;</span>][<span class="hljs-string">&quot;periods&quot;</span>]<br>    forecasts = [<span class="hljs-string">f&quot;&quot;&quot;</span><br><span class="hljs-string"><span class="hljs-subst">&#123;period[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>:</span><br><span class="hljs-string">温度: <span class="hljs-subst">&#123;period[<span class="hljs-string">&#x27;temperature&#x27;</span>]&#125;</span>°<span class="hljs-subst">&#123;period[<span class="hljs-string">&#x27;temperatureUnit&#x27;</span>]&#125;</span></span><br><span class="hljs-string">风: <span class="hljs-subst">&#123;period[<span class="hljs-string">&#x27;windSpeed&#x27;</span>]&#125;</span> <span class="hljs-subst">&#123;period[<span class="hljs-string">&#x27;windDirection&#x27;</span>]&#125;</span></span><br><span class="hljs-string">预报: <span class="hljs-subst">&#123;period[<span class="hljs-string">&#x27;detailedForecast&#x27;</span>]&#125;</span></span><br><span class="hljs-string">&quot;&quot;&quot;</span> <span class="hljs-keyword">for</span> period <span class="hljs-keyword">in</span> periods[:<span class="hljs-number">5</span>]]<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n---\n&quot;</span>.join(forecasts)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    mcp.run(transport=<span class="hljs-string">&quot;stdio&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><strong>初始化 MCP 服务</strong>：通过 <code>FastMCP(&quot;weather&quot;)</code> 创建一个名为“weather”的 MCP 服务。</li><li><strong>定义辅助函数</strong>：<ul><li><code>make_nws_request</code>：请求 NWS API。</li><li><code>format_alert</code>：将 API 返回的警报数据格式化为用户友好的字符串。</li></ul></li><li><strong>定义工具</strong>：<ul><li><code>get_alerts</code>：根据州代码查询天气警报。</li><li><code>get_forecast</code>：根据经纬度查询天气预报。</li></ul></li><li><strong>运行服务</strong>：通过 <code>mcp.run(transport=&quot;stdio&quot;)</code> 启动服务，等待 LLM 调用。</li></ol><p>这个示例展示了 MCP 的核心思想：通过标准化的工具接口，将外部数据（天气 API）与 LLM 的自然语言处理能力结合，提供精准的查询结果。</p><hr><h2 id="动手实践：构建水质查询-MCP"><a href="#动手实践：构建水质查询-MCP" class="headerlink" title="动手实践：构建水质查询 MCP"></a>动手实践：构建水质查询 MCP</h2><p>基于天气查询的经验，我们现在来实现一个水质在线查询 MCP 服务。该服务允许用户通过自然语言输入时间范围、站点名称和监测因子，查询水质监测数据。以下是完整实现步骤和代码。</p><h3 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h3><ol><li><p><strong>初始化 Python 项目</strong>：<br>使用 <code>uv</code> 工具初始化项目并安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv init firstmcp<br><span class="hljs-built_in">cd</span> firstmcp<br>uv add mcp[cli] httpx pandas pymysql<br></code></pre></td></tr></table></figure></li><li><p><strong>数据源说明</strong>：<br>水质数据可以来自多种来源，例如：</p><ul><li>远程 API 接口</li><li>MySQL 数据库</li><li>Excel 文件<br>本示例假设数据通过 <code>multi_station_data</code> 函数从数据库或文件中获取，返回一个 Pandas DataFrame。</li></ul></li></ol><h3 id="核心代码：水质查询-MCP"><a href="#核心代码：水质查询-MCP" class="headerlink" title="核心代码：水质查询 MCP"></a>核心代码：水质查询 MCP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span><br><span class="hljs-keyword">from</span> mcp.server.fastmcp <span class="hljs-keyword">import</span> FastMCP<br><br><span class="hljs-comment"># 初始化 MCP 服务</span><br>mcp = FastMCP(<span class="hljs-string">&quot;water_quality&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">multi_station_data</span>(<span class="hljs-params">stations: <span class="hljs-built_in">list</span>, start_date: datetime, end_date: datetime</span>) -&gt; pd.DataFrame:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    获取多个站点在指定时间范围内的水质监测数据。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        stations: 站点名称列表</span><br><span class="hljs-string">        start_date: 开始时间</span><br><span class="hljs-string">        end_date: 结束时间</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        DataFrame: 包含监测数据的表格</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 示例：模拟从数据库或 API 获取数据</span><br>    <span class="hljs-comment"># 实际实现中可替换为 MySQL 查询、API 调用或 Excel 读取</span><br>    <span class="hljs-comment"># 以下仅为示例</span><br>    data = &#123;<br>        <span class="hljs-string">&quot;监测时间&quot;</span>: [datetime(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>), datetime(<span class="hljs-number">2025</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>)],<br>        <span class="hljs-string">&quot;设备名称&quot;</span>: [stations[<span class="hljs-number">0</span>], stations[<span class="hljs-number">0</span>]],<br>        <span class="hljs-string">&quot;氨氮&quot;</span>: [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>],<br>        <span class="hljs-string">&quot;总磷&quot;</span>: [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.25</span>],<br>        <span class="hljs-string">&quot;高锰酸盐指数&quot;</span>: [<span class="hljs-number">2.1</span>, <span class="hljs-number">2.3</span>]<br>    &#125;<br>    <span class="hljs-keyword">return</span> pd.DataFrame(data)<br><br><span class="hljs-meta">@mcp.tool()</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_water_quality</span>(<span class="hljs-params"></span><br><span class="hljs-params">    start_time: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">    end_time: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">    station_name: <span class="hljs-built_in">str</span>,</span><br><span class="hljs-params">    factors: <span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span></span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    查询指定站点和时间范围内的水质监测数据。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        start_time: 开始时间 (格式: YYYY-MM-DD HH:MM:SS)</span><br><span class="hljs-string">        end_time: 结束时间 (格式: YYYY-MM-DD HH:MM:SS)</span><br><span class="hljs-string">        station_name: 站点名称</span><br><span class="hljs-string">        factors: 逗号分隔的因子名称 (例如: &#x27;氨氮,总磷,高锰酸盐指数&#x27;)，可选</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        str: 格式化的查询结果</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 解析时间参数</span><br>        start_date = datetime.strptime(start_time, <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br>        end_date = datetime.strptime(end_time, <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br>        <br>        <span class="hljs-comment"># 查询数据</span><br>        df_water = multi_station_data([station_name], start_date, end_date)<br>        <span class="hljs-keyword">if</span> df_water <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> df_water.empty:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;未找到符合条件的监测数据。&quot;</span><br>        <br>        <span class="hljs-comment"># 确保时间格式正确</span><br>        df_water[<span class="hljs-string">&quot;监测时间&quot;</span>] = pd.to_datetime(df_water[<span class="hljs-string">&quot;监测时间&quot;</span>])<br>        <br>        <span class="hljs-comment"># 筛选指定因子</span><br>        <span class="hljs-keyword">if</span> factors:<br>            factors_list = [factor.strip() <span class="hljs-keyword">for</span> factor <span class="hljs-keyword">in</span> factors.split(<span class="hljs-string">&quot;,&quot;</span>)]<br>            valid_factors = [f <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> factors_list <span class="hljs-keyword">if</span> f <span class="hljs-keyword">in</span> df_water.columns]<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid_factors:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;指定的因子在监测数据中不存在。&quot;</span><br>            df_water = df_water[[<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&quot;设备名称&quot;</span>] + valid_factors]<br>        <br>        <span class="hljs-comment"># 格式化输出</span><br>        result = df_water.to_string(index=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">return</span> result<br>    <br>    <span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;参数错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;发生错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    mcp.run(transport=<span class="hljs-string">&quot;stdio&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="代码解析-1"><a href="#代码解析-1" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><strong>初始化 MCP 服务</strong>：<ul><li>使用 <code>FastMCP(&quot;water_quality&quot;)</code> 创建一个名为“water_quality”的服务。</li></ul></li><li><strong>数据获取函数</strong>：<ul><li><code>multi_station_data</code> 是一个占位函数，模拟从数据源获取水质数据。实际应用中，你可以替换为：<ul><li>MySQL 查询：使用 <code>pymysql</code> 连接数据库。</li><li>API 调用：使用 <code>requests</code> 或 <code>httpx</code> 获取远程数据。</li><li>Excel 读取：使用 <code>pandas.read_excel</code>。</li></ul></li></ul></li><li><strong>工具定义</strong>：<ul><li><code>get_water_quality</code> 工具接受时间范围、站点名称和可选的因子列表，查询并返回格式化的水质数据。</li><li>使用 Pandas 处理数据，支持动态筛选因子。</li></ul></li><li><strong>错误处理</strong>：<ul><li>捕获时间格式错误、数据缺失等异常，返回用户友好的提示。</li></ul></li></ol><h2 id="集成到-Trae-平台"><a href="#集成到-Trae-平台" class="headerlink" title="集成到 Trae 平台"></a>集成到 Trae 平台</h2><p>Trae 是一个支持 MCP 的 AI 平台（本文基于 Trae 1.3.3 版本），可以轻松将你的 MCP 服务集成到其生态中。以下是集成步骤：</p><ol><li><p><strong>打开 Trae 设置</strong>：</p><ul><li>点击个人头像，选择“AI 功能管理” -&gt; “MCP”。</li><li>点击“添加”，选择“手动配置”。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250501_115802.png" alt="手动配置mcp"></li></ul></li><li><p><strong>配置 MCP 服务</strong>：</p><ul><li>复制以下 JSON 配置到配置框，注意将修改为你项目的实际路径：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;waterquality&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uv&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;--directory&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;D:/python/learn/first_mcp/firstmcp&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;run&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;single.py&quot;</span><br>      <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>确认并测试</strong>：</p><ul><li>点击“确认”，Trae 会验证配置。如果成功，会显示 ✅ 并提示服务可用。</li><li>在 Trae 对话界面输入类似“查询 2025-05-01 10:00:00 至 2025-05-01 12:00:00 的某站点氨氮数据”，即可测试效果。</li></ul></li></ol><h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>以下是一个测试示例（假设使用 Claude 3.5 模型）：</p><ul><li><strong>用户输入</strong>：查询某站点最新的高指数据数据。</li><li><strong>模型输出</strong>：成功分析出所需要的入参和查询结果，并自动判断是否超标。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250502_170756.png" alt="测试效果截图"></p><hr><h2 id="部署到服务器（进阶）"><a href="#部署到服务器（进阶）" class="headerlink" title="部署到服务器（进阶）"></a>部署到服务器（进阶）</h2><p>目前，我们的服务运行在本地。如果希望团队或公众使用，可以将 MCP 服务部署到服务器，公开部署后，其他用户可以像添加 Cherry Studio 的公开 MCP 服务一样，轻松接入你的水质查询服务。</p><hr><h2 id="MCP-的应用价值与思考"><a href="#MCP-的应用价值与思考" class="headerlink" title="MCP 的应用价值与思考"></a>MCP 的应用价值与思考</h2><p>通过以上实践，我们成功构建了一个水质查询 MCP 服务。这只是 MCP 应用的冰山一角。MCP 的真正价值在于其标准化的工具调用机制，能够将 LLM 的语言理解能力与结构化数据和业务逻辑无缝结合。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一个水质查询 MCP 服务的实现，详细介绍了 MCP 的核心概念、开发流程和集成方法。从天气查询示例到水质查询实践，我们看到 MCP 如何将 LLM 与外部数据源结合，提供精准、可控的服务。通过集成到 Trae 平台和可能的服务器部署，MCP 展现了从本地开发到广泛应用的潜力。</p><p>MCP 不仅是一种技术工具，更是一种设计智能体的思维方式。它鼓励开发者将业务逻辑封装为标准化的工具，让 AI 更好地服务于现实世界。希望本文能启发你动手实践，探索 MCP 在更多场景中的可能性！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://mcp-docs.cn/introduction">MCP 简介 - MCP 中文文档</a></li><li><a href="https://docs.trae.ai/ide/what-is-trae?_lang=zh">Trae 官方文档</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>AIGC</tag>
      
      <tag>mcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UV入门指南：更快的Python包管理工具实践</title>
    <link href="/2025/04/25/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/UV%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9B%B4%E5%BF%AB%E7%9A%84Python%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/04/25/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/UV%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9B%B4%E5%BF%AB%E7%9A%84Python%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="什么是-UV？"><a href="#什么是-UV？" class="headerlink" title="什么是 UV？"></a>什么是 UV？</h2><p><a href="https://docs.astral.sh/uv/">UV</a> 是一款由 Rust 编写的现代化 Python 包管理工具，凭借其惊人的性能和直观的用户体验迅速崭露头角。作为传统 pip 的强力替代品，UV 不仅提供了极速的依赖解析能力，还带来了更智能的包管理体验和全方位的项目环境控制。<br><strong>还有他是学习 python 构建 mcp 的基础。</strong></p><h2 id="UV-的核心优势-✨"><a href="#UV-的核心优势-✨" class="headerlink" title="UV 的核心优势 ✨"></a>UV 的核心优势 ✨</h2><ul><li><strong>极速安装</strong>：相比传统工具，依赖解析和包安装速度提升 <strong>10-100 倍</strong></li><li><strong>一站式解决方案</strong>：一个工具替代 pip、pip-tools、pipx、poetry、pyenv、virtualenv 等多种工具</li><li><strong>智能依赖管理</strong>：自动处理复杂依赖关系，有效避免版本冲突</li><li><strong>虚拟环境集成</strong>：无缝创建和管理项目虚拟环境</li><li><strong>通用锁文件支持</strong>：通过 <code>uv.lock</code> 确保环境一致性</li><li><strong>全面的 Python 版本管理</strong>：轻松安装和切换不同 Python 版本</li><li><strong>空间高效</strong>：全局缓存机制实现依赖项去重，节省磁盘空间</li><li><strong>跨平台支持</strong>：完美支持 macOS、Linux 和 Windows</li></ul><h2 id="安装指南-💻"><a href="#安装指南-💻" class="headerlink" title="安装指南 💻"></a>安装指南 💻</h2><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">powershell -ExecutionPolicy ByPass -c <span class="hljs-string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span><br></code></pre></td></tr></table></figure><h3 id="MacOS-和-Linux-系统"><a href="#MacOS-和-Linux-系统" class="headerlink" title="MacOS 和 Linux 系统"></a>MacOS 和 Linux 系统</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LsSf https://astral.sh/uv/install.sh | sh<br></code></pre></td></tr></table></figure><p>安装成功后，您将看到类似以下的输出：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">PS D:\python\learn\uv_learn&gt; powershell -ExecutionPolicy ByPass -c <span class="hljs-string">&quot;irm https://astral.sh/uv/install.ps1 | iex&quot;</span><br>Downloading uv <span class="hljs-number">0.6</span><span class="hljs-number">.16</span> (x86_64-pc-windows-msvc)<br>Installing <span class="hljs-keyword">to</span> C:\Users\chenw\.<span class="hljs-keyword">local</span>\bin<br>  uv.exe<br>  uvx.exe<br>everything&#x27;s installed!<br><br>To add C:\Users\chenw\.<span class="hljs-keyword">local</span>\bin <span class="hljs-keyword">to</span> your PATH, either restart your shell <span class="hljs-keyword">or</span> <span class="hljs-built_in">run</span>:<br><br>    <span class="hljs-keyword">set</span> Path=C:\Users\chenw\.<span class="hljs-keyword">local</span>\bin;%Path%   (cmd)<br>    $env:Path = <span class="hljs-string">&quot;C:\Users\chenw\.local\bin;$env:Path&quot;</span>   (powershell)<br></code></pre></td></tr></table></figure><blockquote><p>💡 <strong>提示</strong>：按照提示将 UV 添加到系统环境变量，然后重启终端或电脑使其生效。</p></blockquote><h2 id="UV-实战指南：从零开始一个项目-🛠️"><a href="#UV-实战指南：从零开始一个项目-🛠️" class="headerlink" title="UV 实战指南：从零开始一个项目 🛠️"></a>UV 实战指南：从零开始一个项目 🛠️</h2><h3 id="Python-版本管理"><a href="#Python-版本管理" class="headerlink" title="Python 版本管理"></a>Python 版本管理</h3><p><strong>查看可用的 Python 版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv python list<br></code></pre></td></tr></table></figure><p>这个命令会列出所有支持的 Python 版本以及您本地已安装的版本。</p><p><strong>查找特定版本的 Python</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv python find 3.13<br></code></pre></td></tr></table></figure><p><strong>安装新的 Python 版本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv python install 3.13<br></code></pre></td></tr></table></figure><h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv init [项目名称]<br></code></pre></td></tr></table></figure><blockquote><p>项目名称可选，不指定时将使用当前文件夹名称</p></blockquote><p>初始化后，UV 会自动创建项目配置文件，并识别系统中的 Python 版本：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250425_164457.png" alt="项目初始化示例"></p><h3 id="包管理操作"><a href="#包管理操作" class="headerlink" title="包管理操作"></a>包管理操作</h3><p><strong>添加依赖包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv add pandas<br></code></pre></td></tr></table></figure><p>执行此命令后，UV 会自动：</p><ul><li>创建虚拟环境（. Venv）</li><li>更新锁文件（uv. Lock）</li><li>修改项目配置（pyproject. Toml）</li></ul><blockquote><p>⚠️ <strong>注意</strong>：在 Trae&#x2F;vscode 编辑器中使用时，建议先关闭 pyproject. Toml 文件再安装第三方库，避免潜在冲突。</p></blockquote><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250425171228283.png" alt="包安装示例"></p><p><strong>查看依赖关系树</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv tree<br></code></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">PS D:\python\learn\uv_learn&gt; uv tree<br>Resolved 7 packages in 0.84ms<br>uv-learn v0.1.0<br>├── numpy v2.2.5<br>└── pandas v2.2.3<br>    ├── numpy v2.2.5<br>    ├── python-dateutil v2.9.0.post0<br>    │   └── six v1.17.0<br>    ├── pytz v2025.2<br>    └── tzdata v2025.2<br></code></pre></td></tr></table></figure><p><strong>移除依赖包</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv remove pandas<br></code></pre></td></tr></table></figure><p>此命令会自动更新所有相关文件，包括虚拟环境、锁文件和项目配置。</p><p><strong>依赖文件</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">uv pip <span class="hljs-keyword">install</span> -r requirements.txt<br></code></pre></td></tr></table></figure><p>快速创建依赖文件，无需单独安装其他库</p><p><strong>同步项目环境</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv <span class="hljs-built_in">sync</span><br></code></pre></td></tr></table></figure><p>根据 pyproject. Toml、. Python-version 等配置文件更新虚拟环境，确保环境与配置一致。</p><h2 id="脚本运行与工具集成-🧰"><a href="#脚本运行与工具集成-🧰" class="headerlink" title="脚本运行与工具集成 🧰"></a>脚本运行与工具集成 🧰</h2><h3 id="内联依赖的脚本运行"><a href="#内联依赖的脚本运行" class="headerlink" title="内联依赖的脚本运行"></a>内联依赖的脚本运行</h3><p>UV 支持在单文件脚本中声明依赖并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个简单的脚本并添加依赖</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;import requests; print(requests.get(&quot;https://astral.sh&quot;))&#x27;</span> &gt; example.py<br><br><span class="hljs-comment"># 为脚本添加依赖</span><br>uv add --script example.py requests<br><br><span class="hljs-comment"># 在隔离环境中运行脚本</span><br>uv run example.py<br></code></pre></td></tr></table></figure><h3 id="代码质量工具集成"><a href="#代码质量工具集成" class="headerlink" title="代码质量工具集成"></a>代码质量工具集成</h3><p>UV 提供了与常用开发工具的无缝集成：</p><p><strong>代码格式检查（Flake 8）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv tool install flake8<br>uvx flake8  <span class="hljs-comment"># 或使用 uv tool run flake8</span><br></code></pre></td></tr></table></figure><p><strong>代码质量检查（Ruff）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv tool install ruff<br>uv tool run ruff check<br></code></pre></td></tr></table></figure><blockquote><p>💡 <strong>小贴士</strong>：虽然现代 IDE 已经集成了类似功能，但 UV 的工具集成在 CI&#x2F;CD 流程或团队协作中仍然非常有价值。</p></blockquote><p><strong>查询已安装的工具</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv tool list<br></code></pre></td></tr></table></figure><h2 id="项目打包与发布-📦"><a href="#项目打包与发布-📦" class="headerlink" title="项目打包与发布 📦"></a>项目打包与发布 📦</h2><p>在 pyproject. Toml 中添加脚本入口点：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[project.scripts]</span><br><span class="hljs-attr">simpleai</span> = <span class="hljs-string">&quot;main:main&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>simpleai = &quot;main:main&quot;</code>，等号前是脚本名称，后面分别是脚本和函数名。</p><p><strong>打包项目</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv build<br></code></pre></td></tr></table></figure><p>这将项目打包为 whl 和 tar. Gz 文件，whl 文件可发布为第三方库。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250425_221315.png" alt="打包结果"></p><p><strong>将本地 whl 作为工具安装</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uv tool install dist\uv_learn-0.1.1-py3-none-any.whl<br></code></pre></td></tr></table></figure><p>安装后可直接使用 simpleai 命令：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250425222008187.png" alt="工具安装后使用"></p><h2 id="总结与展望-🔮"><a href="#总结与展望-🔮" class="headerlink" title="总结与展望 🔮"></a>总结与展望 🔮</h2><p>UV 作为新一代 Python 包管理工具，通过其惊人的性能和友好的用户体验，为 Python 开发者带来了革命性的开发体验。无论是个人项目还是团队协作，UV 都能显著提升开发效率和环境一致性。</p><p>而且 uv 和 uvx 也是 python 构建 mcp 的基础。为构建自己的 mcp sever 打下基础。</p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><ul><li>[Python 解释器如何选择]<a href="https://mp.weixin.qq.com/s/clJ22Y4GK_jDRM4rSF1O6A">https://mp.weixin.qq.com/s/clJ22Y4GK_jDRM4rSF1O6A</a></li><li>[Cherry Studio 入门 MCP：为你的大模型插上翅膀]<a href="https://mp.weixin.qq.com/s/tWTBpoQ3ER_P2ZQhGKyjqg">https://mp.weixin.qq.com/s/tWTBpoQ3ER_P2ZQhGKyjqg</a></li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如有帮助，请收藏点赞<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a> </p><p>Ping 192.168.30.21<br>Ping 192.168.30.22</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Qwen2.5-VL模型及水质污染特征分析的河道污染识别研究</title>
    <link href="/2025/03/23/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E5%9F%BA%E4%BA%8EQwen2.5-VL%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%B0%B4%E8%B4%A8%E6%B1%A1%E6%9F%93%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90%E7%9A%84%E6%B2%B3%E9%81%93%E6%B1%A1%E6%9F%93%E8%AF%86%E5%88%AB%E7%A0%94%E7%A9%B6/"/>
    <url>/2025/03/23/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E5%9F%BA%E4%BA%8EQwen2.5-VL%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%B0%B4%E8%B4%A8%E6%B1%A1%E6%9F%93%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90%E7%9A%84%E6%B2%B3%E9%81%93%E6%B1%A1%E6%9F%93%E8%AF%86%E5%88%AB%E7%A0%94%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>AI 赋能水环境监测：国产大模型的创新实践</p><h2 id="1-研究背景：AI-赋能水环境监测，国产大模型大有可为"><a href="#1-研究背景：AI-赋能水环境监测，国产大模型大有可为" class="headerlink" title="1. 研究背景：AI 赋能水环境监测，国产大模型大有可为"></a>1. 研究背景：AI 赋能水环境监测，国产大模型大有可为</h2><p>随着中国生态文明建设的持续深入，水环境保护已成为环境保护工作的重中之重。近年来，国家不断加强水生态环境的监测与治理，河道监控系统与水质监测站点的建设日益普及。然而，现有的水环境监测体系仍然面临着诸多挑战：</p><ul><li><strong>数据处理低效</strong>：海量的视频和传感器数据需要人工分析，耗时耗力，且容易受到主观因素的影响。</li><li><strong>商业方案昂贵</strong>：现有的智能水质监测系统多为订阅制服务，成本高昂，难以广泛推广。</li><li><strong>识别精度不足</strong>：由于水质污染源识别的训练数据集相对较小，且行业应用较为小众，现有 AI 系统的识别效果往往难以满足实际需求。</li></ul><p>与此同时，以千问为代表的国产大模型正在快速崛起，并在文本理解、图像识别、视频分析等领域展现出强大的能力。尤其是在 2025 年初，阿里巴巴发布的 <code>Qwen 2.5-VL</code> 系列模型在视觉理解领域取得了显著突破。其开源版本（如 <code>Qwen 2.5-VL-7 B-Instruct</code>）已经展现出卓越的图像识别和理解能力，为水环境污染源的自动识别奠定了坚实的技术基础。</p><p>本研究旨在探索如何利用 <code>Qwen 2.5-VL</code> 系列模型的强大视觉理解能力，结合水质监测数据的多因子分析，构建一套高效、精准、经济的河道污染识别系统，从而为水环境保护工作提供强有力的技术支持。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250323083236698.png" alt="Qwen 2.5-VL开源视图"></p><h2 id="2-研究思路：视觉-AI-与数据分析双剑合璧"><a href="#2-研究思路：视觉-AI-与数据分析双剑合璧" class="headerlink" title="2. 研究思路：视觉 AI 与数据分析双剑合璧"></a>2. 研究思路：视觉 AI 与数据分析双剑合璧</h2><p>本研究采用“视觉识别+数据分析”的双轨并行思路，将视觉大模型对水体图像&#x2F;视频的识别与多因子水质数据的关联分析相结合，实现对河道污染的全面监测与智能预警：</p><ol><li><strong>视觉识别路径</strong>：利用 <code>Qwen 2.5-VL</code> 模型对河道监控图像和视频进行实时分析，精准识别水体变色、漂浮物、藻类爆发等直观可见的污染现象。</li><li><strong>数据分析路径</strong>：基于水质监测站点采集的多项指标（如高锰酸盐指数、总磷、氨氮、温度、pH 值、溶解氧等），建立水质状态评估模型，敏锐捕捉数据层面的异常变化。</li><li><strong>多源融合判断</strong>：将视觉识别结果与水质数据分析结果进行交叉验证和融合判断，显著提高污染识别的准确性和可靠性。</li><li><strong>污染特征分析</strong>：针对常见水污染类型（如藻类爆发、污染汇入等），建立详尽的特征模式库，实现污染类型的精准判别。</li><li><strong>预警响应机制</strong>：根据污染识别结果，建立分级预警机制，并提供污染源追溯和治理建议，为决策提供支持。</li></ol><h2 id="3-技术路线：四模块联动，打造智能水环境监测系统"><a href="#3-技术路线：四模块联动，打造智能水环境监测系统" class="headerlink" title="3. 技术路线：四模块联动，打造智能水环境监测系统"></a>3. 技术路线：四模块联动，打造智能水环境监测系统</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250323183557085.png" alt="技术路线"></p><h3 id="3-1-系统整体架构"><a href="#3-1-系统整体架构" class="headerlink" title="3.1 系统整体架构"></a>3.1 系统整体架构</h3><p>本研究构建的河道污染识别系统由四个核心模块组成：数据采集模块、Qwen 2.5-VL 视觉识别模块、水质数据分析模块和综合判断预警模块。</p><h3 id="3-2-数据采集模块"><a href="#3-2-数据采集模块" class="headerlink" title="3.2 数据采集模块"></a>3.2 数据采集模块</h3><ol><li><strong>视频数据采集</strong>：在河道关键位置部署高清监控摄像头，实时采集水体表面图像和视频流。</li><li><strong>水质数据采集</strong>：通过水质自动监测站，高频采集水温、pH 值、溶解氧、浊度、电导率等关键指标数据。</li><li><strong>数据预处理</strong>：对采集的图像进行增强和去噪处理，提升图像质量；对水质数据进行标准化和异常值检测，确保数据可靠性。</li></ol><h3 id="3-3-Qwen-2-5-VL-视觉识别模块"><a href="#3-3-Qwen-2-5-VL-视觉识别模块" class="headerlink" title="3.3 Qwen 2.5-VL 视觉识别模块"></a>3.3 Qwen 2.5-VL 视觉识别模块</h3><ol><li><strong>模型部署</strong>：根据实际需求，将 <code>Qwen 2.5-VL-7 B-Instruct</code> 模型部署于边缘计算设备或云服务器。</li><li><strong>图像识别</strong>：利用 <code>Qwen 2.5-VL</code> 模型强大的图像识别能力，对水体图像进行智能分析，识别水体颜色异常、漂浮物、藻类等污染现象。</li><li><strong>污染定位</strong>：通过生成精确的边界框，精确定位污染区域，为后续治理工作提供精确的空间信息。</li><li><strong>时序分析</strong>：对连续采集的图像序列进行分析，识别动态变化趋势，为污染预警提供依据。</li></ol><h3 id="3-4-水质数据分析模块"><a href="#3-4-水质数据分析模块" class="headerlink" title="3.4 水质数据分析模块"></a>3.4 水质数据分析模块</h3><ol><li><strong>单因子异常检测</strong>：对各项水质指标进行时序分析，及时检测异常波动，发现潜在污染风险。</li><li><strong>多因子关联分析</strong>：深入分析水温、pH 值、溶解氧等指标间的相关性，识别特定污染模式，提升识别精度。</li><li><strong>历史数据比对</strong>：将当前数据与历史同期数据进行比对，识别季节性波动与异常污染，排除干扰因素。</li></ol><h3 id="3-5-综合判断预警模块"><a href="#3-5-综合判断预警模块" class="headerlink" title="3.5 综合判断预警模块"></a>3.5 综合判断预警模块</h3><ol><li><strong>多源信息融合</strong>：融合视觉识别结果与水质数据分析结果，进行综合判断，提升预警准确性。</li><li><strong>污染类型识别</strong>：基于预设的污染特征库，判断污染类型（如工业污染、农业面源污染、藻类爆发等），为治理提供参考。</li><li><strong>预警分级</strong>：根据污染严重程度，发出不同级别的预警信息，确保及时响应。</li><li><strong>决策支持</strong>：为管理部门提供污染源追溯和治理方案建议，辅助科学决策。</li></ol><h2 id="4-实现方法：软硬件协同，精细化模型调优"><a href="#4-实现方法：软硬件协同，精细化模型调优" class="headerlink" title="4. 实现方法：软硬件协同，精细化模型调优"></a>4. 实现方法：软硬件协同，精细化模型调优</h2><h3 id="4-1-Qwen-2-5-VL-模型的部署与应用"><a href="#4-1-Qwen-2-5-VL-模型的部署与应用" class="headerlink" title="4.1 Qwen 2.5-VL 模型的部署与应用"></a>4.1 Qwen 2.5-VL 模型的部署与应用</h3><ol><li><strong>模型选择与优化</strong>：<ul><li>针对边缘计算场景，选用轻量级的 <code>Qwen 2.5-VL-7 B-Instruct</code> 模型，降低资源占用。</li><li>针对云计算场景，可选用更大规模的 <code>Qwen 2.5-VL-72 B-Instruct</code> 模型，提升识别精度。</li><li>采用模型量化技术，进一步降低资源消耗，提高推理速度。</li></ul></li><li><strong>模型微调</strong>：<ul><li>收集水环境污染图像数据集，构建高质量的训练样本。</li><li>基于收集的数据集对模型进行领域适应性微调，提升模型在水环境监测任务上的性能。</li><li>采用少样本学习方法，提升对稀有污染类型的识别能力。</li></ul></li><li><strong>推理优化</strong>：<ul><li>设计针对性的提示模板（Prompt Templates），优化模型输入，提高识别准确性。</li><li>实现批处理机制，提高图像处理效率，降低延迟。</li><li>建立反馈机制，持续收集和分析模型识别结果，不断优化模型表现。</li></ul></li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250323083005608.png" alt="水质监测图像示例"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250323083049199.png" alt="水质监测图像示例"></p><h3 id="4-2-水质污染特征分析实现"><a href="#4-2-水质污染特征分析实现" class="headerlink" title="4.2 水质污染特征分析实现"></a>4.2 水质污染特征分析实现</h3><p><strong>藻类爆发特征分析</strong><br>通过配置触发条件（如高锰酸盐指数默认限值 6 mg&#x2F;L，气温默认限值 15℃）和相关性分析因子（高锰酸盐指数、溶解氧、pH、水温），结合最近 3 天数据进行分析。算法首先检查气温和高锰酸盐指数是否超标，然后计算各因子与高锰酸盐指数的相关系数（限值默认 0.8），并分析其时序变化是否存在周期性波动（如下午高、凌晨低）。当条件满足时，触发藻类爆发预警，输出结论如：“某站点于某时间段，高锰酸盐指数与相关因子高度相关且呈周期性波动，疑似藻类活跃，请关注。”</p><p><strong>污染汇入特征分析</strong><br>基于高锰酸盐指数与氨氮、总磷、COD 等因子的相关性（限值默认 0.8），分析最近 24 小时数据。算法计算相关系数，检查多因子是否同时显著上升，并结合浊度变化判断是否存在降雨导致的污染物溢流。若多个因子高度相关且呈上升趋势，则触发污染汇入预警，输出如：“某站点于某时间段，高锰酸盐指数与氨氮、总磷等相关性分别为某值，且均上升，疑似污染物汇入。”</p><p><strong>波动与趋势判断</strong><br>通过数据预处理（如滑动窗口平滑、去除异常值），采用傅里叶变换和自相关函数检测周期性特征，匹配藻类活动模式；同时利用一阶差分、线性回归和突变点检测分析趋势和突变位置，确保分析结果准确可靠。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141415110.png" alt="藻类爆发特征分析"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250323174432733.png" alt="污染汇入特征分析"></p><h3 id="4-3-系统集成与部署"><a href="#4-3-系统集成与部署" class="headerlink" title="4.3 系统集成与部署"></a>4.3 系统集成与部署</h3><ol><li><strong>硬件平台选择</strong>：<ul><li>边缘计算节点：选择配备 GPU 的工业级计算机或嵌入式设备，满足 AI 计算需求。</li><li>通信网络：采用 4 G&#x2F;5 G 无线网络或有线网络，确保数据传输的稳定性和可靠性。</li><li>服务器端：构建 GPU 服务器集群，提供强大的计算能力和存储空间。</li></ul></li><li><strong>软件架构设计</strong>：<ul><li>采用微服务架构，实现各功能模块的独立部署和弹性伸缩。</li><li>使用消息队列实现高并发数据处理，确保系统的稳定性和可靠性。</li><li>采用时序数据库存储水质监测数据，优化数据查询和分析效率。</li><li>建立 Web 可视化界面，直观展示监测结果和预警信息，方便用户使用。</li></ul></li><li><strong>系统优化</strong>：<ul><li>实现数据缓存机制，减轻服务器负担，提高响应速度。</li><li>设计任务调度策略，合理分配计算资源，提高系统整体效率。</li><li>实现模型热更新机制，便于系统升级和功能扩展。</li></ul></li></ol><h2 id="5-应用前景：多场景落地，助力智慧水务发展"><a href="#5-应用前景：多场景落地，助力智慧水务发展" class="headerlink" title="5. 应用前景：多场景落地，助力智慧水务发展"></a>5. 应用前景：多场景落地，助力智慧水务发展</h2><h3 id="5-1-环境监管应用"><a href="#5-1-环境监管应用" class="headerlink" title="5.1 环境监管应用"></a>5.1 环境监管应用</h3><ol><li><strong>实时监控与预警</strong>：为环保部门提供河道水质状况的实时监控，及时发现并预警潜在污染事件，提升监管效率。</li><li><strong>污染溯源</strong>：通过对污染特征的识别和时空分析，辅助环保执法人员快速锁定污染源，提高执法效率。</li><li><strong>执法取证</strong>：系统可自动记录污染事件的发生过程，为环保执法提供可靠的证据，规范执法行为。</li></ol><h3 id="5-2-生态管理应用"><a href="#5-2-生态管理应用" class="headerlink" title="5.2 生态管理应用"></a>5.2 生态管理应用</h3><ol><li><strong>生态系统评估</strong>：通过长期监测数据，评估河道生态系统健康状况，为生态保护提供依据。</li><li><strong>藻类灾害预防</strong>：对藻类爆发进行早期识别和预警，防止水华灾害发生，保障水生态安全。</li><li><strong>治理效果评估</strong>：对比治理前后的水质状况，客观评估治理措施的效果，为后续治理提供参考。</li></ol><h3 id="5-3-智慧城市集成"><a href="#5-3-智慧城市集成" class="headerlink" title="5.3 智慧城市集成"></a>5.3 智慧城市集成</h3><ol><li><strong>数字孪生融合</strong>：与城市水系统数字孪生平台对接，实现水环境的可视化管理，提升管理水平。</li><li><strong>多部门协同</strong>：为环保、水利、城管等多部门提供统一的水环境监管平台，打破信息壁垒，实现协同管理。</li><li><strong>公众参与</strong>：开发公众版应用，让市民了解河道水质状况，参与环保监督，提升公众环保意识。</li></ol><h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6. 结论"></a>6. 结论</h2><ol><li><strong>技术可行性</strong>：初步测试表明，Qwen 2.5-VL 模型对水体污染的视觉识别能力达到实用水平，结合水质多因子分析可实现更为可靠的污染识别，验证了技术方案的可行性。</li><li><strong>应用价值</strong>：相比传统商业解决方案，基于开源模型的系统可显著降低部署和维护成本，具有更高的性价比。自动化识别和预警可减少人工巡查工作量，提高监管效率，提升水环境管理水平。该技术路线可有效解决现有水环境监测系统中的痛点问题，实现高效、精准、经济的河道污染识别，具有显著的应用价值。</li></ol><hr><p><strong>BY</strong></p><p>如有帮助，请收藏点赞，未经本人允许，本文禁止转载。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>工作总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Cherry Studio 入门 MCP 为大模型插上翅膀</title>
    <link href="/2025/03/22/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E4%BB%8ECherry%20Studio%20%E5%85%A5%E9%97%A8%20MCP%EF%BC%8C%20%E4%B8%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8F%92%E4%B8%8A%E7%BF%85%E8%86%80/"/>
    <url>/2025/03/22/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E4%BB%8ECherry%20Studio%20%E5%85%A5%E9%97%A8%20MCP%EF%BC%8C%20%E4%B8%BA%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%8F%92%E4%B8%8A%E7%BF%85%E8%86%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>最近 MCP (Model Context Protocol) 概念大火，我也抽空学习了 MCP 的相关知识。今天，就让我们从 Cherry Studio 入手，快速了解并掌握 MCP 的基本用法。</p><h2 id="什么是-MCP？"><a href="#什么是-MCP？" class="headerlink" title="什么是 MCP？"></a>什么是 MCP？</h2><p>简单来说，MCP 是一种接口协议，它是连接 API 和大模型的桥梁。通过 MCP，我们可以调用和操作第三方工具，从而扩展大模型的能力边界。 MCP 让大模型不再局限于预训练的知识，而是能够实时地与外部世界互动。</p><h2 id="为什么选择-Cherry-Studio？"><a href="#为什么选择-Cherry-Studio？" class="headerlink" title="为什么选择 Cherry Studio？"></a>为什么选择 Cherry Studio？</h2><p>Cherry Studio 是一款功能全面的 AI 桌面客户端，凭借其友好的用户界面和易用性，深受用户喜爱。近期，Cherry Studio 已开始支持 MCP 服务。本文将以 Cherry Studio 官方文档中提供的 <code>fetch</code> 工具为例，帮助用户快速理解并上手 MCP。同时，我们将通过举一反三的方式，演示如何使用 <code>filesystem</code> 工具操作文件夹，实现通过对话控制桌面文件。通过这些示例，旨在帮助用户了解 MCP 强大的扩展性。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在开始之前，我们需要先安装以下工具：</p><ol><li><strong>uv</strong></li><li><strong>bun</strong></li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250322_143713.png" alt="mcp工具添加"></p><ul><li><strong>uv 是什么？</strong><br><code>uv</code> 是一个快速的 Python 包安装和依赖解析器。它可以显著提升 Python 项目的依赖管理速度。</li><li><strong>Bun 是什么？</strong><br><code>Bun</code> 是一个快速的全面的 JavaScript 工具包，可以用来进行 JavaScript 和 TypeScript 项目的打包、测试和运行。</li></ul><h2 id="配置-fetch-Server"><a href="#配置-fetch-Server" class="headerlink" title="配置 fetch Server"></a>配置 <code>fetch</code> Server</h2><p>为什么要选择 <code>fetch</code> 工具？因为它能够抓取网页信息，配置简单，方便我们理解 MCP 的配置和使用方法。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322160757718.png" alt="配置fetch"></p><p>配置方法如下：</p><ol><li><p>打开 Cherry Studio，进入设置界面。</p></li><li><p>找到 “MCP 服务器” 选项，点击 “添加服务器”。</p></li><li><p>填写 MCP Server 的相关参数（<a href="https://github.com/modelcontextprotocol/servers/tree/main/src/fetch">参考链接</a>）。</p><ul><li><strong>名称</strong>：自定义一个名称，例如 <code>fetch</code>。</li><li><strong>类型</strong>：选择 <code>STDIO</code>。</li><li><strong>命令</strong>：填写 <code>uvx</code>。</li><li><strong>参数</strong>：填写 <code>mcp-server-fetch</code>。</li></ul></li></ol><p><strong>这些参数代表什么？为什么要这样填写？</strong></p><ul><li><strong>STDIO（标准输入&#x2F;输出）</strong>：在本地运行，可访问本机文件和应用程序，但需要配置 Python 和 NodeJS 环境。</li><li><strong>SSE（服务器发送事件）</strong>：在远程服务器运行，配置简单，但无法访问本地资源。</li></ul><p>可以参考 <code>fetch</code> 工具在 GitHub 上的官方介绍。通过 <code>uvx</code> 安装的代码可以看到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;mcpServers&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;fetch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;command&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uvx&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;mcp-server-fetch&quot;</span><span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>Command</code> 对应命令，<code>args</code> 对应参数。对于公开的 MCP 工具，我们通常可以这样找到相应的设置方法，后面我还会介绍如何查找更多公开的 MCP 服务器。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>安装完服务器后，在对话界面点击启用 MCP 服务器。</li><li>选择支持 MCP 的模型（带有扳手 🔧 标志）。</li><li>就可以开始对话了！</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250322_161303.png" alt="使用mcp功能"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322161556959.png" alt="选择支持mcp的模型"></p><p><strong>对话效果：</strong></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322162135053.png" alt="对话效果"></p><p>经过测试，即使是硅基流动免费的 Qwen 2.5-7 B-Instruct 模型，也可以成功抓取对应的网页内容。</p><h2 id="filesystem-服务"><a href="#filesystem-服务" class="headerlink" title="filesystem 服务"></a><code>filesystem</code> 服务</h2><p>学会了 <code>fetch</code> 工具的添加方法，我们就可以举一反三，添加更多的 MCP 工具。例如，<code>filesystem</code> 工具可以帮助我们操作本地文件。</p><h3 id="filesystem-的主要功能"><a href="#filesystem-的主要功能" class="headerlink" title="filesystem 的主要功能"></a><code>filesystem</code> 的主要功能</h3><p><strong>Filesystem 的关键功能包括：</strong></p><ul><li><strong>读&#x2F;写文件和目录：</strong><ul><li>这意味着 Filesystem 允许用户读取文件的内容，以及将新的内容写入文件。</li></ul></li><li><strong>创建、列出、删除或移动目录：</strong><ul><li>用户可以使用 Filesystem 创建新的目录，查看现有目录的内容，删除不再需要的目录，以及将目录移动到新的位置。</li></ul></li><li><strong>使用模式匹配搜索文件：</strong><ul><li>Filesystem 允许用户使用通配符（例如，<code>*.txt</code>）来搜索符合特定模式的文件。这使得查找文件变得更加方便。</li></ul></li><li><strong>检索详细的文件元数据：</strong><ul><li>元数据指的是文件的属性，例如文件的大小、创建时间、修改时间等。Filesystem 可以提供这些详细的信息。</li></ul></li><li><strong>访问控制以限制对指定目录的操作：</strong><ul><li>这是 Filesystem 安全性的核心功能。通过配置文件，用户可以指定哪些目录是“允许的”，而哪些目录是“禁止的”。这可以防止未经授权的访问和操作。</li></ul></li></ul><h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><p>在 Cherry Studio 的 MCP 服务器设置中，搜索 <code>@modelcontextprotocol/server-filesystem</code>，然后在参数下面添加你打算操作的目录地址。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322164536953.png" alt="查找服务器"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322162933530.png" alt="filesystem"></p><h3 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h3><p>使用 <code>filesystem</code>，我们可以轻松地操作文件内容，例如新建文件夹、重命名文件夹等。再次提醒，简单的文件操作，免费的 7 B 模型也能做到。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322163835088.png" alt="效果"></p><p>提示词：写一首春天的诗歌， 利用filesystem在桌面（桌面路径C:\Users\chenw\Desktop）新建一个诗歌.txt， 将诗歌内容写入诗歌.txt中。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250322184317395.png" alt="新建文件"></p><p>注意：每次对话不一定达到想要的效果，需要不断对话调试，尽可能的给出规范的 prompt，才能减少幻觉。</p><h2 id="MCP-资源站"><a href="#MCP-资源站" class="headerlink" title="MCP 资源站"></a>MCP 资源站</h2><p>如何查找 MCP 服务？您可以通过以下网站找到公开的 MCP 工具。这些工具功能丰富，涵盖控制 Blender、Figma、浏览器以及数据库等多个方面。后续，我将根据个人使用体验，持续更新 MCP 相关内容。</p><ul><li>Sminthery : <a href="https://smithery.ai/">https://smithery.ai/</a></li><li>Pulse mcp : <a href="https://www.pulsemcp.com/">https://www.pulsemcp.com/</a></li><li>Awesome mcp servers : <a href="https://mcpservers.org/">https://mcpservers.org/</a></li><li>mcp.so : <a href="https://mcp.so/">https://mcp.so/</a></li><li>Galma.ai : <a href="https://glama.ai/mcp/servers">https://glama.ai/mcp/servers</a></li><li>Cursor.directory : <a href="https://cursor.directory/">https://cursor.directory/</a></li></ul><p>除了 Cherry studio 之外，还可以通过 Claude 客户端、Cursor、Cline 插件等工具调用 MCP 工具。您也可以在上述网站找到支持 MCP 的工具。从目前的趋势来看，将会有越来越多的平台支持 MCP，相信未来会更加便捷，例如直接调用大型模型对话完成 Word 文档的编写。相信这一天很快就会到来。如果您知道更多工具或更优秀的 MCP 服务器，欢迎在评论区留言，谢谢。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>MCP 协议就像为大模型添加了翅膀，让它们能够突破自身的限制，与外部世界进行互动。通过 Cherry Studio 这样易用的工具，我们可以轻松地为自己的大模型配置各种 MCP 服务，从而解锁更多可能性。如果您觉得有帮助，请点赞并关注。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li>Fetch GitHub:  <a href="https://github.com/modelcontextprotocol/servers/tree/main/src/fetch">https://github.com/modelcontextprotocol/servers/tree/main/src/fetch</a></li><li>filesystem Github:<a href="https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem">https://github.com/modelcontextprotocol/servers/tree/main/src/filesystem</a></li><li>Cherry Studio Docs: <a href="https://docs.cherry-ai.com/advanced-basic/mcp-1">https://docs.cherry-ai.com/advanced-basic/mcp-1</a></li><li>Model Context Protocol :<a href="https://modelcontextprotocol.io/">https://modelcontextprotocol.io/</a></li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>微信公众号：环境猫er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a> </p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>cherry_studio</tag>
      
      <tag>mcp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWebUI：一站式 AI 应用构建平台体验</title>
    <link href="/2025/03/16/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/OpenWebUI%EF%BC%9A%E4%B8%80%E7%AB%99%E5%BC%8F%20AI%20%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0%E4%BD%93%E9%AA%8C/"/>
    <url>/2025/03/16/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/OpenWebUI%EF%BC%9A%E4%B8%80%E7%AB%99%E5%BC%8F%20AI%20%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B9%B3%E5%8F%B0%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>🚀 大家好，今天给大家分享一个超棒的 AI 应用构建工具——OpenWebUI！体验下来，只能说<strong>丝滑</strong>！必须强烈推荐！</p><p>🔥 听说过阿里巴巴的 <a href="https://chat.qwen.ai/">Qwen</a> 吗？他们最新的 Qwen Chat 网站就是用 OpenWebUI 搭建的！足以见得这个工具的强大。在 GitHub 上已经狂揽 83.7 k Star，简直恐怖如斯！</p><p><strong>大家可以去体验一下：<a href="https://chat.qwen.ai/">https://chat.qwen.ai/</a></strong></p><h2 id="OpenWebUI-功能特点：All-in-One，应有尽有！"><a href="#OpenWebUI-功能特点：All-in-One，应有尽有！" class="headerlink" title="OpenWebUI 功能特点：All in One，应有尽有！"></a>OpenWebUI 功能特点：All in One，应有尽有！</h2><p>OpenWebUI 简直是为 AI 应用而生，功能丰富到令人发指：</p><ul><li><strong>⚡️ 极速部署：</strong><ul><li>Docker 一键安装，还支持 Ollama 和 CUDA 镜像，告别繁琐配置。</li><li>支持 pip 一键安装，0 代码构建 AI 应用</li></ul></li><li><strong>🤝 超强兼容：</strong><ul><li>完美兼容 Ollama 和 OpenAI API，轻松连接 LMStudio、GroqCloud、Mistral、OpenRouter 等等平台。</li></ul></li><li><strong>🛡️ 权限管理：</strong><ul><li>细粒度的用户角色和权限控制，安全可靠，还能定制个性化用户体验。</li></ul></li><li><strong>📱 响应式设计：</strong><ul><li>无论桌面、笔记本还是移动设备，都能流畅使用。</li></ul></li><li><strong>📲 移动端 PWA：</strong><ul><li>媲美原生 App 的移动端体验，甚至支持本地离线访问！</li></ul></li><li><strong>✍️ 富文本支持：</strong><ul><li>Markdown 和 LaTeX 全面支持，让交互更丰富。</li></ul></li><li><strong>🗣️ 语音&#x2F;视频通话：</strong><ul><li>集成免提语音和视频通话，沟通方式更多样。</li></ul></li><li><strong>🐍 Python 函数调用：</strong><ul><li>内置代码编辑器，支持 Python 函数调用，自由扩展功能。</li></ul></li><li><strong>📚 本地 RAG 集成：</strong><ul><li>支持检索增强生成 (RAG)，直接加载文档或使用文档库进行交互。</li></ul></li><li><strong>🌐 RAG 网络搜索：</strong><ul><li>集成 SearXNG、Google PSE、Brave Search、DuckDuckGo 等搜索引擎，实时获取最新信息。</li></ul></li><li><strong>🎨 图像生成：</strong><ul><li>支持 AUTOMATIC 1111 API、ComfyUI、OpenAI DALL-E 等图像生成 API，聊天中也能生成图像。</li></ul></li><li><strong>🤹 多模型对话：</strong><ul><li>同时使用多个模型，集各家之所长。</li></ul></li><li><strong>🔑 角色权限控制：</strong><ul><li>基于角色的访问控制 (RBAC)，确保安全访问。</li></ul></li><li><strong>多语言支持：</strong><ul><li>支持多语言，支持设置为中文。</li></ul></li><li><strong>🧩 插件支持：</strong><ul><li>Pipelines 插件框架，集成自定义逻辑和 Python 库。</li></ul></li></ul><h2 id="🛠️-Python-环境搭建"><a href="#🛠️-Python-环境搭建" class="headerlink" title="🛠️ Python 环境搭建"></a>🛠️ Python 环境搭建</h2><p>首先，我们需要搭建 Python 环境。这里推荐使用 VS Code，配合 conda 管理环境：</p><ol><li>打开 VS Code 命令面板 (Ctrl+Shift+P)。</li><li>选择 “Python: Select Interpreter”。</li><li>选择 “Create conda environment”。</li><li>选择 Python 3.11，点击 “Create”。</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">#也可用自带的环境工具创建<br><span class="hljs-keyword">python3</span>.<span class="hljs-number">11</span> --<span class="hljs-keyword">version</span><br><span class="hljs-keyword">python3</span>.<span class="hljs-number">11</span> -<span class="hljs-keyword">m</span> venv openwebui.env<br><span class="hljs-keyword">source</span> openwebui.env/bin/activate<br>pip install <span class="hljs-keyword">open</span>-webui<br><span class="hljs-keyword">open</span>-webui serve<br></code></pre></td></tr></table></figure><h3 id="安装-Open-WebUI"><a href="#安装-Open-WebUI" class="headerlink" title="安装 Open WebUI"></a>安装 Open WebUI</h3><p>接下来，使用 pip 安装 Open WebUI。<strong>注意：务必使用 Python 3.11，避免兼容性问题！</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>pip install open-webui<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果安装缓慢或失败，可以尝试指定版本：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pip install open-webui==0.2.0</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者更新 pip 后重试：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">pip install --upgrade open-webui</span><br></code></pre></td></tr></table></figure><p>安装完成后，运行以下命令启动 Open WebUI：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">open-webui serve<br></code></pre></td></tr></table></figure><p>第一次启动会比较慢，耐心等待资源加载完毕。然后在浏览器中打开 <code>http://localhost:8080/</code> 即可。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_160340.png" alt="OpenWebUI 登录界面"></p><p>首次登录需要注册账号，注册后即可登录。</p><h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><p>在 liunx 中使用宝塔和 docker可以快速搭建项目。<br>在 docker 中点击添加容器命令创建，<strong>只使用 OpenAI API</strong>，使用以下命令：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> -<span class="hljs-keyword">d</span> -p 3000:8080 -<span class="hljs-keyword">e</span> OPENAI_API_KEY=your_secret_key -v <span class="hljs-keyword">open</span>-webui:/<span class="hljs-keyword">app</span>/backend/data --name <span class="hljs-keyword">open</span>-webui --restart always ghcr.io/<span class="hljs-keyword">open</span>-webui/<span class="hljs-keyword">open</span>-webui:main<br>下载指定版本<br>docker <span class="hljs-keyword">run</span> -<span class="hljs-keyword">d</span> -p 3000:8080 -<span class="hljs-keyword">e</span> OPENAI_API_KEY=your_secret_key --add-host=host.docker.internal:host-gateway -v <span class="hljs-keyword">open</span>-webui:/<span class="hljs-keyword">app</span>/backend/data --name <span class="hljs-keyword">open</span>-webui --restart always ghcr.io/<span class="hljs-keyword">open</span>-webui/<span class="hljs-keyword">open</span>-webui:v0.5.19<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503191533495.png" alt="image.png"></p><blockquote><p>[!warning]</p></blockquote><p>若出现在本地部署 OpenWebUI 时无问题，但是在阿里云服务 docker部署，设置模型时始终出现 “OpenAI: Network Problem” 的网络连接问题，可能是防火墙的问题，关闭防火墙一切正常。</p><h2 id="⚙️-使用-OpenWebUI"><a href="#⚙️-使用-OpenWebUI" class="headerlink" title="⚙️ 使用 OpenWebUI"></a>⚙️ 使用 OpenWebUI</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>首次登录后，第一件事是添加模型。</p><ol><li>点击左下角或右上角头像，进入 “设置”。</li><li>在 “通用” 选项卡中，设置语言为中文。</li></ol><h3 id="外部链接设置"><a href="#外部链接设置" class="headerlink" title="外部链接设置"></a>外部链接设置</h3><p>OpenWebUI 支持连接各种外部模型 API，例如 Gemini、硅基流动等。</p><ol><li>点击 “+”，在 URL 中输入 API 的 base URL 和密钥。</li><li>点击 “保存”。如果不指定模型 ID，OpenWebUI 会自动检索可用模型。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_162644.png" alt="OpenWebUI 外部链接设置"></p><p>添加成功后，在对话界面左上角即可选择对应的模型。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_163157.png" alt="OpenWebUI 模型选择"></p><h3 id="配置-Gemini-模型"><a href="#配置-Gemini-模型" class="headerlink" title="配置 Gemini 模型"></a>配置 Gemini 模型</h3><p>以配置 Gemini 模型为例：</p><ol><li>进入 “设置” -&gt; “管理员设置” -&gt; “外部链接” -&gt; “添加模型”。</li><li>填写以下信息：<ul><li>URL: <code>https://generativelanguage.googleapis.com/v1beta</code></li><li>模型 ID: <code>gemini-2.0-flash</code></li></ul></li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_164302.png" alt="OpenWebUI Gemini 模型配置"></p><p>添加完成后，在模型对话界面就能看到 Gemini 模型了。你还可以在 “管理员面板” -&gt; “模型” 中管理模型，控制其是否显示。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_164656.png" alt="OpenWebUI 已添加的模型"></p><h2 id="💬-对话效果"><a href="#💬-对话效果" class="headerlink" title="💬 对话效果"></a>💬 对话效果</h2><p>上传一张图片，测试 Gemini 的理解能力：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_164931.png" alt="OpenWebUI 图片理解测试"></p><h2 id="🗂️-工作空间：模型、知识库、提示词、工具"><a href="#🗂️-工作空间：模型、知识库、提示词、工具" class="headerlink" title="🗂️ 工作空间：模型、知识库、提示词、工具"></a>🗂️ 工作空间：模型、知识库、提示词、工具</h2><p>OpenWebUI 的工作空间提供了强大的管理功能。</p><h3 id="模型管理"><a href="#模型管理" class="headerlink" title="模型管理"></a>模型管理</h3><p>在 “工作空间” -&gt; “模型” 界面，你可以添加、管理、微调模型，还可以添加知识库。</p><p>OpenWebUI 社区中有很多别人微调好的参数，可以导入学习。</p><h3 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h3><ol><li>点击 “工作空间” -&gt; “知识库”，进入知识库对话界面。</li><li>点击 “创建知识库”。OpenWebUI 自带向量模型，也可以自定义。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250316165435784.png" alt="OpenWebUI 创建知识库"></p><p>创建知识库后，拖动文件到上传区域，点击即可预览文件。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_165707.png" alt="OpenWebUI 知识库文件上传"></p><p>添加知识库后，在输入框中输入 <code>#</code>，即可加载需要的知识库内容。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_165854.png" alt="OpenWebUI 知识库调用"></p><p>例如，使用 Deepseek R 1 结合知识库进行提问：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_170242.png" alt="OpenWebUI 知识库问答"></p><p>如果觉得回答效果不佳，除了模型本身，还可能与知识库问答设置有关。可以在 “管理员设置” -&gt; “文档” 中自定义提示词。</p><h3 id="提示词"><a href="#提示词" class="headerlink" title="提示词"></a>提示词</h3><p>在 “工作空间” -&gt; “提示词管理” 中，可以进行提示词的设置、导入导出等操作。</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>可以导入导出各种工具，或者自己创建工具，类似于简单的 Agent。</p><p>OpenWebUI 社区中提供了丰富的模型、工具和提示词，可以导入学习。</p><h3 id="联网搜索功能"><a href="#联网搜索功能" class="headerlink" title="联网搜索功能"></a>联网搜索功能</h3><p>下面以联网搜索功能为例，介绍如何添加和使用工具：</p><ol><li>进入 “工作空间” -&gt; “工具” -&gt; “发现更多工具”。</li><li>网页跳转到 <code>https://openwebui.com/tools</code>。</li><li>找到 “Tools” 下面的联网搜索工具。</li><li>点击进入，选择 “Get”。</li><li>选择自己的网址，点击 “保存”。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_193807.png" alt="OpenWebUI 联网搜索工具"></p><p>保存后，你会在工具列表中看到该工具。但是，要正常使用，还需要修改搜索引擎。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250316193911064.png" alt="OpenWebUI 修改搜索引擎"></p><p>修改完成后，在对话框的 “+” 按钮上开启网页搜索功能，即可进行网页搜索。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_194023.png" alt="OpenWebUI 开启网页搜索"></p><h3 id="代码解释器"><a href="#代码解释器" class="headerlink" title="代码解释器"></a>代码解释器</h3><p>OpenWebUI 默认自带代码执行器。用 Gemini 生成一段简单的代码，点击运行，竟然成功了！</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_172824.png" alt="OpenWebUI 代码生成"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250316_172914.png" alt="OpenWebUI 代码执行"></p><p>从结果来看，效果还不错。虽然出现了中文不友好的问题，但可以通过继续提问来解决。</p><h2 id="📝-结语"><a href="#📝-结语" class="headerlink" title="📝 结语"></a>📝 结语</h2><p>这篇文章够长了，我从体验 OpenWebUI 搭建，到模型配置、知识库管理、提示词管理、工具管理，再到代码解释器等特殊功能，完整地展示了 OpenWebUI 的强大之处。它不仅易于上手，而且社区资源丰富，完全可以作为生产力工具来部署。</p><p>OpenWebUI 还在不断更新，本文介绍的功能可能并不全面。我会持续体验这款开源工具，并分享更多使用技巧。</p><p>如果觉得这篇文章对你有帮助，别忘了点赞、收藏加关注哦！</p><h2 id="🔗-相关网站"><a href="#🔗-相关网站" class="headerlink" title="🔗 相关网站"></a>🔗 相关网站</h2><ul><li><strong>OpenWebUI</strong><ul><li>官网：<a href="https://openwebui.com/">https://openwebui.com/</a></li><li>GitHub: <a href="https://github.com/open-webui/open-webui">https://github.com/open-webui/open-webui</a></li></ul></li><li><strong>Gemini</strong><ul><li>Gemini：<a href="https://gemini.google.com/">https://gemini.google.com/</a></li><li>Google AI Studio：<a href="https://aistudio.google.com/">https://aistudio.google.com/</a></li></ul></li><li><strong>Qwen</strong>：<a href="https://chat.qwen.ai/">https://chat.qwen.ai/</a></li><li>**mychat ** :  <a href="https://chat.wenmao.xyz/">https://chat.wenmao.xyz/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>openwebui</tag>
      
      <tag>知识库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian Copilot：打造你的专属 AI 笔记助手</title>
    <link href="/2025/03/12/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Obsidian%20Copilot%EF%BC%9A%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%20AI%20%E7%AC%94%E8%AE%B0%E5%8A%A9%E6%89%8B/"/>
    <url>/2025/03/12/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Obsidian%20Copilot%EF%BC%9A%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%20AI%20%E7%AC%94%E8%AE%B0%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Obsidian Copilot作为一款非常受欢迎的Obsidian插件，不仅极大地提升了用户的笔记管理和信息检索效率，还通过其多样化的AI功能为用户带来了前所未有的便捷体验。本文将详细介绍Obsidian Copilot的核心特点、使用方法及个人体验分享。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><p>Obsidian Copilot 集成了多项核心功能，使其成为强大的 AI 辅助工具：</p><ul><li><strong>多平台 API 支持</strong>：兼容 OpenAI、Anthropic、Cohere、Gemini、OpenRouter、Groq、Mistral 等主流 AI 平台。无论你是追求免费额度，还是需要更强大的性能，都能找到合适的选择。</li><li><strong>本地与云端无缝结合</strong>：同时支持本地模型（如 Ollama、LM Studio）和各种在线api，灵活性极高。无论你偏好离线工作，还是依赖云端算力，都能找到理想的解决方案。</li><li><strong>Vault QA 模式</strong>：基于 Obsidian 笔记库的智能问答功能，如同你的私人知识管家。它可以快速检索笔记内容、总结关键信息，显著提升笔记的利用率。</li><li><strong>自定义命令与提示</strong>：提供强大的自定义 Prompt 功能，允许你根据需求设计专属指令，例如一键翻译、生成摘要或输出特定风格的文本，实现个性化体验。</li><li><strong>界面友好且灵活</strong>：聊天窗口可嵌入编辑器或置于侧边栏，设计直观，支持长文本交互，方便你进行深入探讨或快速查询。</li><li><strong>与 Obsidian 深度融合</strong>：输出内容天然适配 Markdown 格式，与 Obsidian 的核心体验完美契合。大模型生成的内容无需转换，即可无缝融入你的笔记体系，无论是代码块、标题还是链接，都能完美呈现，提升写作与记录效率。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>打开 Obsidian 的设置。</li><li>进入“社区插件”市场。</li><li>搜索 “Copilot” 并安装。</li></ol><p>截至 2025 年 3 月 12 日，该插件下载量已超过 44 万，更新频繁，值得信赖。安装完成后，请务必在社区插件设置中启用它。</p><h2 id="对话界面"><a href="#对话界面" class="headerlink" title="对话界面"></a>对话界面</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503141239041.png" alt="Copilot 对话界面"></p><p>Copilot 的基础界面非常简洁，包括模型切换、对话模式切换、新建对话、最近笔记、默认提问等功能。所有设置都清晰直观，易于上手。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>Copilot 的设置界面分为基础、模型、QA（知识库管理）、提示词和高级五个部分，本文逐一进行介绍。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503141236165.png" alt="Copilot 设置界面"></p><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p>基础设置包括 API 管理、对话模型、文本嵌入模型、对话模式、插件显示位置等选项。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503141242508.png" alt="基础设置选项"></p><h4 id="API-管理"><a href="#API-管理" class="headerlink" title="API 管理"></a>API 管理</h4><p>Copilot 简化了 API 管理流程，支持 OpenAI、Anthropic、Cohere、Gemini、OpenRouter、Groq、Mistral 等平台的 API。只需输入相应的 API 密钥，即可调用这些平台的模型。每个模型下方都有获取api 的跳转链接，非常方便。作为白嫖用户，我个人推荐 Google 的 Gemini 和 Groq，它们提供免费额度。相比之下，ChatGPT 和 Anthropic 对中国大陆的限制较为严格，获取 API 密钥的难度较高。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121642698.png" alt="API 管理界面"></p><p><strong>Gemini API</strong>：下面的动图展示了 Gemini API 极快的响应速度，我并没有加速哦。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%BD%95%E5%B1%8F_20250315_090400.gif" alt="使用gemini api 进行对话"></p><blockquote><p>[!warning]</p></blockquote><p>Gemini 和 Groq 的 API 调用均需要科学上网，如果有难度可以在后文看到推荐的其他 api。<br><strong>插件显示位置</strong>：我选择将 Copilot 嵌入编辑器，而非侧边栏。因为 AI 的回答通常较长，嵌入编辑器更方便查看。</p><p><strong>文本嵌入模型</strong>：我选择了 Gemini 的 <code>text-embedding-004</code>。选定后，插件会将模型下载到本地，这可能需要一段时间（取决于你的网络速度）。嵌入模型用于 Vault QA 模式，使 Copilot 能够理解你的笔记内容。</p><h3 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h3><p>除了通过管理在线 API 获取模型外，Copilot 还允许你自定义添加模型。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121701708.png" alt="模型设置界面"></p><p>在模型添加处，你可以添加 OpenAI 格式的模型（如硅基流动），也可以添加 Ollama、LM Studio 等本地部署的模型。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121703127.png" alt="添加模型示例"></p><h4 id="硅基流动示例"><a href="#硅基流动示例" class="headerlink" title="硅基流动示例"></a>硅基流动示例</h4><p>以添加硅基流动模型为例，主要是为了在 Gemini 额度用完后，有一个免费的 DeepSeek 模型作为备用。</p><ul><li><strong>Model name</strong>：Pro&#x2F;deepseek-ai&#x2F;DeepSeek-R1</li><li><strong>Display name</strong>：DeepSeek-R1</li><li><strong>Provider</strong>：供应商，选择 “OpenAI Format”</li><li><strong>Base url</strong>：<code>https://api.siliconflow.cn/v1</code></li><li><strong>Api key</strong>：你的 API 密钥</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121708985.png" alt="硅基流动模型设置"></p><p><strong>Ps</strong>：硅基流动提供的免费 DeepSeek 模型速度较慢，远不如 Gemini-2.0-flash，仅作为备用。你可以根据自己的需求设置其他 API，例如火山引擎、百炼等模型，方法类似。<br>硅基流动目前正在进行推广活动。通过以下链接注册，你可以获得 2000 万 Tokens（价值 14 元平台配额）：</p><p>模型邀请链接：<a href="https://cloud.siliconflow.cn/i/p61lgKxB">https://cloud.siliconflow.cn/i/p61lgKxB</a><br>邀请码：<code>p61lgKxB</code></p><h4 id="火山引擎示例"><a href="#火山引擎示例" class="headerlink" title="火山引擎示例"></a>火山引擎示例</h4><ul><li><strong>Model name</strong>：<code>deepseek-v3-241226</code></li><li><strong>Display name</strong>：<code>deepseek-v3</code></li><li><strong>Provider</strong>：供应商，选择 “OpenAI Format”</li><li><strong>Base url</strong>：<code>https://ark.cn-beijing.volces.com/api/v3</code></li><li><strong>Api key</strong>：你的 API 密钥</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503141251030.png" alt="火山引擎模型设置"></p><p>火山引擎也提供了免费 Token，点击邀请链接即可参与：</p><p>参与入口：<a href="https://volcengine.com/L/ykJ1s4LMSD8/">https://volcengine.com/L/ykJ1s4LMSD8/</a><br>邀请码：<code>Y3GWJ762</code><br>经过测试，这几个模型的调用速度排序为：Gemini &gt; 火山引擎 &gt; 硅基流动。</p><h4 id="火山引擎-API-获取"><a href="#火山引擎-API-获取" class="headerlink" title="火山引擎 API 获取"></a>火山引擎 API 获取</h4><ol><li>登录 <a href="https://volcengine.com/L/ykJ1s4LMSD8">https://volcengine.com/L/ykJ1s4LMSD8</a>。</li><li>点击右上方的“API 接入”。</li><li>按照引导设置你想要接入的模型和 API。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250314_214516.png" alt="火山引擎 API 接入"></p><blockquote><p>[!note]</p></blockquote><p>欢迎大家使用我的网站：<a href="https://chat.wenmao.xyz/">https://chat.wenmao.xyz/</a><br>方便快捷的进入各大模型平台</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250315_092435.png" alt="局部截取_20250315_092435.png"></p><h3 id="提示词管理"><a href="#提示词管理" class="headerlink" title="提示词管理"></a>提示词管理</h3><p>在提示词设置界面，你可以选择所需的提示词。默认提示词包括修改语法、翻译、总结、简化、续写、生成表格等。你可以设置提示词调用的模型、修改提示词内容，并决定是否勾选。如果勾选，该提示词将出现在右键菜单中，方便你在任意文本中调用。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%B1%80%E9%83%A8%E6%88%AA%E5%8F%96_20250314_214937.png" alt="提示词设置界面"></p><p>以下是我设置的简单润色提示词：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">instruction</span>&gt;</span>请润色以下文本，使其更加专业和易于阅读，但不要改变其原意。请保留所有格式、特殊字符及原始信息，仅做必要的语法和拼写修正。<span class="hljs-tag">&lt;/<span class="hljs-name">instruction</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">text</span>&gt;</span></span><span class="hljs-template-variable">&#123;copilot-selection&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">text</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>**<code>&#123;copilot-selection&#125;</code>**：这是一个占位符，表示你选定的需要处理的文本部分。当你选择一段文本并触发该提示时，所选文本会自动替换这个占位符。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/20250314220538043.png" alt="润色提示词示例"></p><h3 id="Vault-QA-知识库管理"><a href="#Vault-QA-知识库管理" class="headerlink" title="Vault QA  知识库管理"></a>Vault QA  知识库管理</h3><p>Vault QA 是 Copilot 的核心功能之一。通过为你的 Obsidian 笔记库创建索引。Copilot 会根据笔记内容智能回答，非常适合管理和回顾大量笔记。索引生成后，插件会显示相关笔记的相似度排名，甚至包括链接和上下文信息。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/%E5%BD%95%E5%B1%8F_20250315_090832.gif" alt="知识库对话模式"></p><h3 id="高级设置"><a href="#高级设置" class="headerlink" title="高级设置"></a>高级设置</h3><p>高级设置包括系统提示词，api 加密，测试模式，一般用不到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细介绍了 Obsidian Copilot 插件的使用体验，重点突出了其核心特点、安装方法、界面功能、API 管理、模型设置以及提示词应用。希望通过本文，你能更全面地了解 Obsidian Copilot，并将其应用到你的笔记工作流中，提升效率，打造专属的 AI 知识库。<br>如果本文对你有帮助，请点赞、关注、评论转发哦~</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
      <tag>deepseek</tag>
      
      <tag>obsidian插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word 一键审稿 deepseek 公文审稿大师</title>
    <link href="/2025/03/12/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Word%20+%20deepseek%EF%BC%9A%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E6%96%87%E7%A8%BF%E5%AE%A1%E7%A8%BF%E5%8A%A9%E6%89%8B/"/>
    <url>/2025/03/12/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/Word%20+%20deepseek%EF%BC%9A%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E6%96%87%E7%A8%BF%E5%AE%A1%E7%A8%BF%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 前言<p>在工作中，文稿审核至关重要。然而，这项工作往往枯燥乏味，尤其对于像我这样粗心大意的人来说，常常因疏忽检查而导致错误。最近，我痛定思痛，决定借助 AI 成为我的审稿助手，并在之前 Word 接入 DeepSeek 代码的基础上，进一步开发，新增了以下功能：</p><ol><li>输出格式优化</li><li>审稿提示词优化</li><li>模型调用设置优化</li></ol><p>代码的亮点是无需复制粘贴，即可在 word 中快速解决文稿审查问题。</p><h2 id="输出格式优化"><a href="#输出格式优化" class="headerlink" title="输出格式优化"></a>输出格式优化</h2><p>我们对输出格式进行了自定义，采用了仿宋字体、小四字号和首行缩进的格式。同时，去除了默认 Markdown 格式中的 <code>#、*、-</code> 等符号，并替换了空格，以确保在 Word 中输出的友好性。</p><h2 id="提示词优化"><a href="#提示词优化" class="headerlink" title="提示词优化"></a>提示词优化</h2><p>根据我的审稿需求，我对提示词进行了调整，使其更符合实际工作场景。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">作为审稿专家，请按以下优先级审查文稿：<br><span class="hljs-bullet">1.</span> 基础错误排查：检查序号连贯性、错别字、数字逻辑矛盾；<br><span class="hljs-bullet">2.</span> 语言优化：修正语句不通顺、冗余表达，提升可读性；<br><span class="hljs-bullet">3.</span> 逻辑审查：验证段落过渡自然性，图表与文字一致性；<br><span class="hljs-bullet">4.</span> 内容评估：判断创新性与学术价值；<br>请按「问题-建议」格式逐条反馈，区分修改优先级，如果没有相关问题则跳过该条目。<br></code></pre></td></tr></table></figure><h2 id="模型调用设置优化"><a href="#模型调用设置优化" class="headerlink" title="模型调用设置优化"></a>模型调用设置优化</h2><p>将 apiurl、modelname 、apykey 作为变量，方便大家调试。</p><h2 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h2><p>以下是一段常见的函件示例。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121420236.png" alt="image.png"></p><p>在 Word 中选中该段文字，点击“审稿大师”，即可生成审稿意见。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121422335.png" alt="image.png"></p><h2 id="VBA-代码"><a href="#VBA-代码" class="headerlink" title="VBA 代码"></a>VBA 代码</h2><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> Perform()<br>    <span class="hljs-keyword">Dim</span> selectedText <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> apiKey <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> response <span class="hljs-keyword">As</span> <span class="hljs-type">Object</span><br>    <span class="hljs-keyword">Dim</span> re <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> midString <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> ans <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> polishPrompt <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> rng <span class="hljs-keyword">As</span> Range<br>    <span class="hljs-keyword">Dim</span> model_name <span class="hljs-keyword">As</span> <span class="hljs-type">String</span> <span class="hljs-comment">&#x27; 模型名称变量</span><br><br>    <span class="hljs-comment">&#x27; 检查是否有正常选择文本</span><br>    <span class="hljs-keyword">If</span> Selection.Type &lt;&gt; wdSelectionNormal <span class="hljs-keyword">Then</span> <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Sub</span><br><br>    <span class="hljs-comment">&#x27; 获取选中文本并保存范围</span><br>    <span class="hljs-keyword">Set</span> rng = Selection.Range<br>    selectedText = rng.<span class="hljs-keyword">text</span><br>    selectedText = Replace(selectedText, ChrW$(<span class="hljs-number">13</span>), <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">&#x27; 移除回车符</span><br><br>    <span class="hljs-comment">&#x27; API 配置</span><br>    apiKey = <span class="hljs-string">&quot;sk-wna&quot;</span><br>    <span class="hljs-keyword">Const</span> URL <span class="hljs-keyword">As</span> <span class="hljs-type">String</span> = <span class="hljs-string">&quot;https://api.siliconflow.cn/v1/chat/completions&quot;</span><br><br>    <span class="hljs-comment">&#x27; 修改后的提示词</span><br>    polishPrompt = <span class="hljs-string">&quot;作为审稿专家，请按以下优先级审查文稿并提供反馈：&quot;</span> &amp; _<br>                   <span class="hljs-string">&quot;1. 基础错误排查：检查序号连贯性、错别字；&quot;</span> &amp; _<br>                   <span class="hljs-string">&quot;2. 数字与数学逻辑审查：检查数字一致性、单位匹配、计算正确性、数学表达规范性；&quot;</span> &amp; _<br>                   <span class="hljs-string">&quot;3. 语言优化：修正语句不通顺、冗余表达，提升可读性；&quot;</span> &amp; _<br>                   <span class="hljs-string">&quot;4. 逻辑审查：验证段落过渡自然性，图表与文字一致性；&quot;</span> &amp; _<br>                   <span class="hljs-string">&quot;请按「问题-建议」格式逐条反馈，区分修改优先级，如果没有相关问题则跳过该条目。&quot;</span><br><br>    <span class="hljs-comment">&#x27; 设置模型名称</span><br>    model_name = <span class="hljs-string">&quot;Qwen/Qwen2.5-72B-Instruct-128K&quot;</span><br><br>    <span class="hljs-comment">&#x27; 发送 API 请求</span><br>    <span class="hljs-keyword">Set</span> response = CreateObject(<span class="hljs-string">&quot;MSXML2.XMLHTTP&quot;</span>)<br>    <span class="hljs-keyword">With</span> response<br>        .Open <span class="hljs-string">&quot;POST&quot;</span>, URL, <span class="hljs-literal">False</span><br>        .setRequestHeader <span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span><br>        .setRequestHeader <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> &amp; apiKey<br>        .Send <span class="hljs-string">&quot;&#123;&quot;&quot;model&quot;&quot;:&quot;&quot;&quot;</span> &amp; model_name &amp; <span class="hljs-string">&quot;&quot;&quot;, &quot;&quot;messages&quot;&quot;:[&#123;&quot;&quot;role&quot;&quot;:&quot;&quot;user&quot;&quot;,&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span> &amp; polishPrompt &amp; selectedText &amp; <span class="hljs-string">&quot;&quot;&quot;&#125;], &quot;&quot;temperature&quot;&quot;:0.7&#125;&quot;</span><br>        re = .responseText<br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br><br>    <span class="hljs-comment">&#x27; 解析响应</span><br>    midString = <span class="hljs-keyword">Mid</span>(re, InStr(re, <span class="hljs-string">&quot;&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span>) + <span class="hljs-number">11</span>)<br>    ans = Split(midString, <span class="hljs-string">&quot;&quot;&quot;&quot;</span>)(<span class="hljs-number">0</span>)<br>    ans = Replace(ans, <span class="hljs-string">&quot;\n&quot;</span>, vbNewLine) <span class="hljs-comment">&#x27; 将 \n 转换为实际换行</span><br><br>    <span class="hljs-comment">&#x27; 创建必要样式</span><br>    <span class="hljs-keyword">Call</span> CreateDocumentStyles<br><br>    <span class="hljs-comment">&#x27; 插入结果</span><br>    <span class="hljs-keyword">With</span> rng<br>        .Collapse wdCollapseEnd<br>        .InsertAfter vbNewLine &amp; vbNewLine<br><br>        <span class="hljs-keyword">Dim</span> outputRange <span class="hljs-keyword">As</span> Range<br>        <span class="hljs-keyword">Set</span> outputRange = .Duplicate<br><br>        <span class="hljs-comment">&#x27; 插入文本并清理格式</span><br>        outputRange.<span class="hljs-keyword">text</span> = ans<br>        <span class="hljs-keyword">Call</span> CleanTextFormatting(outputRange)<br><br>        <span class="hljs-comment">&#x27; 添加尾部换行符并定位光标</span><br>        outputRange.InsertAfter vbNewLine &amp; vbNewLine<br>        .<span class="hljs-keyword">End</span> = outputRange.<span class="hljs-keyword">End</span><br>        .<span class="hljs-keyword">Select</span><br>        Selection.Collapse wdCollapseEnd<br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br><br>    <span class="hljs-comment">&#x27; 清理</span><br>    <span class="hljs-keyword">Set</span> response = <span class="hljs-literal">Nothing</span><br>    <span class="hljs-keyword">Set</span> rng = <span class="hljs-literal">Nothing</span><br>    <span class="hljs-keyword">Set</span> outputRange = <span class="hljs-literal">Nothing</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br><br><span class="hljs-keyword">Private</span> <span class="hljs-keyword">Sub</span> CreateDocumentStyles()<br>    <span class="hljs-comment">&#x27; 只创建正文样式</span><br>    <span class="hljs-keyword">Dim</span> sty <span class="hljs-keyword">As</span> Style<br><br>    <span class="hljs-keyword">On</span> <span class="hljs-keyword">Error</span> <span class="hljs-keyword">Resume</span> <span class="hljs-keyword">Next</span><br>    <span class="hljs-keyword">Set</span> sty = ActiveDocument.Styles(<span class="hljs-string">&quot;BodyText&quot;</span>)<br>    <span class="hljs-keyword">If</span> sty <span class="hljs-built_in">Is</span> <span class="hljs-literal">Nothing</span> <span class="hljs-keyword">Then</span><br>        <span class="hljs-keyword">Set</span> sty = ActiveDocument.Styles.Add(<span class="hljs-string">&quot;BodyText&quot;</span>, wdStyleTypeParagraph)<br>        <span class="hljs-keyword">With</span> sty<br>            .Font.Name = <span class="hljs-string">&quot;仿宋&quot;</span><br>            .Font.Size = <span class="hljs-number">12</span> <span class="hljs-comment">&#x27; 小四</span><br>            .ParagraphFormat.FirstLineIndent = CentimetersToPoints(<span class="hljs-number">0.74</span>) <span class="hljs-comment">&#x27; 2字符</span><br>            .ParagraphFormat.LineSpacingRule = wdLineSpaceExactly<br>            .ParagraphFormat.LineSpacing = <span class="hljs-number">22</span> <span class="hljs-comment">&#x27; 行距22磅</span><br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br>    <span class="hljs-keyword">On</span> <span class="hljs-keyword">Error</span> <span class="hljs-keyword">GoTo</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br><br><span class="hljs-keyword">Private</span> <span class="hljs-keyword">Sub</span> CleanTextFormatting(rng <span class="hljs-keyword">As</span> Range)<br>    <span class="hljs-comment">&#x27; 清理文本中的无意义符号、删除空行并应用正文样式</span><br>    <span class="hljs-keyword">With</span> rng<br>        <span class="hljs-comment">&#x27; 移除 Markdown 符号</span><br>        .<span class="hljs-keyword">text</span> = Replace(.<span class="hljs-keyword">text</span>, <span class="hljs-string">&quot;**&quot;</span>, <span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">&#x27; 移除粗体标记</span><br>        .<span class="hljs-keyword">text</span> = Replace(.<span class="hljs-keyword">text</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">&#x27; 移除单个星号</span><br>        .<span class="hljs-keyword">text</span> = Replace(.<span class="hljs-keyword">text</span>, <span class="hljs-string">&quot;#&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">&#x27; 移除标题标记</span><br>        .<span class="hljs-keyword">text</span> = Replace(.<span class="hljs-keyword">text</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">&#x27; 移除-标记</span><br><br>        <span class="hljs-comment">&#x27; 移除无序列表符号和其他常见无意义符号</span><br>        <span class="hljs-keyword">With</span> .Find<br>            .ClearFormatting<br>            .<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p- &quot;</span>           <span class="hljs-comment">&#x27; 移除行首 &quot;- &quot;</span><br>            .Replacement.<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p&quot;</span><br>            .Execute Replace:=wdReplaceAll<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>        <span class="hljs-keyword">With</span> .Find<br>            .ClearFormatting<br>            .<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p-&quot;</span>            <span class="hljs-comment">&#x27; 移除行首单独 &quot;-&quot;</span><br>            .Replacement.<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p&quot;</span><br>            .Execute Replace:=wdReplaceAll<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>        <span class="hljs-keyword">With</span> .Find<br>            .ClearFormatting<br>            .<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p&gt; &quot;</span>           <span class="hljs-comment">&#x27; 移除引用符号 &quot;&gt; &quot;</span><br>            .Replacement.<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p&quot;</span><br>            .Execute Replace:=wdReplaceAll<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>        <br>        <span class="hljs-comment">&#x27; 删除空行</span><br>        <span class="hljs-keyword">With</span> .Find<br>            .ClearFormatting<br>            .<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p^p&quot;</span>           <span class="hljs-comment">&#x27; 连续两个段落标记</span><br>            .Replacement.<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p&quot;</span> <span class="hljs-comment">&#x27; 替换为单个段落标记</span><br>            .Execute Replace:=wdReplaceAll<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>        <span class="hljs-keyword">With</span> .Find<br>            .ClearFormatting<br>            .<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p[ ^t]^p&quot;</span>      <span class="hljs-comment">&#x27; 删除只包含空格或制表符的空行</span><br>            .Replacement.<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p&quot;</span><br>            .Execute Replace:=wdReplaceAll<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br>        <span class="hljs-keyword">With</span> .Find<br>            .ClearFormatting<br>            .<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;^p$&quot;</span>            <span class="hljs-comment">&#x27; 删除段落末尾的空行</span><br>            .Replacement.<span class="hljs-keyword">text</span> = <span class="hljs-string">&quot;&quot;</span><br>            .Execute Replace:=wdReplaceAll<br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br><br>        <span class="hljs-comment">&#x27; 应用统一的正文样式</span><br>        .<span class="hljs-keyword">text</span> = Replace(.<span class="hljs-keyword">text</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;&quot;</span>)   <span class="hljs-comment">&#x27; 移除空格</span><br>        .Style = <span class="hljs-string">&quot;BodyText&quot;</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br><br><br></code></pre></td></tr></table></figure><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><p>这段 VBA 代码是一个用于 Word 文档的宏，其主要作用是：</p><ol><li><strong>获取选中文本：</strong> 从 Word 文档中获取用户选中的文本内容。</li><li><strong>调用 AI 润色接口：</strong> 将选中的文本发送到指定的 AI 接口（硅 flow），并附带一个润色提示词，要求 AI 对文本进行润色和审查。</li><li><strong>处理 AI 响应：</strong> 接收 AI 返回的润色结果，并对结果进行简单的格式处理。</li><li><strong>将润色结果插入文档：</strong> 将处理后的润色结果插入到 Word 文档中，位于原始选中文本的下方，并应用指定的正文样式。</li></ol><p>下面是代码的详细解析和调试内容：</p><p><strong>代码解析：</strong></p><ul><li><strong><code>Sub Perform()</code>：</strong> 主过程，当宏运行时，从这里开始执行。</li><li><strong>变量声明：</strong><ul><li><code>selectedText As String</code>: 用于存储选中的文本。</li><li><code>apiKey As String</code>: 用于存储 API 密钥。</li><li><code>response As Object</code>: 用于存储 HTTP 请求的响应。</li><li><code>re As String</code>: 用于存储完整的 API 响应文本。</li><li><code>midString As String</code>: 用于存储从 API 响应中提取的内容部分。</li><li><code>ans As String</code>: 用于存储最终的润色结果。</li><li><code>polishPrompt As String</code>: 用于存储发送给 AI 的润色提示词。</li><li><code>rng As Range</code>: 用于存储选中文本的范围。</li><li><code>model_name As String</code> 变量，存储调用模型名称</li></ul></li><li><strong>检查选中文本：</strong><ul><li><code>If Selection.Type &lt;&gt; wdSelectionNormal Then Exit Sub</code>: 确保用户选择了正常的文本范围。如果没有选择文本，则退出宏。</li></ul></li><li><strong>获取选中文本并移除回车符：</strong><ul><li><code>Set rng = Selection.Range</code>: 获取选中文本的范围。</li><li><code>selectedText = rng.text</code>: 获取选中文本的内容。</li><li><code>selectedText = Replace(selectedText, ChrW$(13), &quot;&quot;)</code>: 移除选中文本中的回车符。</li></ul></li><li><strong>API 配置：</strong><ul><li><code>apiKey = &quot;sk-rvv&quot;</code>:  <strong>重要：</strong> 这里需要替换成你自己的 API 密钥。</li><li><code>Const URL As String = &quot;https://api.siliconflow.cn/v1/chat/completions&quot;</code>: 定义 API 的 URL。</li></ul></li><li><strong>设置润色提示词：</strong><ul><li><code>polishPrompt = ...</code>: 定义发送给 AI 的提示词，指示 AI 作为审稿专家，按照一定的优先级对文本进行审查和润色。</li></ul></li><li><strong>发送 API 请求：</strong><ul><li><code>Set response = CreateObject(&quot;MSXML2.XMLHTTP&quot;)</code>: 创建一个 XMLHTTP 对象，用于发送 HTTP 请求。</li><li><code>With response ... End With</code>: 使用 <code>With</code> 语句简化代码，设置 HTTP 请求的各种属性。<ul><li><code>.Open &quot;POST&quot;, URL, False</code>:  以 POST 方式打开连接到指定的 URL。<code>False</code> 表示同步请求。</li><li><code>.setRequestHeader &quot;Content-Type&quot;, &quot;application/json&quot;</code>: 设置请求头，指定内容类型为 JSON。</li><li><code>.setRequestHeader &quot;Authorization&quot;, &quot;Bearer &quot; &amp; apiKey</code>: 设置请求头，添加授权信息，使用 Bearer 令牌认证。</li><li><code>.Send &quot;&#123;&quot;&quot;model&quot;&quot;:&quot;&quot;&quot; &amp; model_name &amp; &quot;&quot;&quot;, &quot;&quot;messages&quot;&quot;:[&#123;&quot;&quot;role&quot;&quot;:&quot;&quot;user&quot;&quot;,&quot;&quot;content&quot;&quot;:&quot;&quot;&quot; &amp; polishPrompt &amp; selectedText &amp; &quot;&quot;&quot;&#125;], &quot;&quot;temperature&quot;&quot;:0.7&#125;&quot;</code>: 发送 JSON 格式的请求体，包含模型名称、用户角色和内容（提示词 + 选中文本）。<code>temperature</code> 参数控制生成文本的随机性。</li><li><code>re = .responseText</code>: 获取 API 的响应文本。</li></ul></li></ul></li><li><strong>解析响应：</strong><ul><li><code>midString = Mid(re, InStr(re, &quot;&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;) + 11)</code>: 从响应文本中提取 <code>content</code> 字段的值。</li><li><code>ans = Split(midString, &quot;&quot;&quot;&quot;)(0)</code>:  将提取的字符串按 <code>&quot;</code> 分割，取第一个元素，得到最终的润色结果。</li><li><code>ans = Replace(ans, &quot;\n&quot;, vbNewLine)</code>: 将结果中的 <code>\n</code> 替换为 VBA 的换行符 <code>vbNewLine</code>。</li></ul></li><li><strong>创建必要样式：</strong><ul><li><code>Call CreateDocumentStyles</code>: 调用 <code>CreateDocumentStyles</code> 子过程，创建或获取名为 “BodyText” 的样式。</li></ul></li><li><strong>插入结果：</strong><ul><li><code>With rng ... End With</code>: 使用 <code>With</code> 语句简化代码，对选中文本的范围进行操作。<ul><li><code>.Collapse wdCollapseEnd</code>: 将范围折叠到选中文本的末尾。</li><li><code>.InsertAfter vbNewLine &amp; vbNewLine</code>: 在选中文本后插入两个换行符。</li><li><code>Set outputRange = .Duplicate</code>: 创建一个与原始范围相同的副本，用于插入润色结果。</li><li><code>outputRange.text = ans</code>: 将润色结果插入到 <code>outputRange</code> 中。</li><li><code>Call CleanTextFormatting(outputRange)</code>: 调用 <code>CleanTextFormatting</code> 子过程，清理文本格式并应用正文样式。</li><li><code>outputRange.InsertAfter vbNewLine &amp; vbNewLine</code>: 在润色结果后插入两个换行符。</li><li><code>.End = outputRange.End</code>: 更新原始范围的结束位置。</li><li><code>.Select</code>: 选中更新后的范围。</li><li><code>Selection.Collapse wdCollapseEnd</code>: 将光标移动到选中文本的末尾。</li></ul></li></ul></li><li><strong>清理：</strong><ul><li><code>Set response = Nothing</code>: 释放对象变量，防止内存泄漏。</li><li><code>Set rng = Nothing</code></li><li><code>Set outputRange = Nothing</code></li></ul></li><li><strong><code>Private Sub CreateDocumentStyles()</code>：</strong>  创建或获取名为 “BodyText” 的样式。如果样式不存在，则创建一个新的样式，并设置字体、字号、缩进和行距。</li><li><strong><code>Private Sub CleanTextFormatting(rng As Range)</code>：</strong>  清理文本格式并应用正文样式。<ul><li>移除 Markdown 符号（<code>**</code>, <code>*</code>, <code>#</code>, <code>-</code>）。</li><li>移除无序列表符号和其他常见无意义符号（如行首的 <code>- </code>、<code>-</code>、<code>&gt; </code>）。</li><li>移除空格</li><li>应用 “BodyText” 样式。</li></ul></li></ul><p><strong>可调试内容：</strong></p><ol><li><strong>API 密钥：</strong> 确保将 <code>apiKey = &quot;sk-rvv&quot;</code> 替换为你自己的有效 API 密钥。这是代码能够正常运行的关键。</li><li><strong>API Endpoint:</strong> 确认 <code>Const URL As String = &quot;https://api.siliconflow.cn/v1/chat/completions&quot;</code> 这个 API 是硅基流动的 api ，根据自己的情况选择 api 接口</li><li><code>model_name</code> 用的 <code>Qwen/Qwen2.5-7B-Instruct</code>，可以更换为 <code>Pro/deepseek-ai/DeepSeek-V3</code>，<code>Pro/deepseek-ai/DeepSeek-R1</code> 等收费模型，不过需要等待的时间更长，且 R 1 模型可能存在更多幻觉。</li><li><strong>Prompt 优化:</strong> 根据实际润色效果，可优化 <code>polishPrompt</code>，以获得更好的结果。</li></ol><h2 id="代码使用方法"><a href="#代码使用方法" class="headerlink" title="代码使用方法"></a>代码使用方法</h2><p>宏的使用有很多方法，快捷键、放在功能区都行，这里以自定义功能区简单介绍。</p><h3 id="添加开发工具"><a href="#添加开发工具" class="headerlink" title="添加开发工具"></a>添加开发工具</h3><ol><li>选项-信任中心-宏设置-启用所有宏-信任 vba</li><li>开启开发工具, 选项-自定义选项卡-勾选开发工具。</li><li>Word 工具栏点击“开发工具”选项卡。</li><li>点击“Visual Basic”。</li><li>右键当前文稿下的“模块”，选择“插入模块”。</li><li>复制上述代码到新建的模块中，或者右键模块-导入 bas 文件。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503121450670.png" alt="image.png"></p><h3 id="自定义功能区调用宏"><a href="#自定义功能区调用宏" class="headerlink" title="自定义功能区调用宏"></a>自定义功能区调用宏</h3><p>宏有多中调用方式，这里介绍选项卡调用。</p><ol><li>点击“文件”-&gt;“选项”-&gt;“自定义功能区”。</li><li>选择“宏”，在右侧自定义功能区新建选项卡和组。</li><li>将宏添加至组中，重命名并更换图标。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502020918275.png" alt="image.png"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>需要替换自己的 API 密钥。</li><li>不建议用推理模型，文稿审核相对比较简单，用推理模型反而慢了，容易卡顿。</li><li>可以根据自己的需要修改提示词。</li><li>运行转圈是正常的，需要等待结果生成。</li></ol><p>希望这次润色能够帮助您更好地呈现您的工作成果。如果您有任何其他问题或需要进一步的修改，请随时告诉我。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>办公技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2025年主流知识库对话应用开源工具盘点</title>
    <link href="/2025/03/06/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/2025%E5%B9%B4%E4%B8%BB%E6%B5%81%E5%BC%80%E6%BA%90%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AF%B9%E8%AF%9D%E5%B7%A5%E5%85%B7%E7%9B%98%E7%82%B9/"/>
    <url>/2025/03/06/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/2025%E5%B9%B4%E4%B8%BB%E6%B5%81%E5%BC%80%E6%BA%90%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AF%B9%E8%AF%9D%E5%B7%A5%E5%85%B7%E7%9B%98%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>最近一直在思考 <strong>DeepSeek</strong> 的应用场景，而知识库的搭建无疑是其中至关重要的一环。在当今的大模型时代，本地化与个性化的知识库已成为增强检索（RAG, Retrieval Augmented Generation）技术的最大应用场景之一，同时也是各个行业定制化模型不可或缺的一部分。随着开源大模型的易用性不断提升，越来越多的人希望拥有属于自己的知识库问答工具，以满足个性化需求。</p><p>目前市面上涌现了大量知识库对话应用，这也从侧面反映了用户对这一领域的强烈需求。我们每个人都希望能够站在巨人的肩膀上，利用现有的成熟工具来实现目标，而不是从零开始“造轮子”。</p><p>今天，我将对比几款主流的知识库搭建框架，希望能为大家提供一些参考。这些工具：</p><ul><li><strong>Anything LLM</strong></li><li><strong>LangChain-Chatchat</strong></li><li><strong>Dify</strong></li><li><strong>MaxKB</strong></li><li><strong>RAGflow</strong></li><li><strong>FastGPT</strong></li><li><strong>Cherry Studio</strong></li></ul><p>AI 技术日新月异，知识库搭建领域也在飞速发展。如果你有其他喜欢的工具或框架，欢迎在评论区留言推荐！让我们一起探索更高效、更智能的知识管理方式。</p><h2 id="工具盘点"><a href="#工具盘点" class="headerlink" title="工具盘点"></a>工具盘点</h2><h3 id="1-Anything-LLM"><a href="#1-Anything-LLM" class="headerlink" title="1. Anything LLM"></a>1. <strong>Anything LLM</strong></h3><ul><li>网址： <a href="https://anythingllm.com/">https://anythingllm.com/</a></li><li>Github stars : 39.6 k</li><li><strong>核心优势</strong>：<br>✅ 有客户端应用，学习成本低<br>✅ 兼容多种 LLM（HuggingFace&#x2F;OpenAI&#x2F;Ollama 等）<br>❌ 社区支持相对薄弱（GitHub Issues 响应较慢）</li><li><strong>部署成本</strong>：支持 docker 和客户端部署，硬件需求中等</li><li><strong>学习难度</strong>：★★☆（需理解 LLM 配置与向量化原理）</li><li><strong>应用场景</strong>：企业级文档智能客服、多团队协作知识管理</li><li></li></ul><h3 id="2-LangChain-Chatchat"><a href="#2-LangChain-Chatchat" class="headerlink" title="2. LangChain-Chatchat"></a>2. <strong>LangChain-Chatchat</strong></h3><ul><li>网址： <a href="https://github.com/chatchat-space/Langchain-Chatchat">https://github.com/chatchat-space/Langchain-Chatchat</a></li><li>Github stars : 33.8 k</li><li><strong>核心优势</strong>：<br>✅ 中文场景支持最佳（专为中文优化）<br>✅ 模块化架构便于二次开发<br>✅ 前端使用 streamlit 开发，界面简单<br>✅ 支持混合部署（本地模型+云端 API）<br>❌ 文档更新滞后于代码迭代（近 4 个月未更新）</li><li><strong>部署成本</strong>：仅支持 Python 3.8-3.11 环境</li><li><strong>学习难度</strong>：★★★★☆（需掌握 LangChain 框架）</li><li><strong>应用场景</strong>：技术团队主导的定制化问答系统</li></ul><h3 id="3-Dify"><a href="#3-Dify" class="headerlink" title="3. Dify"></a>3. <strong>Dify</strong></h3><ul><li>网址： <a href="https://dify.ai/zh">https://dify.ai/zh</a></li><li>Github stars : 76.3 k</li><li><strong>核心优势</strong>：<br>✅ 可视化 AI 工作流编排（拖拽式设计）<br>✅ 内置模型监控与日志分析<br>✅ 支持多租户 SaaS 化部署<br>❌ 定制化能力受平台限制</li><li><strong>部署成本</strong>：支持 docker 部署，部署有一定难度，对服务器硬件要求高</li><li><strong>学习难度</strong>：★★★☆（面向无代码开发者友好）</li><li><strong>应用场景</strong>：生成式 AI 应用创新引擎，开源的 LLM 应用开发平台。提供从 Agent 构建到 AI workflow 编排、RAG 检索、模型管理等能力，轻松构建和运营生成式 AI 原生应用。</li></ul><h3 id="4-MaxKB"><a href="#4-MaxKB" class="headerlink" title="4. MaxKB"></a>4. <strong>MaxKB</strong></h3><ul><li>网址： <a href="https://github.com/1panel-dev/MaxKB">https://github.com/1panel-dev/MaxKB</a></li><li>Github stars : 14 k</li><li><strong>核心优势</strong>：<br>✅ 飞致云旗下，开箱即用，直接使用 1 pannel 部署<br>✅ 支持自动网页爬取与文档解析<br>❌ 仅提供基础 RAG 功能</li><li><strong>部署成本</strong>：最低（2 GB 内存可运行）</li><li><strong>学习难度</strong>：★☆（适合非技术人员）</li><li><strong>应用场景</strong>：中小企业内部知识库快速搭建</li></ul><h3 id="5-RAGFlow"><a href="#5-RAGFlow" class="headerlink" title="5. RAGFlow"></a>5. <strong>RAGFlow</strong></h3><ul><li>网址：<a href="https://ragflow.io/">https://ragflow.io/</a></li><li>Github stars : 41.9 k</li><li><strong>核心优势</strong>：<br>✅ 基于深度文档理解（支持表格&#x2F;公式提取）<br>✅ 提供引用溯源与置信度评估<br>✅ 支持 docker 部署<br>❌ 硬件需求高（推荐 GPU 加速）</li><li><strong>部署成本</strong>：最高（需专用推理服务器）<ul><li>CPU ≥ 4 cores (x 86)</li><li>RAM ≥ 16 GB</li><li>Disk ≥ 50 GB</li><li>Docker ≥ 24.0.0 &amp; Docker Compose ≥ v 2.26.1.</li></ul></li><li><strong>学习难度</strong>：★★★★（需配置文档解析流水线）</li><li><strong>应用场景</strong>：一款基于深度文档理解构建的开源 RAG 引擎</li></ul><h3 id="6-FastGPT"><a href="#6-FastGPT" class="headerlink" title="6. FastGPT"></a>6. <strong>FastGPT</strong></h3><ul><li>网址： <a href="https://fastgpt.cn/zh">https://fastgpt.cn/zh</a></li><li>Github stars : 22.1 k</li><li><strong>核心优势</strong>：<br>✅ 可视化工作流设计（Flow 模块）<br>✅ 支持多模态输入（图像&#x2F;文本混合处理）<br>❌ 社区案例较少</li><li><strong>部署成本</strong>：中等（推荐 4 核 8 G 配置）</li><li><strong>学习难度</strong>：★★☆（需理解数据处理流程）</li><li><strong>应用场景</strong>：基于 LLM 大模型的开源 AI 知识库构建平台。提供了开箱即用的数据处理、模型调用、RAG 检索、可视化 AI 工作流编排等能力，帮助您轻松构建复杂的 AI 应用。</li></ul><h3 id="7-cherry-studio"><a href="#7-cherry-studio" class="headerlink" title="7. cherry studio"></a>7. <strong>cherry studio</strong></h3><ul><li>网址： <a href="https://cherry-ai.com/">https://cherry-ai.com/</a></li><li>Github stars : 17.6 k</li><li><strong>核心优势</strong>：<br>✅ 可视化工作流设计（Flow 模块）<br>✅ 支持多模态输入（图像&#x2F;文本混合处理）<br>❌ 社区案例较少</li><li><strong>部署成本</strong>：低，客户端运行</li><li><strong>学习难度</strong>：★★☆（需理解数据处理流程）</li><li><strong>应用场景</strong>：跨模态知识检索系统</li><li>使用感受：国人开发的知识库软件，集合了多个服务商，文档比较清晰，操作简单，可作为知识库入门。</li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>知识库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动发布AI编程工具Trae</title>
    <link href="/2025/03/06/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8AI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7Trae%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2025/03/06/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8AI%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7Trae%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>字节跳动近日发布了其首款国产AI编程工具——Trae，直接对标Cursor。初步体验感觉非常棒。Trae集成了Claude 3.7 Sonnet引擎，展现了强大的AI能力，无论是代码自动补全、智能问答还是多模态输入编程等功能，都表现得非常出色，而且目前所有AI编程功能均可免费使用，简直不要太香。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>登录Trae 官网下载使用。<br><a href="https://www.trae.ai/">https://www.trae.ai/</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503061647574.png" alt="官网界面"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>安装后支持导入 cursor，vscode 设置及插件，界面和 vscode 很像，更简洁，设置也比较少。熟悉 vscode 的朋友可以轻松上手。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>虽然 Trae 有插件市场，但有的插件（比如 cline、 Continue）并没有上架，好在支持 open-vsx 插件源，可以手动安装。<br>手动安装方法就是下载.vsix 格式的文件，拖拽到插件市场面板中即可。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503070913275.png" alt="插件市场"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503070914739.png" alt="搜索插件"></p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p>项目管理和 vscode 一样，支持本地文件夹创建项目，还支持从 github 中直接 clone 项目。</p><h2 id="AI-编程能力"><a href="#AI-编程能力" class="headerlink" title="AI 编程能力"></a>AI 编程能力</h2><p>AI 编程能是是最核心的，目前所有的 AI 功能都是免费的。</p><p>Trae 支持代码自动补全、智能问答、代码生成、项目开发，多模态输入编程等。</p><ol><li>编辑代码时候，可以根据上下文自动补全，给出代码提示。</li><li>在中间的代码编辑框使用 CRTL + I 调出对话页面。</li><li>在侧边栏chat 页面对话，对话框输入 “#”号可以选择引用文件、文件夹、代码、工作项目等联系上下文。</li><li>在侧边栏Builder 页面可实现从 0 到 1 构建项目。</li><li>在 chat 页面可以输入图片比如一个设计原型，可以识别并创建想要的 UI 界面。</li></ol><h2 id="体验感受"><a href="#体验感受" class="headerlink" title="体验感受"></a>体验感受</h2><p>经过一天的初步体验，觉得非常不错，我在使用他进行数据分析时，只需要给他数据源，然后对话就好了，可以<strong>全程不敲一段代码，直接生成我想要的效果</strong>，极大的提高了工作效率。</p><p>不得不赞叹国内AI技术发展的速度之快，之前都是用 pycharm、vscode、cursor 这些产品，如今Trae 的出现真的是一个很好的开始，希望越来越多国产 AI工具出现。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503070918757.png" alt="image.png"></p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="https://www.trae.ai/">https://www.trae.ai/</a></li><li><a href="https://docs.trae.ai/docs">https://docs.trae.ai/docs</a></li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如有帮助，请收藏点赞~<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《围城》：初读不接书中意，再读已是书中人</title>
    <link href="/2025/03/05/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%9B%B4%E5%9F%8E%E3%80%8B%EF%BC%9A%E5%88%9D%E8%AF%BB%E4%B8%8D%E6%8E%A5%E4%B9%A6%E4%B8%AD%E6%84%8F%EF%BC%8C%E5%86%8D%E8%AF%BB%E5%B7%B2%E6%98%AF%E4%B9%A6%E4%B8%AD%E4%BA%BA/"/>
    <url>/2025/03/05/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%9B%B4%E5%9F%8E%E3%80%8B%EF%BC%9A%E5%88%9D%E8%AF%BB%E4%B8%8D%E6%8E%A5%E4%B9%A6%E4%B8%AD%E6%84%8F%EF%BC%8C%E5%86%8D%E8%AF%BB%E5%B7%B2%E6%98%AF%E4%B9%A6%E4%B8%AD%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 围城</p><ul><li><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/457/22946457/t7_22946457.jpg" alt=" 围城|200"></li><li>书名： 围城</li><li>作者： 钱钟书</li><li>简介： 钱钟书先生最经典的作品，也是仅有的一部长篇小说，堪称中国现代文学史上风格独特的讽刺经典，被誉为“新儒林外史”，自上世纪八十年代以来一直横贯常销、畅销小说之首。小说塑造了抗战初期以方鸿渐为主的一类知识分子群像，记叙了他们所面临的教育、婚姻和事业困境。虽然有具体的历史背景，但这部小说揭示的人群的弱点，在今天依然能引起人们的共鸣。著名文学评论家夏志清先生在《中国现代小说史》中认为，“《围城》比任何中国古典讽刺小说优秀”，称之为“中国现代文学史中写得最有趣、最细腻的小说，或许是最伟大的小说。”</li><li>出版时间： 2017-07-01 00:00:00</li><li>ISBN： 9787020127894</li><li>分类： 文学-经典作品</li><li>出版社： 人民文学出版社</li><li>PC 地址：<a href="https://weread.qq.com/web/reader/54c32520715e229954c8b8a">https://weread.qq.com/web/reader/54c32520715e229954c8b8a</a></li></ul></blockquote><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>初读钱钟书先生的《围城》时，还是在中学，只记得方鸿渐不是个好人，还有那句脍炙人口的名言：“城外的人想冲进去，城里的人想逃出来。”今年突然想起书中有人使用了卡片笔记法记录资料，加上最近书荒，就找来看看。<br>一看就入迷了，《围城》是钱钟书唯一的长篇小说，从书中看出作者阅历之丰富，洞察人心，他描述的人和事仿佛就在眼前，其实书中远不止围城这一处比喻，还有很多特别的比喻，让人拍案叫绝。</p><h2 id="情节概述与阶段分析"><a href="#情节概述与阶段分析" class="headerlink" title="情节概述与阶段分析"></a>情节概述与阶段分析</h2><p>《围城》的故事结构清晰，可分为五个阶段，每一阶段都展现了方鸿渐在不同环境下的成长与困境。</p><h3 id="留学归来：假文凭与初恋的幻灭"><a href="#留学归来：假文凭与初恋的幻灭" class="headerlink" title="留学归来：假文凭与初恋的幻灭"></a>留学归来：假文凭与初恋的幻灭</h3><p>方鸿渐在欧洲留学期间并未认真学习，而是辗转于多所大学之间。为了给家人一个交代，他在毕业前购买了一个虚构的“克莱登大学”的博士学位证书，并随其他留学生一同回国，在船上遇到以前的同学苏文纨，回到上海后，方鸿渐在未婚妻周淑英的父亲开设的银行工作，但由于种种原因，他与苏文纨的感情也未能持续，最终与唐晓芙相恋，但这段感情也因误会而结束。</p><h3 id="上海工作：职场困境与感情波折"><a href="#上海工作：职场困境与感情波折" class="headerlink" title="上海工作：职场困境与感情波折"></a>上海工作：职场困境与感情波折</h3><p>回到上海，方鸿渐在未婚妻周淑英父亲开设的银行工作，但因性格软弱和不谙世事，很快与上司发生冲突，丢了工作。此阶段，他尝试与苏文纨续情，却因误会无果，随后与唐晓芙相恋，但这段感情也因沟通问题而破裂。钱钟书通过这些情节，讽刺了职场的人际复杂性和恋爱中的沟通障碍。</p><h3 id="前往三闾大学：旅途中的性格揭示"><a href="#前往三闾大学：旅途中的性格揭示" class="headerlink" title="前往三闾大学：旅途中的性格揭示"></a>前往三闾大学：旅途中的性格揭示</h3><p>因职业发展受阻，方鸿渐接受赵辛楣建议，前往内地的三闾大学任教。旅途中，他与赵辛楣、李梅亭、顾尔谦和孙柔嘉同行，钱钟书利用这段旅程深入刻画人物性格，一路上嬉笑怒骂，非常有趣，这段旅程不仅是物理上的移动，更是心理上的探索，揭示了人物在压力下的真实面貌。</p><h3 id="三闾大学任教：学术与人际的挣扎"><a href="#三闾大学任教：学术与人际的挣扎" class="headerlink" title="三闾大学任教：学术与人际的挣扎"></a>三闾大学任教：学术与人际的挣扎</h3><p>抵达三闾大学后，方鸿渐因无正式学位，地位低下，卷入学术权力斗争。他与孙柔嘉的关系逐渐升温，最终订婚并离开学校。大学环境充斥伪知识分子，钱钟书通过对教授间的虚伪和争斗的描写，讽刺了学术界的浮夸与空洞。</p><h3 id="婚后生活：围城的现实与破裂"><a href="#婚后生活：围城的现实与破裂" class="headerlink" title="婚后生活：围城的现实与破裂"></a>婚后生活：围城的现实与破裂</h3><p>婚后，方鸿渐与孙柔嘉回到上海，婚姻生活却不如预期。两人性格差异和家庭背景导致频繁争吵，方鸿渐工作不顺，最终失业，婚姻也日益恶化，直至分道扬镳。这一阶段，钱钟书通过细腻的心理描写，展现了婚姻的现实残酷，呼应了“围城”隐喻：城内人想逃，城外人想入。</p><h3 id="文学技巧：比喻与讽刺的艺术"><a href="#文学技巧：比喻与讽刺的艺术" class="headerlink" title="文学技巧：比喻与讽刺的艺术"></a>文学技巧：比喻与讽刺的艺术</h3><p>钱钟书以其精湛的文笔，将比喻和讽刺融入小说，增强了文本的表现力。</p><h2 id="比喻的运用"><a href="#比喻的运用" class="headerlink" title="比喻的运用"></a>比喻的运用</h2><ul><li><strong>核心比喻：“围城”</strong>：婚姻如围城，城外人渴望进入，城内人却想逃出，这一隐喻贯穿全书，深刻反映人类对婚姻的矛盾心理。</li><li><strong>人物比喻</strong>：如鲍小姐被戏称为“局部的真理”，因其外露而非完全赤裸，幽默中透露出对人物性格的批判。</li><li><strong>自然意象</strong>：如夜空“如浸油的纸，变得半透明”，象征方鸿渐生活中的模糊与过渡。</li></ul><h2 id="讽刺的辛辣"><a href="#讽刺的辛辣" class="headerlink" title="讽刺的辛辣"></a>讽刺的辛辣</h2><ul><li><strong>假文凭的讽刺</strong>：方鸿渐买假文凭，批判了知识分子对西方教育的盲目崇拜和学术不端的普遍现象。</li><li><strong>伪知识分子的嘲弄</strong>：三闾大学中，教授间的虚伪与争斗，揭露了学术界的浮夸与空洞。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502221625636.png" alt="《围城》人物关系"></p><h2 id="原文划线"><a href="#原文划线" class="headerlink" title="原文划线"></a>原文划线</h2><blockquote><p>红海早过了，船在印度洋面上开驶着，但是太阳依然不饶人地迟落早起，侵占去大部分的夜。夜仿佛纸浸了油，变成半透明体；它给太阳拥抱住了，分不出身来，也许是给太阳陶醉了，所以夕照晚霞隐褪后的夜色也带着酡红。</p></blockquote><blockquote><p>他们上了船，天就微雨。时而一点两点，像不是头顶这方天下的，到定睛细看，又没有了。一会儿，雨点密起来，可是还不像下雨，只仿佛许多小水珠在半空里顽皮，滚着跳着，顽皮得够了，然后趁势落地…这雨愈下愈老成，水点贯串作丝，河面上像出了痘，无数麻瘢似的水涡，随生随灭，息息不停，到雨线更密，又仿佛光滑的水面上在长毛。</p></blockquote><blockquote><p>鸿渐走出门，神经麻木，不感觉冷，意识里只有左颊在发烫。头脑里，情思弥漫纷乱像个北风飘雪片的天空。他信脚走着，彻夜不睡的路灯把他的影子一盏盏彼此递交。</p></blockquote><blockquote><p>左颊忽然星星作痛，他一摸湿腻腻的，以为是血，吓得心倒定了，腿里发软。走到灯下，瞧手指上没有痕迹，才知道流了眼泪。</p></blockquote><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>刚开始阅读《围城》时，我被钱钟书对书中人物的精彩描写和辛辣讽刺深深吸引，沉浸其中。最好玩的部分就是前往三闾大学的故事了，那一段不仅充满了幽默与趣味，更通过一系列生动的情节展现了每个人物的独特性格。尤其是赵辛楣，他三观端正、能力出众，在感情上也从不拖泥带水，让人由衷地欣赏和钦佩。</p><p>然而，随着故事的发展，特别是到了方鸿渐和孙柔嘉结婚前后的情节，心情逐渐变得复杂起来。这段内容越看越觉得气愤又好笑，甚至有些感同身受。方鸿渐在婚姻中的种种无奈与困惑，仿佛一面镜子，映照出生活中那些看似微不足道却又无处不在的烦恼。读到这里，我不禁代入了方鸿渐那种既不甘心又无力改变现状的心理状态，甚至产生了“生活不止眼前的苟且，还有远方的苟且”的感慨。</p><p>钱钟书对方鸿渐心理活动的细致刻画令人叹服。每一个细节都栩栩如生，仿佛将读者带入了那个充满矛盾与挣扎的世界。读完这本书后，我久久不能平静，内心深处依然回荡着书中人物的命运与情感。幸好，后记中杨绛详细讲述了写作过程，并分享了她与钱钟书之间温馨而有趣的生活点滴，这才让我慢慢恢复过来。</p><p>人生正如钱钟书笔下的世界，像一场草台班子上演的大戏，充满了不确定性和戏剧性。但正是这种不确定性，赋予了生活无限的可能性和意义。《围城》不仅仅是一部小说，它更是对人生的深刻反思与启示。读完这本书，我最大的感悟就是要好好生活，学会理解和宽容他人，保持坚定和乐观的心态。</p><p>感谢钱钟书创作了这样一部杰作，它不仅让我们看到了人性的复杂和社会的真实面貌，更教会我们在面对生活的种种挑战时，如何以更加豁达和积极的态度去迎接未来。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如有帮助，请收藏点赞<br>微信公众号：环境猫er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain-Chatchat  +  deepseek 搭建知识库应用</title>
    <link href="/2025/03/03/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LangChain-Chatchat%20%20+%20%20deepseek%20%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E5%BA%93%E5%BA%94%E7%94%A8/"/>
    <url>/2025/03/03/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/LangChain-Chatchat%20%20+%20%20deepseek%20%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E5%BA%93%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>之前介绍过如何使用 cherry studio 搭建本地知识库应用，不过它只能在个人电脑上运行，无法实现web端的应用。如何利用开源工具LangChain - Chatchat，在本地快速构建一个知识库的web应用，希望对大家有所帮助，如果有什么疑问欢迎留言评论。</p><h2 id="安装-python-3-11-9"><a href="#安装-python-3-11-9" class="headerlink" title="安装 python 3.11.9"></a>安装 python 3.11.9</h2><p>LangChain - Chatchat支持的Python版本为3.8 - 3.11，这里以python 3.11.9为例。</p><ul><li>环境：python 3.11.9</li><li>IDE：pycharm</li></ul><p>下载地址：<br><a href="https://www.python.org/downloads/release/python-3119/">Python Release Python 3.11.9 | Python.org</a><br>利用 pytcharm 新建一个项目，选择 python 3.11.9 做为基础解释器，新建一个 venv 环境。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503032107236.png" alt="设置解释器"></p><p>先Fork 官方项目langchain-chatchat。</p><p>将项目 clone 到文件夹。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:chatchat-space/Langchain-Chatchat.git<br></code></pre></td></tr></table></figure><h3 id="安装支持库"><a href="#安装支持库" class="headerlink" title="安装支持库"></a>安装支持库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#必须安装</span><br>pip <span class="hljs-keyword">install</span> langchain-chatchat -U<br><span class="hljs-comment">#可选安装</span><br>pip <span class="hljs-keyword">install</span> <span class="hljs-string">&quot;langchain-chatchat[xinference]&quot;</span> -U<br></code></pre></td></tr></table></figure><p>Xinference 是一个模型平台类似与 ollama，可选安装</p><p>如果运行 rag 报错-TypeError, 需要降级 httpx。没有报错则忽略</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pip</span> install httpx==<span class="hljs-number">0</span>.<span class="hljs-number">27</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="初始化配置文件"><a href="#初始化配置文件" class="headerlink" title="初始化配置文件"></a>初始化配置文件</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">chatchat <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>运行后进行以下炒作：</p><ul><li>创建所有需要的数据目录</li><li>复制 samples 知识库内容</li><li>生成默认 <code>yaml</code> 配置文件</li></ul><h2 id="模型推理框架加载模型"><a href="#模型推理框架加载模型" class="headerlink" title="模型推理框架加载模型"></a>模型推理框架加载模型</h2><p>从 0.3.0 版本起，Langchain-Chatchat 不再根据用户输入的本地模型路径直接进行模型加载，涉及到的模型种类包括 LLM、Embedding、Reranker 及后续会提供支持的多模态模型等，均改为支持市面常见的各大模型推理框架接入，如 <a href="https://github.com/xorbitsai/inference">Xinference</a>、<a href="https://github.com/ollama/ollama">Ollama</a>、<a href="https://github.com/mudler/LocalAI">LocalAI</a>、<a href="https://github.com/lm-sys/FastChat">FastChat</a>、<a href="https://github.com/songquanpeng/one-api">One API</a> 等。因此，请确认在启动 Langchain-Chatchat 项目前，首先进行模型推理框架的运行，并加载所需使用的模型。</p><h3 id="文本嵌入模型"><a href="#文本嵌入模型" class="headerlink" title="文本嵌入模型"></a>文本嵌入模型</h3><p>本文选择使用 ollama 下载本地嵌入模型 bge-large-zh-v 1.5: latest</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503041335198.png" alt="ollama "></p><h3 id="默认对话模型"><a href="#默认对话模型" class="headerlink" title="默认对话模型"></a>默认对话模型</h3><p>对话模型比较大，我选择使用硅基流动 api 。我测试的时候硅基流动的文本嵌入模型没法直接调用。</p><h4 id="修改模型配置"><a href="#修改模型配置" class="headerlink" title="修改模型配置"></a>修改模型配置</h4><p>配置模型（modelsettings. yaml）<br>需要根据步骤 2. 模型推理框架并加载模型中选用的模型推理框架与加载的模型进行模型接入配置，具体参考 modelsettings. Yaml 中的注释。主要修改以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 默认选用的 LLM 名称  </span><br><span class="hljs-attr">DEFAULT_LLM_MODEL:</span> <span class="hljs-string">deepseek-ai/DeepSeek-R1-Distill-Qwen-7B</span><br>  <br><span class="hljs-comment"># 默认选用的 Embedding 名称  </span><br><span class="hljs-attr">DEFAULT_EMBEDDING_MODEL:</span> <span class="hljs-string">quentinz/bge-large-zh-v1.5:latest</span><br><br><span class="hljs-attr">MODEL_PLATFORMS:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">platform_name:</span> <span class="hljs-string">ollama</span>  <br>  <span class="hljs-attr">platform_type:</span> <span class="hljs-string">ollama</span>  <br>  <span class="hljs-attr">api_base_url:</span> <span class="hljs-string">http://127.0.0.1:11434/v1</span>  <br>  <span class="hljs-attr">api_key:</span> <span class="hljs-string">EMPTY</span>  <br>  <span class="hljs-attr">api_proxy:</span> <span class="hljs-string">&#x27;&#x27;</span>  <br>  <span class="hljs-attr">api_concurrencies:</span> <span class="hljs-number">5</span>  <br>  <span class="hljs-attr">auto_detect_model:</span> <span class="hljs-literal">false</span>  <br>  <span class="hljs-attr">llm_models:</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">qwen:1.8b</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">qwen2:7b</span>  <br>  <span class="hljs-attr">embed_models:</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">quentinz/bge-large-zh-v1.5:latest</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">platform_name:</span> <span class="hljs-string">openai</span>  <br>  <span class="hljs-attr">platform_type:</span> <span class="hljs-string">openai</span>  <br>  <span class="hljs-attr">api_base_url:</span> <span class="hljs-string">https://api.siliconflow.cn/v1/</span><br>  <span class="hljs-comment"># 使用自己的apikey   </span><br>  <span class="hljs-attr">api_key:</span> <span class="hljs-string">sk-</span>  <br>  <span class="hljs-attr">api_proxy:</span> <span class="hljs-string">&#x27;&#x27;</span>  <br>  <span class="hljs-attr">api_concurrencies:</span> <span class="hljs-number">5</span>  <br>  <span class="hljs-attr">auto_detect_model:</span> <span class="hljs-literal">false</span>  <br>  <span class="hljs-attr">llm_models:</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Pro/deepseek-ai/DeepSeek-V3</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">deepseek-ai/DeepSeek-R1</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">Pro/deepseek-ai/DeepSeek-R1</span>  <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">deepseek-ai/DeepSeek-R1-Distill-Qwen-7B</span><br></code></pre></td></tr></table></figure><h4 id="邀请链接"><a href="#邀请链接" class="headerlink" title="邀请链接"></a>邀请链接</h4><p>最近硅基流动在做推广活动，用下面的链接注册，就可以获得2000万Tokens（14元平台配额），如果需要，就用下面的链接注册吧。<br>模型邀请链接：<br><a href="https://cloud.siliconflow.cn/i/p61lgKxB">https://cloud.siliconflow.cn/i/p61lgKxB</a><br>邀请码：p61lgKxB</p><p>初始化知识库，并测试模型是否配置好。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">chatchat kb -r</span><br></code></pre></td></tr></table></figure><p>成功效果如下：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202503032156778.png" alt="成功效果"></p><h4 id="5-启动项目"><a href="#5-启动项目" class="headerlink" title="5. 启动项目"></a>5. 启动项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">chatchat start -a<br>```  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 测试对话</span></span><br><br>![对话界面](https://gitee.com/chenwenmao/picbed/raw/master/img/202503040740566.png)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">### 测试知识库问答</span></span><br><br>![知识库问答](https://gitee.com/chenwenmao/picbed/raw/master/img/202503041251973.png)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 遇到的坑</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">## TypeError</span></span> <br><br>![image.png](https://gitee.com/chenwenmao/picbed/raw/master/img/202503041250572.png)<br><br>错误原因：`httpx==0.28.0` 版本可能会导致上述错误。建议将 `httpx` 的版本降级到 `0.27.2`，因为这个版本已经被证实可以解决问题<br>- 执行以下命令来降级 `httpx`：<br></code></pre></td></tr></table></figure><p>pip install httpx&#x3D;&#x3D;0.27.2</p><pre><code class="hljs">### 无法使用硅基流动文本嵌入模型无法用 openai 格式直接调用硅基流动的文本嵌入模型，需要用 ollama 、oneapi 等工具。## 优化方向- 使用 oneapi 等工具更方便的选择模型，管理模型- 修改 streamlit 设置，制作最的 ui 界面，修改logo## 小结**LangChain-Chatchat**项目利用 langchain+ollama 实现 RAG 对话应用，前段采用 streamlit 框架，整个项目全部使用 python，模型框架支持 ollama、oneapi、Xinference 等模型框架，几乎可以使用任何模型进行调试，适合进行二次开发，如果使用本地模型，则对硬件有一定要求，建议大家测试使用免费 api 即可，等成熟后再考虑本地部署或者用收费 api 。## BY如有帮助，请收藏点赞加关注~微信公众号：环境猫er  CSDN : 细节处有神明  个人博客：https://maoyu92.github.io/</code></pre>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>deepseek</tag>
      
      <tag>知识库</tag>
      
      <tag>langchain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deepseek + mermaid 自动绘制流程图</title>
    <link href="/2025/02/24/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/deepseek%20+%20mermaid%20%E8%87%AA%E5%8A%A8%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2025/02/24/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/deepseek%20+%20mermaid%20%E8%87%AA%E5%8A%A8%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><blockquote><p>在数字化迅猛发展的今天，流程图作为信息可视化的重要工具，在众多领域发挥着不可替代的作用。然而，传统的手动绘制流程图方式存在耗时且易出错的问题。本文将重点介绍利用 DeepSeek 与 Mermaid 相结合的方法，实现快速构建清晰美观的流程图。</p></blockquote><h2 id="什么是-Mermaid？"><a href="#什么是-Mermaid？" class="headerlink" title="什么是 Mermaid？"></a>什么是 Mermaid？</h2><p>Mermaid 是一种轻量级的图表标记语言，允许用户通过简单的文本语法定义各种类型的图表，包括流程图、序列图、甘特图等。以下是 Mermaid 流程图的基本语法示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">graph <span class="hljs-selector-tag">TD</span>;<br>    <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[开始]</span> --&gt; <span class="hljs-selector-tag">B</span>&#123;决策&#125;;<br>    <span class="hljs-selector-tag">B</span> --是--&gt; C<span class="hljs-selector-attr">[执行任务]</span>;<br>    <span class="hljs-selector-tag">B</span> --否--&gt; D<span class="hljs-selector-attr">[结束]</span>;<br></code></pre></td></tr></table></figure><p>效果如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502131543142.png" alt="image.png"></p><h3 id="Mermaid-的优势："><a href="#Mermaid-的优势：" class="headerlink" title="Mermaid 的优势："></a>Mermaid 的优势：</h3><ol><li><strong>简洁易用</strong>：只需编写少量代码即可生成复杂的图表。</li><li><strong>跨平台兼容</strong>：支持多种工具和框架（如 Markdown 编辑器、HTML 页面）。</li><li><strong>动态更新</strong>：修改代码后图表会实时更新，非常适合敏捷开发。</li></ol><hr><h2 id="使用-DeepSeek-生成-Mermaid-语法"><a href="#使用-DeepSeek-生成-Mermaid-语法" class="headerlink" title="使用 DeepSeek 生成 Mermaid 语法"></a>使用 DeepSeek 生成 Mermaid 语法</h2><p>DeepSeek 是一款强大的开源大语言模型，能够根据自然语言描述自动生成代码。我们可以利用它来快速生成 Mermaid 语法，从而减少手动编写的工作量。</p><p>例如，如果我们需要绘制一个简单的审批流程图，可以向 DeepSeek 提供以下输入：</p><p><strong>输入：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">请生成一个 Mermaid 流程图语法，描述以下场景：<br>用户提交申请；<br>管理员审核申请；<br>如果审核通过，则进入下一步；<br>如果审核不通过，则返回用户修改。<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">graph <span class="hljs-selector-tag">TD</span>;<br>    <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[用户提交申请]</span> --&gt; <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[管理员审核]</span>;<br>    <span class="hljs-selector-tag">B</span> --通过--&gt; C<span class="hljs-selector-attr">[进入下一步]</span>;<br>    <span class="hljs-selector-tag">B</span> --不通过--&gt; D<span class="hljs-selector-attr">[返回用户修改]</span>;<br></code></pre></td></tr></table></figure><p><strong>效果：</strong></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502131545512.png"></p><p>通过这种方式，我们可以轻松地将复杂的需求转化为结构化的 Mermaid 语法。</p><hr><h2 id="工具推荐：快速渲染-Mermaid-图表"><a href="#工具推荐：快速渲染-Mermaid-图表" class="headerlink" title="工具推荐：快速渲染 Mermaid 图表"></a>工具推荐：快速渲染 Mermaid 图表</h2><p>生成 Mermaid 语法后，可以选择合适的工具将其渲染为可视化的流程图。以下是几款常用的工具推荐：</p><h3 id="draw-Io"><a href="#draw-Io" class="headerlink" title="draw. Io"></a>draw. Io</h3><ul><li><strong>简介</strong>：draw. Io 是一款功能强大的在线绘图工具，支持导入 Mermaid 语法并生成图表。</li><li><strong>特点</strong>：</li><li>免费使用，无需注册。</li><li>支持导出为多种格式（如 PNG、SVG、PDF）。</li><li><strong>使用方法</strong>：</li></ul><ol><li>打开 <a href="https://app.diagrams.net/">draw.io</a>。</li><li>以此点击编辑图形-插入-高级-mermaid</li><li>实时预览并调整图表布局。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502131534692.png"></p><h3 id="Obsidian-Excalidraw"><a href="#Obsidian-Excalidraw" class="headerlink" title="Obsidian Excalidraw"></a>Obsidian Excalidraw</h3><ul><li><strong>简介</strong>：Excalidraw 是一款协作式白板工具，而 Obsidian 的 Excalidraw 插件允许用户直接在笔记中嵌入和编辑图表。</li><li><strong>特点</strong>：</li><li>支持 Mermaid 语法嵌入。</li><li>集成于 Obsidian 生态系统，适合知识管理爱好者。</li><li>提供丰富的主题和样式选项。</li><li><strong>使用方法</strong>：</li></ul><ol><li>安装 Obsidian 和 Excalidraw 插件。</li><li>新建绘图文件-点击最右侧更多工具-mermaid。</li><li>复制代码渲染流程图，根据自己需要修改。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502131549781.png"></p><h3 id="Obsidian-笔记"><a href="#Obsidian-笔记" class="headerlink" title="Obsidian 笔记"></a>Obsidian 笔记</h3><p>在 obsidian 中可以直接渲染 mermaid 语法。在代码块中输入如下内容，就可以直接渲染。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502131554714.png"></p><p><strong>效果：</strong></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502131555020.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 DeepSeek 和 Mermaid 的配合使用，我们可以快速生成结构化流程图，并借助工具如 draw. Io 或 Obsidian Excalidraw 将其渲染为高质量的可视化图表。这种方法不仅提高了效率，还降低了手动绘制流程图的复杂性。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h3><ul><li><a href="https://mermaid-js.github.io/">Mermaid 官方文档</a></li><li><a href="https://app.diagrams.net/">draw.io 官网</a></li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><blockquote><p>欢迎点赞、评论、收藏，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a><br>如果对你有帮助，请我喝杯咖啡~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>流程图</tag>
      
      <tag>办公技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProcessOn与DeepSeek强强联合，制图效率upup！</title>
    <link href="/2025/02/22/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/DeepSeek%E4%B8%8EProcessOn%E5%BC%BA%E5%BC%BA%E8%81%94%E5%90%88%EF%BC%8C%E5%88%B6%E5%9B%BE%E6%95%88%E7%8E%87upup%EF%BC%81/"/>
    <url>/2025/02/22/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/DeepSeek%E4%B8%8EProcessOn%E5%BC%BA%E5%BC%BA%E8%81%94%E5%90%88%EF%BC%8C%E5%88%B6%E5%9B%BE%E6%95%88%E7%8E%87upup%EF%BC%81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>之前分享过 DeepSeek 与 Mermaid 的组合使用，今天再为大家推荐一款强大的在线制图工具——ProcessOn。这款工具不仅功能全面，还能够与 DeepSeek 等 AI 工具联动，帮助我们大幅提升工作效率。</p><h2 id="ProcessOn-简介"><a href="#ProcessOn-简介" class="headerlink" title="ProcessOn  简介"></a>ProcessOn  简介</h2><p>ProcessOn作为一款国产免费的在线流程图、思维导图工具，想必大家或多或少都有所耳闻。它无需下载安装，直接在网页端就能便捷使用。其功能涵盖多种图表类型，如流程图、思维导图等，还提供了思维笔记、协作白板等多种实用功能。其中，思维笔记类似于幕布的思维导图大纲笔记模式，而协作白板则更具个性化和自由度。</p><p>ProcessOn兼容性极佳，可导入markdown、xmind、mmap、mm、km、opml、visio、csv等多种市面上常见的流程图、思维导图格式，几乎做到了全面覆盖。</p><p>此外，ProcessOn还支持导入mermaid、markdown格式的语法，并且流程图中能够插入python等代码，支持LaTeX语法等功能，这些特性使得它成为一款功能强大的制图工具。</p><p>既然ProcessOn支持导入markdown和mermaid，那么它就可以很好地与DeepSeek结合使用，从而一键生成各种图表，例如思维导图、流程图、饼图、桑基图、甘特图、类图、状态图、实体关系图等。下面以思维导图和流程图为例进行详细说明。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502221542382.png" alt="在process on中插入 mermaid "></p><h2 id="思维导图-围城人物关系案例"><a href="#思维导图-围城人物关系案例" class="headerlink" title="思维导图 -围城人物关系案例"></a>思维导图 -围城人物关系案例</h2><p>Markdown + deepseek +提示词获得思维导图大纲。</p><p>Prompt ：用 markdown 格式生成钱钟书小说围城人物关系思维导图。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502221614780.png" alt="image.png"></p><p>结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 《围城》人物关系思维导图</span><br><br><span class="hljs-section">## 1. 方鸿渐</span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**情感纠葛**</span><br><span class="hljs-bullet">  -</span> 鲍小姐（邮轮露水情缘，后遭抛弃）<br><span class="hljs-bullet">  -</span> 苏文纨（大学同学，暧昧未果，后嫁曹元朗）<br><span class="hljs-bullet">  -</span> 唐晓芙（苏文纨表妹，方鸿渐理想恋人，因误会分手）<br><span class="hljs-bullet">  -</span> 孙柔嘉（三闾大学同事，后成妻子，婚姻矛盾激化）<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**职场关系**</span><br><span class="hljs-bullet">  -</span> 赵辛楣（好友，引荐至三闾大学，惺惺相惜）<br><span class="hljs-bullet">  -</span> 李梅亭（虚伪同事，同行赴三闾大学）<br><span class="hljs-bullet">  -</span> 高松年（三闾大学校长，权谋算计）<br><span class="hljs-bullet">  -</span> 韩学愈（假学历同事，与方鸿渐对立）<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**家庭关系**</span><br><span class="hljs-bullet">  -</span> 方父方母（传统乡绅，施压婚姻）<br><span class="hljs-bullet">  -</span> 周家（未婚妻家族，资助留学后关系破裂）<br><br><span class="hljs-section">## 2. 孙柔嘉</span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**婚姻困境**</span><br><span class="hljs-bullet">  -</span> 方鸿渐（丈夫，性格不合，矛盾频发）<br><span class="hljs-bullet">  -</span> 姑母与姐姐（干预婚姻，激化家庭矛盾）<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**性格特质**</span><br><span class="hljs-bullet">  -</span> 表面柔弱，实则工于心计，掌控婚姻主导权<br><br><span class="hljs-section">## 3. 苏文纨</span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**情感游戏**</span><br><span class="hljs-bullet">  -</span> 方鸿渐（暧昧对象）<br><span class="hljs-bullet">  -</span> 赵辛楣（追求者，后与其私情纠葛）<br><span class="hljs-bullet">  -</span> 曹元朗（最终丈夫，平庸诗人）<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**人物象征**</span><br><span class="hljs-bullet">  -</span> 伪知识分子，追求虚荣与男性簇拥<br><br><span class="hljs-section">## 4. 赵辛楣</span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**核心关系**</span><br><span class="hljs-bullet">  -</span> 方鸿渐（从情敌转为挚友）<br><span class="hljs-bullet">  -</span> 苏文纨（单恋对象，后疏远）<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**职场助力**</span><br><span class="hljs-bullet">  -</span> 引荐方鸿渐至三闾大学及报馆任职<br><br><span class="hljs-section">## 5. 次要人物</span><br><span class="hljs-bullet">-</span> <span class="hljs-strong">**三闾大学群体**</span><br><span class="hljs-bullet">  -</span> 汪处厚（官僚作风教授）<br><span class="hljs-bullet">  -</span> 范懿（爱慕赵辛楣，性格矫饰）<br><span class="hljs-bullet">  -</span> 刘东方（同事，与方鸿渐短暂合作）<br><span class="hljs-bullet">-</span> <span class="hljs-strong">**其他角色**</span><br><span class="hljs-bullet">  -</span> 李妈（方家佣人，象征传统束缚）<br><span class="hljs-bullet">  -</span> 褚慎明（哲学家，虚伪做作）<br></code></pre></td></tr></table></figure><p>打开 ProcessOn- 新建-导入 -markdown 生成思维导图。效果如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502221625636.png" alt="《围城》人物关系"></p><h2 id="流程图-英雄是怎么练成的"><a href="#流程图-英雄是怎么练成的" class="headerlink" title="流程图 - 英雄是怎么练成的"></a>流程图 - 英雄是怎么练成的</h2><p>Prompt：用mermaid 语法描述坎贝尔的《千面英雄》中英雄是怎么练成的流程。</p><p>结果：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">graph</span> <span class="hljs-selector-tag">TD</span><br>    <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[平凡世界]</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[冒险的召唤]</span><br>    <span class="hljs-selector-tag">B</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">C</span>&#123;拒绝召唤&#125;<br>    <span class="hljs-selector-tag">C</span> <span class="hljs-selector-tag">--</span>&gt;|接受| <span class="hljs-selector-tag">D</span><span class="hljs-selector-attr">[超自然助力]</span><br>    <span class="hljs-selector-tag">C</span> <span class="hljs-selector-tag">--</span>&gt;|拒绝| <span class="hljs-selector-tag">A</span><br>    <span class="hljs-selector-tag">D</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">E</span><span class="hljs-selector-attr">[跨越第一个阈限]</span><br>    <span class="hljs-selector-tag">E</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">F</span><span class="hljs-selector-attr">[鲸鱼之腹/人生低谷]</span><br>    <span class="hljs-selector-tag">F</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">G</span><span class="hljs-selector-attr">[试炼之路]</span><br>    <span class="hljs-selector-tag">G</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">H</span><span class="hljs-selector-attr">[与女神相会]</span><br>    <span class="hljs-selector-tag">H</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">I</span><span class="hljs-selector-attr">[诱惑者考验]</span><br>    <span class="hljs-selector-tag">I</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">J</span><span class="hljs-selector-attr">[与父和解]</span><br>    <span class="hljs-selector-tag">J</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">K</span><span class="hljs-selector-attr">[神化]</span><br>    <span class="hljs-selector-tag">K</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">L</span><span class="hljs-selector-attr">[终极恩赐]</span><br>    <span class="hljs-selector-tag">L</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">M</span>&#123;拒绝回归&#125;<br>    <span class="hljs-selector-tag">M</span> <span class="hljs-selector-tag">--</span>&gt;|接受| <span class="hljs-selector-tag">N</span><span class="hljs-selector-attr">[魔法飞行]</span><br>    <span class="hljs-selector-tag">M</span> <span class="hljs-selector-tag">--</span>&gt;|拒绝| <span class="hljs-selector-tag">O</span><span class="hljs-selector-attr">[救援助力]</span><br>    <span class="hljs-selector-tag">O</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">N</span><br>    <span class="hljs-selector-tag">N</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">P</span><span class="hljs-selector-attr">[跨越回归阈限]</span><br>    <span class="hljs-selector-tag">P</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">Q</span><span class="hljs-selector-attr">[两个世界的主宰]</span><br>    <span class="hljs-selector-tag">Q</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">R</span><span class="hljs-selector-attr">[生活的自由]</span><br>    <br>    <span class="hljs-selector-tag">style</span> <span class="hljs-selector-tag">A</span> <span class="hljs-selector-tag">fill</span>:<span class="hljs-selector-id">#f9f</span>,<span class="hljs-selector-tag">stroke</span>:<span class="hljs-selector-id">#333</span><br>    <span class="hljs-selector-tag">style</span> <span class="hljs-selector-tag">R</span> <span class="hljs-selector-tag">fill</span>:<span class="hljs-selector-id">#bbf</span>,<span class="hljs-selector-tag">stroke</span>:<span class="hljs-selector-id">#333</span><br></code></pre></td></tr></table></figure><p>导入 ProcessOn 进行修改后效果。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502241952095.png" alt="千面英雄之成神之路.png"></p><h2 id="其他特别功能"><a href="#其他特别功能" class="headerlink" title="其他特别功能"></a>其他特别功能</h2><h3 id="与-visio-联动"><a href="#与-visio-联动" class="headerlink" title="与 visio 联动"></a>与 visio 联动</h3><p>ProcessOn还拥有众多AI功能，例如一键美化、润色排版等。并且它支持导出为Visio文件，这意味着可以直接将其放置在Word文档中，并且在Word中还能进行编辑。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502220822188.png" alt="word中的visio"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502220822316.png" alt="ProcessOn 中导入的visio 文件"></p><h3 id="LaTeX-联动"><a href="#LaTeX-联动" class="headerlink" title="LaTeX 联动"></a>LaTeX 联动</h3><p>ProcessOn支持LaTeX语法，同时具备OCR识别LaTeX公式的能力。如果在撰写论文过程中遇到需要复制的公式，不妨一试。对于LaTeX语法，我们还可以通过DeepSeek生成或者修改想要的公式，然后粘贴到LaTeX页面。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502222018501.png"></p><h3 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h3><p>流程图支持插入代码块，这对程序员非常友好。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502222034862.png" alt="image.png"></p><h3 id="模板社区"><a href="#模板社区" class="headerlink" title="模板社区"></a>模板社区</h3><p>ProcessOn 有丰富的模板社区，可以根据自己需要找到合适的模板，还可以自己的成果发布为付费模板，实现知识变现。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502241957595.png" alt="ProcessOn 模板社区"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>ProcessOn是一款功能全面的在线流程图、思维导图工具，可用于原型图、UML、BPMN、网络拓扑图等多种图形绘制，支持多种格式的导入导出，兼容markdown、mermaid、LaTeX等语法。它能与DeepSeek等大语言模型相结合，快速提升制图效率，再配合ProcessOn优秀的编辑功能，方便地完成各类图形的修改和完善。</p><h2 id="文末福利"><a href="#文末福利" class="headerlink" title="文末福利"></a>文末福利</h2><p>ProcessOn专属邀请链接，欢迎大家使用下面的链接注册 ProcessOn</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.processon.com<span class="hljs-regexp">/i/</span><span class="hljs-number">659513</span>ff2b4cb726485cbfb4?full_name=PO_SvJHYT<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://www.processon.com/i/659513ff2b4cb726485cbfb4?full_name=PO_SvJHYT">https://www.processon.com/i/659513ff2b4cb726485cbfb4?full_name=PO_SvJHYT</a></p></blockquote><h3 id="相关网址"><a href="#相关网址" class="headerlink" title="相关网址"></a>相关网址</h3><ul><li><a href="https://mermaid.js.org/syntax/flowchart.html">Mermaid 流程图文档</a></li><li><a href="https://www.processon.com/">ProcessOn 官方网站</a></li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
      <tag>deepseek</tag>
      
      <tag>流程图</tag>
      
      <tag>办公技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grok 3模型震撼发布  抢先免费体验</title>
    <link href="/2025/02/18/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Grok%203%E6%A8%A1%E5%9E%8B%E9%9C%87%E6%92%BC%E5%8F%91%E5%B8%83%20%20%E6%8A%A2%E5%85%88%E5%85%8D%E8%B4%B9%E4%BD%93%E9%AA%8C/"/>
    <url>/2025/02/18/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Grok%203%E6%A8%A1%E5%9E%8B%E9%9C%87%E6%92%BC%E5%8F%91%E5%B8%83%20%20%E6%8A%A2%E5%85%88%E5%85%8D%E8%B4%B9%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>北京时间 2 月 18 日中午 12 点，马斯克旗下 xAI 公司正式发布了备受瞩目的新一代人工智能模型——Grok 3。号称地表最强模型，这款被马斯克吹上天的产品具体如何，我们通过直播视频的几张关键对比图来一探究竟。同时推荐一个快速尝鲜  Grok 3 的网站。</p><h2 id="Grok-3-的亮点"><a href="#Grok-3-的亮点" class="headerlink" title="Grok 3 的亮点"></a>Grok 3 的亮点</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502181415237.png"></p><p>上图展示的是 <strong>Chatbot Arena (LMSYS)</strong> 平台上不同大型语言模型 (LLM) 的 Elo 评分，反映了它们在用户体验和性能方面的相对排名。图表中，Grok-3 的早期版本 “chocolate” 以 1400+ 的高分位居榜首，gemini 2.- flash 1380 分，deepseek r1 有 1360 分。 </p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502181424249.png"></p><p>上图展示了不同大型语言模型（LLM）在数学、科学和编程三个基准测试中的得分情况。其中，Grok-3 在所有三个测试中都取得了最高分，超过了 deepseek v 3、gemini、Claude、GPT 4 O。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502181418273.png"></p><p>上图展示了不同大型语言模型在 AIME 2025 数学竞赛中的表现，主要考察它们的推理能力和计算能力。其中，Grok-3 Reasoning Beta 版本为 93 分，Grok-3 mini Reasoning 版本也达到了 90 分，显示出 Grok 系列模型在数学推理方面的强大实力。相比之下，Deepseek-R 1 和 Gemini-2 Flash Thinking 的得分分别为 87 分和 79 分，o3 mini (high) 和 o1 模型的得分则分别为 87 分和 75 分。整体来看，Grok-3 系列模型在 AIME 2025 测试中表现突出，尤其 Grok-3 Reasoning Beta 版本在数学推理能力上展现出显著优势。</p><h2 id="抢先体验-Grok-3"><a href="#抢先体验-Grok-3" class="headerlink" title="抢先体验 Grok 3"></a>抢先体验 Grok 3</h2><p>本文推荐一个免费体验 Grok 3 早期版本的网址。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//lmarena.ai/</span><br></code></pre></td></tr></table></figure><p>进入网站后点击直接对话，选择 Grok 3 即可。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502181407706.png" alt="image.png"></p><p>目前 grok 3 已经免费使用啦。体验了下还是很不错的，速度很快。（修改于 2025 年 2 月 24 日）</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>马斯克凭借 200,000 个 Nvidia H 100 GPU 和超长的训练周期，打造出这款在纸面数据上超越众多现有模型的产品。然而，与 Deepseek 等竞争对手相比，Grok 3 巨大的成本投入并未带来显著的优势提升。试问，除了少数几家顶级科技巨头，还有哪家企业能够负担如此庞大的显卡资源和高昂的训练成本？这种“堆料”式的开发路径，似乎并不具备明显的长期竞争优势。目前，Grok 3 尚未正式发布，其实际应用效果及市场影响力仍有待进一步观察。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a>  </p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>grok3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deepseek + Napkin，轻松打造高颜值流程图</title>
    <link href="/2025/02/18/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Deepseek%20+%20Napkin%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%89%93%E9%80%A0%E9%AB%98%E9%A2%9C%E5%80%BC%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <url>/2025/02/18/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/Deepseek%20+%20Napkin%EF%BC%8C%E8%BD%BB%E6%9D%BE%E6%89%93%E9%80%A0%E9%AB%98%E9%A2%9C%E5%80%BC%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前我分享过如何用 <strong>Deepseek + Mermaid</strong> 快速生成流程图的方法，虽然实用，但总觉得少了点美感。今天，我要给大家介绍一款更强大的工具——<strong>Napkin.Ai</strong>！它不仅能将文本转化为流程图，还能生成<strong>超高颜值</strong>的视觉化内容，简直是效率与美学的完美结合！</p><p><strong>Napkin.Ai 的核心功能</strong>非常简单：输入文本，自动生成流程图。而它的最佳搭档，正是我们熟悉的 <strong>Deepseek</strong>。通过 Deepseek 生成精准的提示词，再交给 Napkin.Ai 处理，流程图瞬间就能变得既专业又美观。</p><p><strong>注册 Napkin.Ai 即可免费体验</strong>，接下来，我将通过一个实际案例，带大家感受一下这对“黄金组合”的强大威力！</p><hr><h2 id="案例演示：-Deepseek-Napkin-Ai-生成读书笔记流程图"><a href="#案例演示：-Deepseek-Napkin-Ai-生成读书笔记流程图" class="headerlink" title="案例演示： Deepseek + Napkin.Ai 生成读书笔记流程图"></a>案例演示： Deepseek + Napkin.Ai 生成读书笔记流程图</h2><h3 id="第一步：用-Deepseek-生成提示词"><a href="#第一步：用-Deepseek-生成提示词" class="headerlink" title="第一步：用 Deepseek 生成提示词"></a>第一步：用 Deepseek 生成提示词</h3><p>在 Deepseek 中输入以下指令：</p><blockquote><p>搜索《纳瓦尔宝典》中的核心概念，用书中提到的几个维度绘制一个流程图。</p></blockquote><p>Deepseek 迅速输出了以下核心流程图结构：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[判断力]</span>  <br>   │  <br>   ├──▶ <span class="hljs-selector-attr">[财富创造]</span>  <br>   │     ├─ 专长 → 杠杆（资本/代码/媒体） → 所有权 → 复利 → 财富自由  <br>   │  <br>   └──▶ <span class="hljs-selector-attr">[幸福哲学]</span>  <br>         ├─ 健康 → 内在平静 → 活在当下 → 退出竞争  <br>         │  <br>         └─ <span class="hljs-selector-attr">[自我成长循环]</span>  <br>              自我教育 → 实践 → 冥想 → 更新判断力  <br></code></pre></td></tr></table></figure><h3 id="第二步：将提示词导入-Napkin-Ai"><a href="#第二步：将提示词导入-Napkin-Ai" class="headerlink" title="第二步：将提示词导入 Napkin.Ai"></a>第二步：将提示词导入 Napkin.Ai</h3><p>将上述内容复制到 Napkin.Ai 中，点击闪电图标，流程图瞬间生成！</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502181051236.png" alt="image.png"></p><h4 id="第三步：选择并优化"><a href="#第三步：选择并优化" class="headerlink" title="第三步：选择并优化"></a>第三步：选择并优化</h4><p>Napkin.Ai 提供了多种风格供选择，你可以根据自己的喜好进行调整。以下是我最终选择的版本，支持二次编辑，还可以保存为高清图片：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502181052215.png" alt="纳瓦尔宝典总结 - visual selection.png"></p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <strong>Deepseek + Napkin.Ai</strong> 的组合，我们可以轻松将复杂的读书笔记转化为清晰、美观的流程图。整个过程简单高效，唯一的“缺点”可能就是免费版的使用次数有限。但即便如此，每一次使用 AI 工具，都让我感受到技术进步的震撼。</p><p>在这个快速发展的时代，我们需要保持专注、不断学习。希望今天的分享能为大家提供一些灵感，快去试试吧！如果你有其他好用的工具推荐，欢迎在评论区分享哦～</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>deepseek</tag>
      
      <tag>流程图</tag>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deepseek 应用合集</title>
    <link href="/2025/02/17/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/deepseek%20%E5%85%8D%E8%B4%B9%E5%BA%94%E7%94%A8%E5%90%88%E9%9B%86%E7%AE%80%E6%B4%81%E7%89%88/"/>
    <url>/2025/02/17/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/deepseek%20%E5%85%8D%E8%B4%B9%E5%BA%94%E7%94%A8%E5%90%88%E9%9B%86%E7%AE%80%E6%B4%81%E7%89%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于经常使用DeepSeek的用户来说，网页对话中时常出现服务器繁忙的情况实在令人困扰。好在越来越多的厂商宣布接入了 deepseek。现在网上也有很多 AI 聚合网站，但是感觉眼花缭乱的，于是我尽量搜集了接入 deepseek 网页版的应用，用 streamlit 做了一个简单的 web 导航页，方便自己随时可以使用。当然大家也可以把这些网址加入收藏夹或者用 itab 等插件添加为自定义页面，甚至直接使用 AI 聚合网址。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502171436606.png" alt="image.png"></p><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><p>界面比较简陋，没有时间去优化每一个 icon，用 emoji 代替的。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502171444431.png" alt="image.png"></p><h2 id="代码分享"><a href="#代码分享" class="headerlink" title="代码分享"></a>代码分享</h2><p>核心代码如下，需要的可以自己制作属于自己的导航页面。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import streamlit as st<br>link1, link2, link3, link4 = st.columns(4)<br>with link1:  <br>    st.page_link(<span class="hljs-string">&quot;https://chat.deepseek.com/&quot;</span>, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;DeepSeek 官网&quot;</span>, <span class="hljs-attribute">icon</span>=<span class="hljs-string">&quot;🌐&quot;</span>)  <br>with link2:  <br>    st.page_link(<span class="hljs-string">&quot;https://yuanbao.tencent.com/chat&quot;</span>, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;腾讯元宝&quot;</span>, <span class="hljs-attribute">icon</span>=<span class="hljs-string">&quot;💬&quot;</span>)  <br>with link3:  <br>    st.page_link(<span class="hljs-string">&quot;https://zhida.zhihu.com/&quot;</span>, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;知乎直答&quot;</span>, <span class="hljs-attribute">icon</span>=<span class="hljs-string">&quot;📚&quot;</span>)  <br>with link4:  <br>    st.page_link(<span class="hljs-string">&quot;https://bot.n.cn/&quot;</span>, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;360 纳米 AI&quot;</span>, <span class="hljs-attribute">icon</span>=<span class="hljs-string">&quot;🤖&quot;</span>)<br></code></pre></td></tr></table></figure><p>希望对大家有用~<br>如果大家有更好的想法留言告诉我吧~</p><p>网址：<a href="http://chat.wenmao.xyz/">http://chat.wenmao.xyz</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>工具推荐</tag>
      
      <tag>自制工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>word、ppt 接入deepseek 文章补充说明（免费送代码）</title>
    <link href="/2025/02/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/word%E3%80%81ppt%20%E6%8E%A5%E5%85%A5deepseek%20%E6%96%87%E7%AB%A0%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E/"/>
    <url>/2025/02/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/word%E3%80%81ppt%20%E6%8E%A5%E5%85%A5deepseek%20%E6%96%87%E7%AB%A0%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>再次感谢大家的关注，针对前面两篇文章进行一下补充。</p><h2 id="一、宏安全问题"><a href="#一、宏安全问题" class="headerlink" title="一、宏安全问题"></a>一、宏安全问题</h2><p>很多人说宏安全问题一直报错，原因一是没有在信任中心中开启宏安全设置。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112028028.png"></p><p>二是宏只保存在当前的 word 下，没有放在模板文件下，docx 是不支持宏的，需要在 dotm 中。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112029729.png"></p><p>那么如果我们将宏保存在模板中，他每次新建都会套用模板，就不存在问题了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112030843.png"></p><p>三是版本问题<br>有的朋友，始终不支持宏，那么我建议重装 office，至少能够录制宏，再来操作。</p><h2 id="二、文件下载与打开问题"><a href="#二、文件下载与打开问题" class="headerlink" title="二、文件下载与打开问题"></a>二、文件下载与打开问题</h2><p>我之前使用的蓝奏云，是为了大家方便，且不用输入验证码。代码免费下载。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112031582.png"></p><p>有的朋友反应下不了，我决定优化到百度网盘里。<br>另外我直接将宏导出为 abs 文件，需要的朋友自己导入就可以了，而且我新增了翻译功能。</p><p>更新后，为了保持一致，后台回复不变。<br>回复 wordAI 、1001，以此获得对应的代码。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112041354.png"></p><p>新增回复 1000 ，获得所有代码和模板文件。ABS 文件只需要在模块中选择导入就行。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112041352.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112116599.png"></p><h2 id="三、PPT-宏安全问题"><a href="#三、PPT-宏安全问题" class="headerlink" title="三、PPT 宏安全问题"></a>三、PPT 宏安全问题</h2><p>有的朋友反应，代码第一次能用，第二次不能用，道理和 word 模板一样，ppt 默认 vb 编辑界面没有模板，需要自己建一个 potm 模板文件，然后用这个模板右键打开，就可以使用了。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112044061.png"></p><h2 id="四、代码修改"><a href="#四、代码修改" class="headerlink" title="四、代码修改"></a>四、代码修改</h2><p>需要修改的得放就是 API key ，url ， model name。不会的将代码和自己的 apikey 为给 deepseek ，让他帮你改。</p><p>我默认用的硅基流动的蒸馏版，已经够用了，如果你要用满血 deepseek ，请用自己的 api key。如果不是硅基流动的，需要替换 API key ，url ， model name。再对应的 api 文档中查找就行。</p><p>如果你有更多想法，比如接入 excel，可以自行尝试，我有新发现也会发表新的文章，欢迎关注~</p><h2 id="五、关于-wps"><a href="#五、关于-wps" class="headerlink" title="五、关于 wps"></a>五、关于 wps</h2><p>Wps 在 vb 模式下，代码一模一样，但是默认没有 vb 模式，需要安装 vb 插件或者用企业版。<br>至于 js, 我并不熟悉，有大佬可以补充下。</p><h2 id="六、愿景"><a href="#六、愿景" class="headerlink" title="六、愿景"></a>六、愿景</h2><p>一起进步、共同成长~<br>Build in public，learn in public</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>欢迎点赞、评论、收藏，如需转载，请注明出处。<br>微信公众号：环境猫er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a><br>如果对你有帮助，请我喝杯咖啡~</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>deepseek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快来围观，我上线了一个免费AI对话网站</title>
    <link href="/2025/02/11/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%88%91%E4%B8%8A%E7%BA%BF%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9deepseek%E6%A8%A1%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BD%91%E7%AB%99%EF%BC%8C%E5%BF%AB%E6%9D%A5%E5%9B%B4%E8%A7%82/"/>
    <url>/2025/02/11/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%88%91%E4%B8%8A%E7%BA%BF%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%8D%E8%B4%B9deepseek%E6%A8%A1%E5%9E%8B%E8%81%8A%E5%A4%A9%E7%BD%91%E7%AB%99%EF%BC%8C%E5%BF%AB%E6%9D%A5%E5%9B%B4%E8%A7%82/</url>
    
    <content type="html"><![CDATA[<meta name=`referrer` content=`no-referrer` /><p>帮你省流，免费的是 deepseek 蒸馏模型。</p><p>利用 streamlit + 硅基流动 +阿里云服务器，做了个对话网站。大家可以轻松体验蒸馏的deepseek、通义千问、 llama 3、零一万物等，不需要 api key ，因为用的我的~，当然你也可以用自己的 API key。</p><p>我的费用就是自己的服务器，为爱发电，如果喜欢，给我买杯咖啡 ~</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="免费模型对话"><a href="#免费模型对话" class="headerlink" title="免费模型对话"></a>免费模型对话</h3><p>目前支持免费模型列表</p><ul><li><code>deepseek-ai/DeepSeek-R1-Distill-Qwen-7B</code>  </li><li><code>deepseek-ai/DeepSeek-R1-Distill-Qwen-1.5B</code></li><li><code>Qwen/Qwen2.5-7B-Instruct</code></li><li><code>Qwen/Qwen2.5-Coder-7B-Instruct</code></li><li><code>internlm/internlm2_5-7b-chat</code></li><li><code>meta-llama/Meta-Llama-3.1-8B-Instruct</code></li><li><code>01-ai/Yi-1.5-9B-Chat-16K</code></li></ul><h3 id="流式输出"><a href="#流式输出" class="headerlink" title="流式输出"></a>流式输出</h3><p>效果：</p><h3 id="新对话-历史对话"><a href="#新对话-历史对话" class="headerlink" title="新对话&#x2F;历史对话"></a>新对话&#x2F;历史对话</h3><p>利用 streamlit 的状态功能，实现新对话和历史对话查询功能</p><p>没有登录功能，因此没有保存任何对话信息。</p><p>手机访问界面也非常友好哦~</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502111727133.jpg" alt="8c8cf2c1bd3f9590b157eec8a1a89ee.jpg"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这只是自己的一个小尝试，做着玩的，欢迎来看看，感谢硅基流动大善人提供的免费 API，感谢 deepseek 开源。</p><h3 id="邀请链接"><a href="#邀请链接" class="headerlink" title="邀请链接"></a>邀请链接</h3><p>最近硅基流动在做推广活动，用下面的链接注册，就可以获得 2000 万 Tokens（14 元平台配额），如果需要，就用下面的链接注册吧，嘿嘿~<br>模型邀请链接：<br><a href="https://cloud.siliconflow.cn/i/p61lgKxB">https://cloud.siliconflow.cn/i/p61lgKxB</a><br>邀请码：p61lgKxB</p><blockquote><p>欢迎留言评论，转载注明出处。<br>如果对你有帮你，请我喝杯咖啡~</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>个人项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零代码构建AI助手：Cherry Studio全功能实践指南</title>
    <link href="/2025/02/07/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E9%9B%B6%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BAAI%E5%8A%A9%E6%89%8B%EF%BC%9ACherry%20Studio%E5%85%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/"/>
    <url>/2025/02/07/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E9%9B%B6%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BAAI%E5%8A%A9%E6%89%8B%EF%BC%9ACherry%20Studio%E5%85%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在[[为什么不推荐个人本地部署大语言模型？模型供应商推荐]]中，我们曾简要提及使用Cherry Studio搭建知识库的方案。本文将深度解析这款国产AI开发工具的最新功能与实践技巧，助你快速构建知识库、联网搜索、智能体、文生图等多项AI应用。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul><li>下载 Cherry studio<br>地址： <a href="https://cherry-ai.com/">https://cherry-ai.com/</a><br>注意：如果电脑性能不好，不要安装在 C 盘，因为所有资料库信息都在本地。</li></ul><h2 id="Cherry-studio-介绍"><a href="#Cherry-studio-介绍" class="headerlink" title="Cherry studio 介绍"></a>Cherry studio 介绍</h2><p>Cherry Studio 是一个国人开发的开源，多模型服务的桌面客户端，在 github 上有 5.7 k 的 star。因其简单易上手，最近非常火。而且最近更新比较频繁，适合新手快速上手。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li>开源免费，本地部署，不用数据泄密</li><li>中文开发者，文档清晰，界面简洁，易上手</li><li>功能丰富：对话知识库、联网搜索、多模型接入、智能体、文生图等。</li><li>可快速学习 AI 应用（智能体）搭建、 prompt 提示词工程</li></ol><h2 id="模型服务设置"><a href="#模型服务设置" class="headerlink" title="模型服务设置"></a>模型服务设置</h2><p>模型服务商支持硅基流动等近 30 种服务商，其中 ollama 就是所谓本地部署模型管理器，感兴趣的可以挨个去尝试了解获取 API（不建议一股脑全部申请），软件同时支持自定义添加 4 种主流的模型供应商类型：openAI, Gemini, anthropic, Azure openAI。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081616287.png" alt="模型服务商"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081617829.png" alt="自定义添加模型"></p><h3 id="硅基流动举例获取-key"><a href="#硅基流动举例获取-key" class="headerlink" title="硅基流动举例获取 key"></a>硅基流动举例获取 key</h3><p>首先获取在硅基流动官网获取 api key 。Cherry 贴心的做好了所有的跳转链接。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081633018.png" alt="跳转链接"></p><p>下方按钮点击模型，输入模型 id。模型 id 在模型广场复制。Cherry 自动识别了默认的服务商的模型名称和分组名称。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081637540.png" alt="添加模型"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081638593.png" alt="模型id查找"></p><h2 id="快速搭建本地知识库对话应用"><a href="#快速搭建本地知识库对话应用" class="headerlink" title="快速搭建本地知识库对话应用"></a>快速搭建本地知识库对话应用</h2><p>知识库对话并不神秘，就是 RAG 技术，需要本地知识库和两类模型，一类是文本对话，一类是文本嵌入。<br>文本对话模型示例</p><ul><li>deepseek-ai&#x2F;DeepSeek-R1（收费，运行慢，效果好）</li><li>deepseek-ai&#x2F;DeepSeek-V3（收费，运行慢，效果好）</li><li>deepseek-ai&#x2F;DeepSeek-R1-Distill-Llama-8B（蒸馏模型，免费，运行快）<br>文本嵌入模型举例</li><li>BAAI&#x2F;bge-m3</li><li>netease-youdao&#x2F;bce-embedding-base_v1</li><li>BAAI&#x2F;bge-large-zh-v1.5</li></ul><h3 id="添加个人知识库"><a href="#添加个人知识库" class="headerlink" title="添加个人知识库"></a>添加个人知识库</h3><p>在添加文本嵌入模型后，在知识库界面添加知识库，素材可以是文件、网址、网站、笔记。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502031118825.png" alt="添加文本嵌入模型"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081701346.png" alt="添加知识库"></p><p>注意，RAG 对 pdf、md 格式更加友好，推荐使用微软开源工具 markitdown 进行转换。 <a href="https://www.html.zone/markitdown/">https://www.html.zone/markitdown/</a></p><h3 id="模型使用并调用知识库"><a href="#模型使用并调用知识库" class="headerlink" title="模型使用并调用知识库"></a>模型使用并调用知识库</h3><p>在模型对话界面选择合适的模型，点击知识库图标，开始对话。下面是我以自己的历史博客内容用 deepseekv 2.5 进行的对话演示，输出引用内容可直接点击跳转。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502031122819.png" alt="知识库对话示例"></p><h2 id="联网搜索"><a href="#联网搜索" class="headerlink" title="联网搜索"></a>联网搜索</h2><p>Cherry Studio 目前已经支持的联网模型服务商有：<br>5. Google Gemini<br>6. 腾讯混元<br>7. 智谱 AI（全部收费）</p><p>具体申请 API 不在赘述，以下是使用 Google Gemini 2.0 联网模型的对话示例。<br>查找联网模型，注意添加 API key 并检查可用性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081655917.png" alt="联网模型"></p><p>在默认助手选择联网模型，点击联网模式，开启对话。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502081654727.png" alt="联网对话"></p><h2 id="智能体"><a href="#智能体" class="headerlink" title="智能体"></a>智能体</h2><p>内置了多种智能体，所谓智能体就是 prompt +模型参数微调。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502090818387.png" alt="image.png"></p><p>选择任意智能体，右键添加助手，在助手栏，右键编辑，可以看到内置的 prompt 。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502090820259.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502090823052.png" alt="image.png"></p><p>模型调参包括：默认温度、top-p、上下文数、是否流式输出、思维链长度等。</p><ol start="8"><li><strong>温度（temperature）</strong>：控制生成文本的随机性。值越高，输出越随机和多样化；值越低，输出越确定和保守，倾向于选择概率最高的词。</li><li><strong>top-p（nucleus sampling）</strong>：也称为概率阈值，决定从累积概率超过p的最小候选词集合中选择。例如，top_p&#x3D;0.7时，模型会从概率最高的词开始累加，直到总和超过0.7，然后仅从这些词中采样。这有助于减少重复性，同时保持多样性。</li><li><strong>上下文数（context window或max_tokens）</strong>：可能指模型处理的最大上下文长度，或者生成的最大token数。</li><li><strong>是否流式输出（stream）</strong>：流式输出指是否逐步接收生成的文本，而不是等待整个生成完成。代码中的stream参数设为False，表示不启用流式传输，一次性返回所有结果。</li><li><strong>思维链长度（chain of thought length）</strong>：控制推理模型的思维长度。</li></ol><p>我们可以通过内置的智能体，根据自己的需求构建属于自己的智能体。具体在智能体-我的-创建智能体。</p><h2 id="快捷助手"><a href="#快捷助手" class="headerlink" title="快捷助手"></a>快捷助手</h2><p>设置中开启快捷助手，可点击托盘图标快速启动默认对话机器人，其中默认模型可设置。个人感觉划词的方式更克制一点。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502090816375.png" alt="快捷助手"></p><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><p>小程序可快速进入主流大语言模型对话页面。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502090833780.png" alt="image.png"></p><h2 id="文生图"><a href="#文生图" class="headerlink" title="文生图"></a>文生图</h2><p>以硅基流动 API 为例，调用主流的 FLUX 文生图模型，可以快速绘制精美图片。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502090846627.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cherry studio 是适合个人的 AI 工具箱，通过使用它可以快速理解大语言模型调用、模型选择、模型参数微调、文生图、搭建本地知识库应用、联网搜索等一系列的 AI 应用，帮助我们提升工作效率。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
      <tag>知识库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么不推荐个人本地部署大语言模型？模型供应商推荐</title>
    <link href="/2025/02/03/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%B8%AA%E4%BA%BA%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%9F%E6%A8%A1%E5%9E%8B%E4%BE%9B%E5%BA%94%E5%95%86%E6%8E%A8%E8%8D%90/"/>
    <url>/2025/02/03/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%B8%AA%E4%BA%BA%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%A7%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%EF%BC%9F%E6%A8%A1%E5%9E%8B%E4%BE%9B%E5%BA%94%E5%95%86%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>随着Deepseek的爆火，大型语言模型（LLM）再次成为热门话题。作为一名深度用户，我近期投入了大量时间学习相关内容，并尝试了多种本地部署开源模型的方法，如使用Ollama。然而，实际使用中发现，本地部署存在诸多不足，尤其不适合个人或小型企业。本文将探讨本地部署大模型的主要缺点，并提出更优的解决方案，同时推荐一些优秀的模型供应商。</p><h2 id="明确使用大模型的目的"><a href="#明确使用大模型的目的" class="headerlink" title="明确使用大模型的目的"></a>明确使用大模型的目的</h2><p>在决定是否本地部署大模型之前，首先需要明确使用目的。如果仅仅是进行对话或聊天，直接使用各大模型的在线平台即可，无需涉及复杂的本地部署或API调用。然而，如果计划基于大模型进行二次开发，特别是在公司或行业特定领域进行私有化部署，那么就需要考虑是否采用本地部署或API调用。</p><h2 id="本都部署大语言模型的局限性"><a href="#本都部署大语言模型的局限性" class="headerlink" title="本都部署大语言模型的局限性"></a>本都部署大语言模型的局限性</h2><p>目前，较为流行的开源模型部署平台包括Ollama和LM Studio。Ollama通过简单的命令行指令即可下载模型，而LM Studio则提供了图形用户界面。两者的共同点在于都需要将模型下载到本地，这对计算机的显存、内存和CPU提出了较高要求。以Ollama中的Deepseek-r1为例，普通PC在运行8B模型时已显得力不从心，响应速度缓慢。若部署在Linux服务器上，成本将大幅增加。虽然可以使用蒸馏后的1.5B模型，但效果大打折扣，且我后续推荐的模型供应商免费提供1.5B模型的API接口。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502030755090.png" alt="ollama deepseek r1"></p><h2 id="模型供应商选择"><a href="#模型供应商选择" class="headerlink" title="模型供应商选择"></a>模型供应商选择</h2><p>模型供应商很多，我们应该如何选择呢，首先需要找到模型供应商有哪些，可以在 dify 或者 cherry studio 服务商页面去找。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502030935458.png" alt="模型供应商"></p><p>打开 dify 设置，选择模型供应商，我们可以看到有在线有本地的。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502030936438.png" alt="dify设置"></p><p>感兴趣的可以一个一个尝试，本文推荐使用硅基流动（SiliconFlow），也欢迎读者留言分享其他优秀的模型供应商。</p><h3 id="硅基流动"><a href="#硅基流动" class="headerlink" title="硅基流动"></a>硅基流动</h3><p>硅基流动（SiliconFlow）致力于加速AGI的普及，让生成式人工智能惠及开发者和终端用户。其模型广场几乎涵盖了市面上所有的开源模型，包括Deepseek-r1，提供收费和免费选项。注册用户可获得14元赠金，与Deepseek官方相当，个人用户基本可以免费调用API一个月以上。此外，硅基流动还提供许多免费模型，如Qwen 2.5-7B、Deepseek Janus-Pro-7B，足以满足学习和调试的需求。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502030827048.png"></p><h2 id="Api-怎么用？"><a href="#Api-怎么用？" class="headerlink" title="Api 怎么用？"></a>Api 怎么用？</h2><p>模型API提供了对模型的所有权限，我们可以利用Cline构建智能编码IDE，在VBA中使用宏调用API创建智能办公组件，或使用Dify、AnythingLLM、Cherry Studio等工具构建知识库应用、聊天机器人、Agent、工作流等。当然，也可以直接通过代码调用API。本文将以硅基流动（SiliconFlow）和Cherry Studio为例，快速构建一个聊天机器人。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li>下载Cherry studio</li><li>注册硅基流动（siliconflow）</li></ul><h3 id="Cherry-studio-介绍"><a href="#Cherry-studio-介绍" class="headerlink" title="Cherry studio 介绍"></a>Cherry studio 介绍</h3><p>Cherry Studio 是一个支持多模型服务的桌面客户端，在 github 上有 5.7 k 的 star。</p><h3 id="Cherry-studio-制作基于本地知识库的聊天机器人"><a href="#Cherry-studio-制作基于本地知识库的聊天机器人" class="headerlink" title="Cherry studio 制作基于本地知识库的聊天机器人"></a>Cherry studio 制作基于本地知识库的聊天机器人</h3><ol><li>在硅基流动模型广场点击 api 密钥，生成 api key。</li><li>在Cherry studio 点击设置 -模型服务中选择硅基流动添加模型，必须添加一个文本嵌入模型（我使用的是有道的免费版）。</li><li>在知识库界面添加知识库，素材可以是文件、网址、网站、笔记。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502031118825.png" alt="添加文本嵌入模型"></p><h3 id="模型使用并调用知识库"><a href="#模型使用并调用知识库" class="headerlink" title="模型使用并调用知识库"></a>模型使用并调用知识库</h3><p>在模型对话界面选择合适的模型，点击知识库图标，开始对话。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502031122819.png" alt="知识库对话示例"></p><h2 id="邀请链接"><a href="#邀请链接" class="headerlink" title="邀请链接"></a>邀请链接</h2><p>最近硅基流动在做推广活动，用下面的链接注册，就可以获得2000万Tokens（14元平台配额），如果需要，就用下面的链接注册吧，嘿嘿~<br>模型邀请链接：<br><a href="https://cloud.siliconflow.cn/i/p61lgKxB">https://cloud.siliconflow.cn/i/p61lgKxB</a><br>邀请码：p61lgKxB</p><p>最后我想说的是，学会调用 api 才是解决问题的方法，api 供应商越来越多，竞争越来越激烈，价格会越来越低，我们只需要学会如何使用，出现好用且便宜的服务商直接替换就好了，保持关注。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如果你觉得有用，请关注，评论，转发，谢谢~<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p><a href="https://siliconflow.cn/zh-cn/">SiliconFlow, Accelerate AGI to Benefit Humanity</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
      <tag>deepseek</tag>
      
      <tag>工具推荐</tag>
      
      <tag>闲话漫谈</tag>
      
      <tag>dify</tag>
      
      <tag>cherry_studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Word接入DeepSeek r1，轻松实现智能文本生成与润色</title>
    <link href="/2025/02/02/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Word%E6%8E%A5%E5%85%A5DeepSeek%20r1%EF%BC%8C%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E4%B8%8E%E6%B6%A6%E8%89%B2/"/>
    <url>/2025/02/02/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Word%E6%8E%A5%E5%85%A5DeepSeek%20r1%EF%BC%8C%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E6%99%BA%E8%83%BD%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90%E4%B8%8E%E6%B6%A6%E8%89%B2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>之前我曾利用Word的VBA宏接入ChatGPT 3.5的API。然而，由于OpenAI对中国大陆地区的限制，这一方案难以持续使用。随后出现的大型语言模型要么难以调用，要么收费昂贵。如今，随着DeepSeek的开源，结合Word这一办公常用场景，我决定将DeepSeek模型接入Word，实现文本生成和文本润色两大功能。</p><h2 id="Vba-code"><a href="#Vba-code" class="headerlink" title="Vba  code"></a>Vba  code</h2><h3 id="文本生成模块代码"><a href="#文本生成模块代码" class="headerlink" title="文本生成模块代码"></a>文本生成模块代码</h3><p>通过VBA调用英伟达的API(具体获取方式之前已提到多次不再赘述)，采用非流式生成方式。用户只需选中文字并点击模块名称，稍等片刻即可生成结果。该模块基于推理文本模型，并保留了模型的思考过程。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> DeepSeek()<br>    <span class="hljs-keyword">Dim</span> selectedText <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> apiKey <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> response <span class="hljs-keyword">As</span> <span class="hljs-type">Object</span>, re <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> midString <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> ans <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">If</span> Selection.Type = wdSelectionNormal <span class="hljs-keyword">Then</span><br>        selectedText = Selection.<span class="hljs-keyword">Text</span><br>        selectedText = Replace(selectedText, ChrW$(<span class="hljs-number">13</span>), <span class="hljs-string">&quot;&quot;</span>)<br>        apiKey = <span class="hljs-string">&quot;your_api_key_here&quot;</span><br>        URL = <span class="hljs-string">&quot;https://integrate.api.nvidia.com/v1/chat/completions&quot;</span><br>        <span class="hljs-keyword">Set</span> response = CreateObject(<span class="hljs-string">&quot;MSXML2.XMLHTTP&quot;</span>)<br>        response.Open <span class="hljs-string">&quot;POST&quot;</span>, URL, <span class="hljs-literal">False</span><br>        response.setRequestHeader <span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span><br>        response.setRequestHeader <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> + apiKey<br>        response.Send <span class="hljs-string">&quot;&#123;&quot;&quot;model&quot;&quot;:&quot;&quot;deepseek-ai/deepseek-r1&quot;&quot;, &quot;&quot;messages&quot;&quot;:[&#123;&quot;&quot;role&quot;&quot;:&quot;&quot;user&quot;&quot;,&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span> &amp; selectedText &amp; <span class="hljs-string">&quot;&quot;&quot;&#125;], &quot;&quot;temperature&quot;&quot;:0.7&#125;&quot;</span><br>        <br>        re = response.responseText<br>        midString = <span class="hljs-keyword">Mid</span>(re, InStr(re, <span class="hljs-string">&quot;&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span>) + <span class="hljs-number">11</span>)<br>        ans = Split(midString, <span class="hljs-string">&quot;&quot;&quot;&quot;</span>)(<span class="hljs-number">0</span>)<br>        ans = Replace(ans, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        Selection.<span class="hljs-keyword">Text</span> = selectedText &amp; vbNewLine &amp; ans<br>        <span class="hljs-keyword">Else</span><br>        <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Sub</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br></code></pre></td></tr></table></figure><h3 id="文本润色模块"><a href="#文本润色模块" class="headerlink" title="文本润色模块"></a>文本润色模块</h3><p>文本润色模块内置了提示词，大家可根据需要修改提示词，实现翻译、润色、续写等功能。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> DeepSeekPolish()<br>    <span class="hljs-keyword">Dim</span> selectedText <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> apiKey <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> response <span class="hljs-keyword">As</span> <span class="hljs-type">Object</span>, re <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> midString <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> ans <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <span class="hljs-keyword">Dim</span> polishPrompt <span class="hljs-keyword">As</span> <span class="hljs-type">String</span><br>    <br>    <span class="hljs-comment">&#x27; 检查是否有正常选中的文本</span><br>    <span class="hljs-keyword">If</span> Selection.Type = wdSelectionNormal <span class="hljs-keyword">Then</span><br>        <span class="hljs-comment">&#x27; 获取选中文本并去除不需要的字符</span><br>        selectedText = Selection.<span class="hljs-keyword">Text</span><br>        selectedText = Replace(selectedText, ChrW$(<span class="hljs-number">13</span>), <span class="hljs-string">&quot;&quot;</span>)<br>        <br>        <span class="hljs-comment">&#x27; 定义API密钥和请求URL</span><br>        apiKey = <span class="hljs-string">&quot;your_api_key_here&quot;</span><br>        URL = <span class="hljs-string">&quot;https://integrate.api.nvidia.com/v1/chat/completions&quot;</span><br>        <br>        <span class="hljs-comment">&#x27; 设置润色提示词</span><br>        polishPrompt = <span class="hljs-string">&quot;请润色以上文字，要求语句通顺，条理清晰，专业而合理。&quot;</span><br>        <br>        <span class="hljs-comment">&#x27; 创建HTTP请求对象并设置参数</span><br>        <span class="hljs-keyword">Set</span> response = CreateObject(<span class="hljs-string">&quot;MSXML2.XMLHTTP&quot;</span>)<br>        response.Open <span class="hljs-string">&quot;POST&quot;</span>, URL, <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-comment">&#x27; 添加必要的头部信息</span><br>        response.setRequestHeader <span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span><br>        response.setRequestHeader <span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer &quot;</span> + apiKey<br>        <br>        <span class="hljs-comment">&#x27; 发送请求，注意在JSON字符串中添加了polishPrompt</span><br>        response.Send <span class="hljs-string">&quot;&#123;&quot;&quot;model&quot;&quot;:&quot;&quot;deepseek-ai/deepseek-r1&quot;&quot;, &quot;&quot;messages&quot;&quot;:[&#123;&quot;&quot;role&quot;&quot;:&quot;&quot;user&quot;&quot;,&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span> &amp; selectedText &amp; <span class="hljs-string">&quot;&quot;&quot;&#125;, &#123;&quot;&quot;role&quot;&quot;:&quot;&quot;assistant&quot;&quot;, &quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span> &amp; polishPrompt &amp; <span class="hljs-string">&quot;&quot;&quot;&#125;], &quot;&quot;temperature&quot;&quot;:0.7&#125;&quot;</span><br>        <br>        <span class="hljs-comment">&#x27; 处理响应数据</span><br>        re = response.responseText<br>        midString = <span class="hljs-keyword">Mid</span>(re, InStr(re, <span class="hljs-string">&quot;&quot;&quot;content&quot;&quot;:&quot;&quot;&quot;</span>) + <span class="hljs-number">11</span>)<br>        ans = Split(midString, <span class="hljs-string">&quot;&quot;&quot;&quot;</span>)(<span class="hljs-number">0</span>)<br>        ans = Replace(ans, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>        <br>        <span class="hljs-comment">&#x27; 将原选中文本与润色后的文本一起插入文档中</span><br>        Selection.<span class="hljs-keyword">Text</span> = selectedText &amp; vbNewLine &amp; ans<br>    <span class="hljs-keyword">Else</span><br>        <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Sub</span><br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br></code></pre></td></tr></table></figure><h2 id="宏的使用"><a href="#宏的使用" class="headerlink" title="宏的使用"></a>宏的使用</h2><p>宏的使用有很多方法，快捷键、放在功能区都行，这里以自定义功能区简单介绍。</p><h3 id="添加宏"><a href="#添加宏" class="headerlink" title="添加宏"></a>添加宏</h3><ol><li>选项-信任中心-宏设置-启用所有宏-信任 vba</li><li>开启开发工具, 选项-自定义选项卡-勾选开发工具。    </li><li>Word 工具栏点击“开发工具”选项卡。    </li><li>点击“Visual Basic”。    </li><li>右键模板下的“模块”，选择“插入模块”。    </li><li>复制上述代码到新建的模块中。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502112028028.png" alt="宏设置"></p><h3 id="自定义功能区"><a href="#自定义功能区" class="headerlink" title="自定义功能区"></a>自定义功能区</h3><ol><li>点击“文件”-&gt;“选项”-&gt;“自定义功能区”。    </li><li>选择“宏”，在右侧自定义功能区新建选项卡和组。    </li><li>将宏添加至组中，重命名并更换图标。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502020918275.png"></li></ol><h3 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502021030439.png"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最近几天，我一直在探索DeepSeek的应用，深感其高性能和低成本对工作生活的普惠意义。对于个人和小企业而言，人工智能的应用应紧密结合自身场景，无需考虑在本地搭建模型。尽管DeepSeek模型开源，但在本地运行全功能模型成本较高。随着各大厂商的跟进，生成式模型可能成为基础设施，如同GitHub一样普及。我们需要做的是提前跑通整个流程，以便在新模型出现时能迅速应用。目前，DeepSeek虽强大，但运行速度仍有提升空间，尤其是RI推理模型。让我们保持热情，持续关注其发展。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p><p><a href="https://blog.csdn.net/weixin_42984235/article/details/129632566">GPT3.5 与word的结合，提前享受office copilot_wordgpt-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>deepseek</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>deepseek+cursor打造免费智能代码编辑器</title>
    <link href="/2025/02/01/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/deepseek+cursor%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E6%99%BA%E8%83%BD%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2025/02/01/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/deepseek+cursor%E6%89%93%E9%80%A0%E5%85%8D%E8%B4%B9%E6%99%BA%E8%83%BD%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>之前使用 Cursor 时常常担心 token 耗尽问题。现在通过 DeepSeek 开源模型和 NVIDIA 提供的免费 API 接口，配合 Cline 插件即可实现智能代码生成。</p><h2 id="deepseek-api-获取"><a href="#deepseek-api-获取" class="headerlink" title="deepseek api 获取"></a>deepseek api 获取</h2><p>登录英伟达官方网站，进入 NIM 界面，找到 DeepSeek R 1 项目，并点击右侧的“获取 API Key”。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[deepseek-r1 Model by Deepseek-ai | NVIDIA NIM]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//build.nvidia.com/deepseek-ai/deepseek-r1)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501312203160.png" alt="image.png"></p><h2 id="Cursor-设置"><a href="#Cursor-设置" class="headerlink" title="Cursor 设置"></a>Cursor 设置</h2><p>在 cursor 应用商店，输入 Cline，选择 Cline（prev. debug cline）点击安装。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502011737177.png" alt="image.png"><br>选择安装好的 cline 插件，点击设置，以此输入 api、baseurl、apikey、modelid。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502011739671.png" alt="image.png"></p><p>插件配置参数如下</p><ul><li>API Provider:    OpenAI (Compatible)</li><li>Base URL:        <a href="https://integrate.api.nvidia.com/v1">https://integrate.api.nvidia.com/v1</a></li><li>API Key:         [您的实际API密钥]</li><li>Model ID:        deepseek-ai&#x2F;deepseek-r1</li></ul><p>成功啦。</p><p>在 Cline 中可以通过@，连接项目、文件夹、文件，直接读取并修改文件代码内容，还可以可以直接在文件中优化文稿。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://blog.csdn.net/weixin_42984235/article/details/145410582">nivdia 接入 deepseek r1 免费调用API-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42984235/article/details/145385200">DeepSeek 崛起引发的思考：一场颠覆性技术革命如何重塑全球AI与半导体格局-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42984235/article/details/145375900">使用Streamlit与DeepSeek API快速构建Chat应用-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42984235/article/details/145414563">deepseek+cursor打造免费智能代码编辑器-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扩展无限可能：Obsidian Web Viewer插件深度解析</title>
    <link href="/2025/01/31/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E6%89%A9%E5%B1%95%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%EF%BC%9AObsidian%20Web%20Viewer%E6%8F%92%E4%BB%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <url>/2025/01/31/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E6%89%A9%E5%B1%95%E6%97%A0%E9%99%90%E5%8F%AF%E8%83%BD%EF%BC%9AObsidian%20Web%20Viewer%E6%8F%92%E4%BB%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>随着 Obsidian 1.8.3 正式版的发布，备受期待的官方核心插件——Web Viewer 也终于上线。本文将从插件启用、设置以及应用场景三个方面详细介绍如何使用这一新功能，和大家一起更好地利用 Obsidian 进行内容管理和知识整理。</p><h2 id="插件启用"><a href="#插件启用" class="headerlink" title="插件启用"></a>插件启用</h2><p>Web Viewer作为官方核心插件，在更新到1.8.3版本后，用户可以直接在核心插件列表中找到并开启它。启用之后，在新标签页会出现一个“Open Web Viewer”的按钮，点击该按钮并输入网址即可开始浏览网页。</p><h2 id="插件设置"><a href="#插件设置" class="headerlink" title="插件设置"></a>插件设置</h2><p>点击插件设置</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501312010090.png" alt="image.png"></p><p>具体包括：</p><ul><li>是否打开超链接，默认为是。</li><li>主页，设置打开web viewer 的主页</li><li>保存文章文件夹，设置剪藏的默认文件夹</li><li>搜索引擎</li><li>是否开启广告拦截</li><li>广告拦截规则</li><li>广告拦截频率</li><li>清除浏览器缓存</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>根据实际体验，主要场景有 4个方面，简洁浏览器、沉浸式阅读、快速剪藏、功能拓展。</p><h3 id="简洁浏览器"><a href="#简洁浏览器" class="headerlink" title="简洁浏览器"></a>简洁浏览器</h3><p>最基础的功能就是在 Obsidian 中多了一个浏览器的场景，默认点击超链接就打开了，非常简洁，相当于没有插件的浏览器，对于写笔记的时候预览链接很方便。</p><h3 id="沉浸式阅读"><a href="#沉浸式阅读" class="headerlink" title="沉浸式阅读"></a>沉浸式阅读</h3><p>插件有一个沉浸式阅读的按钮，点击网址右边的👓图标，就可以进入沉浸式阅读。这样我们可以将一些常用的咨询类网站，收藏起来，然后使用沉浸式阅读，就会将网页转为 obsidian 的语法模式和笔记样式。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501312019303.png" alt="使用web viewer "></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501312020297.png" alt="沉浸式阅读"></p><h3 id="快速剪藏"><a href="#快速剪藏" class="headerlink" title="快速剪藏"></a>快速剪藏</h3><p>Obsidian 此前出的 web clipper 插件已经相当优秀，在 web viewer 使用沉浸式阅读后，点击三个竖点，点击 save to vault 就可以将文章以 markdown 格式保存在之前设置好的文件夹中。</p><h3 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h3><p>借助浏览器网页强大的生态，减少资源占用，比如我们直接使用滴答清单网页版管理待办清单、flomo 网页版管理闪念笔记、打开微信读书网页版阅读，可以将这些工具很好的整合起来。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Web Viewer 插件的推出无疑是Obsidian发展历程中的一个重要里程碑，它不仅显著扩展了这款知识管理工具的应用范围，还极大地提升了用户的使用体验。通过集成网页浏览功能，用户现在能够更加流畅地在笔记和外部资源之间切换，无需离开Obsidian即可访问互联网上的丰富信息。这不仅提高了工作效率，也为内容输入与输出提供了更多的便利。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian插件</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nivdia 接入 deepseek r1 免费调用API</title>
    <link href="/2025/01/31/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/nivdia%20%E6%8E%A5%E5%85%A5%20deepseek%20r1%20%E5%85%8D%E8%B4%B9%E8%B0%83%E7%94%A8API/"/>
    <url>/2025/01/31/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/nivdia%20%E6%8E%A5%E5%85%A5%20deepseek%20r1%20%E5%85%8D%E8%B4%B9%E8%B0%83%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>1月30日，英伟达在其NIM平台上架了由DeepSeek开源的DeepSeek R1模型，这标志着开发者们现在能够免费利用这一强大的API快速构建各种应用程序。感谢DeepSeek的开源贡献，让我们得以免费体验如此优秀的模型。</p><h2 id="获取英伟达-key"><a href="#获取英伟达-key" class="headerlink" title="获取英伟达 key"></a>获取英伟达 key</h2><p>首先，登录英伟达官方网站，进入NIM界面，找到DeepSeek R1项目，并点击右侧的“获取API Key”。页面会提供Python调用方法，方便直接测试和集成。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[deepseek-r1 Model by Deepseek-ai | NVIDIA NIM]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//build.nvidia.com/deepseek-ai/deepseek-r1)</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501312203160.png" alt="image.png"></p><p>以下是英伟达给的调用接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI(<br>  base_url = <span class="hljs-string">&quot;https://integrate.api.nvidia.com/v1&quot;</span>,<br>  api_key = <span class="hljs-string">&quot;$API_KEY_REQUIRED_IF_EXECUTING_OUTSIDE_NGC&quot;</span><br>)<br><br>completion = client.chat.completions.create(<br>  model=<span class="hljs-string">&quot;deepseek-ai/deepseek-r1&quot;</span>,<br>  messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;Which number is larger, 9.11 or 9.8?&quot;</span>&#125;],<br>  temperature=<span class="hljs-number">0.6</span>,<br>  top_p=<span class="hljs-number">0.7</span>,<br>  max_tokens=<span class="hljs-number">4096</span>,<br>  stream=<span class="hljs-literal">True</span><br>)<br><br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> completion:<br>  <span class="hljs-keyword">if</span> chunk.choices[<span class="hljs-number">0</span>].delta.content <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">print</span>(chunk.choices[<span class="hljs-number">0</span>].delta.content, end=<span class="hljs-string">&quot;&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="使用Chainlit框架构建简单页面"><a href="#使用Chainlit框架构建简单页面" class="headerlink" title="使用Chainlit框架构建简单页面"></a>使用Chainlit框架构建简单页面</h2><p>之前曾用 streamlit 构建了 deepseek 对话页面，但是其功能略微粗糙，相较于传统Streamlit框架，我们采用Chainlit 实现更高效、简洁的流式交互体验。Chainlit的异步处理架构完美适配大语言模型的流式响应特性，主要技术优势包括：</p><ul><li>实时token级渲染（Token-by-token rendering）    </li><li>WebSocket长连接支持    </li><li>会话状态管理（Session state management）    </li><li>多模态输入支持（文本&#x2F;文件&#x2F;图像）</li></ul><p>今天尝试使用Chainlit框架构建一个简单的交互式页面。新建一个 <code>app.py</code> 文件，并复制以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 安装第三方库</span><br><span class="hljs-comment"># pip install chainlit openai </span><br><span class="hljs-keyword">import</span> chainlit <span class="hljs-keyword">as</span> cl<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI <br><br><span class="hljs-meta">@cl.on_chat_start</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_chat</span>():<br>    <span class="hljs-comment"># 初始化客户端（密钥建议通过环境变量管理）</span><br>    client = OpenAI(<br>        base_url=<span class="hljs-string">&quot;https://integrate.api.nvidia.com/v1&quot;</span>,<br>        api_key=<span class="hljs-string">&quot;&quot;</span><br>    )<br>    <span class="hljs-comment"># 将客户端保存到用户会话</span><br>    cl.user_session.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;client&quot;</span>, client)<br><span class="hljs-meta">@cl.on_message</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">message: cl.Message</span>):<br>    <span class="hljs-comment"># 获取客户端实例</span><br>    client = cl.user_session.get(<span class="hljs-string">&quot;client&quot;</span>)<br>    <span class="hljs-comment"># 创建消息对象（支持流式响应）</span><br>    msg = cl.Message(content=<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-comment"># 调用NVIDIA API</span><br>    completion = client.chat.completions.create(<br>        model=<span class="hljs-string">&quot;deepseek-ai/deepseek-r1&quot;</span>,<br>        messages=[<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: message.content&#125;<br>        ],<br>        temperature=<span class="hljs-number">0.6</span>,<br>        top_p=<span class="hljs-number">0.7</span>,<br>        max_tokens=<span class="hljs-number">4096</span>,<br>        stream=<span class="hljs-literal">True</span><br>    ) <br><br>    <span class="hljs-comment"># 流式处理响应</span><br>    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> completion:<br>        <span class="hljs-keyword">if</span> chunk.choices[<span class="hljs-number">0</span>].delta.content:<br>            <span class="hljs-keyword">await</span> msg.stream_token(chunk.choices[<span class="hljs-number">0</span>].delta.content)<br>    <span class="hljs-comment"># 发送完整响应</span><br>    <span class="hljs-keyword">await</span> msg.send()<br></code></pre></td></tr></table></figure><p>技术参数说明：</p><ul><li>基础接口地址：<code>https://integrate.api.nvidia.com/v1</code>    </li><li>模型标识符：<code>deepseek-ai/deepseek-r1</code>    </li><li>最大上下文窗口：4096 tokens    </li><li>默认推理参数：temperature&#x3D;0.6，top_p&#x3D;0.7</li></ul><p>在命令行中输入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">chainlit <span class="hljs-built_in">run</span> app.py<br></code></pre></td></tr></table></figure><p>跳转到 8000 端口，就可以对话了。可以看到的确使用了</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202502010814190.png" alt="image.png"></p><p>完美展现了过程并实现了流式输出。</p><p>![[录屏_20250201_082623.mp4]]</p><h2 id="技术生态影响与行业动态"><a href="#技术生态影响与行业动态" class="headerlink" title="技术生态影响与行业动态"></a>技术生态影响与行业动态</h2><p>打不过就加入，随着 deepseek 的开源，国内外大厂都认识到他的价值，同时引发全球技术生态的连锁反应，其核心优势体现在：</p><table><thead><tr><th>技术指标</th><th>DeepSeek R1</th><th>LLaMA2-13B</th><th>Mistral-7B</th></tr></thead><tbody><tr><td>推理成本($&#x2F;1M tokens)</td><td>0.15</td><td>0.45</td><td>0.28</td></tr><tr><td>训练算力消耗(PF-days)</td><td>820</td><td>1840</td><td>950</td></tr><tr><td>代码生成准确率(HumanEval)</td><td>68.9%</td><td>52.1%</td><td>59.3%</td></tr></tbody></table><p>了英伟达（NVIDIA）将DeepSeek集成到其NIM平台外，其他行业巨头也迅速跟进：</p><ul><li><strong>微软</strong>：在Azure AI和GitHub上提供DeepSeek R1模型。</li><li><strong>AMD</strong>：为MI300系列GPU优化了ROCm推理加速方案，显著提升了DeepSeek在高性能计算环境中的表现。</li><li><strong>印度数字部</strong>：基于DeepSeek架构构建 AI项目，旨在打造符合本国需求的基础模型。</li></ul><p>这些举措表明，DeepSeek不仅在技术上具有领先优势，还在全球范围内获得了广泛的应用和支持，成为推动人工智能普及化的重要力量。</p><p>DeepSeek的技术突破标志着大模型发展进入”高效能时代”，其混合专家架构（MoE）实现了参数利用率300%的提升。这种技术民主化进程正在重塑AI产业格局：初创公司现可用1&#x2F;10的算力成本达到GPT-3.5级性能，传统行业智能化改造门槛显著降低。随着NVIDIA、微软等巨头的生态支持，DeepSeek的技术红利将持续释放，推动全球AI应用进入普惠新阶段。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeepSeek 崛起引发的思考：一场颠覆性技术革命如何重塑全球AI与半导体格局</title>
    <link href="/2025/01/28/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/DeepSeek%20%E5%B4%9B%E8%B5%B7%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%9A%E4%B8%80%E5%9C%BA%E9%A2%A0%E8%A6%86%E6%80%A7%E6%8A%80%E6%9C%AF%E9%9D%A9%E5%91%BD%E5%A6%82%E4%BD%95%E9%87%8D%E5%A1%91%E5%85%A8%E7%90%83AI%E4%B8%8E%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%A0%BC%E5%B1%80/"/>
    <url>/2025/01/28/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/DeepSeek%20%E5%B4%9B%E8%B5%B7%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%9A%E4%B8%80%E5%9C%BA%E9%A2%A0%E8%A6%86%E6%80%A7%E6%8A%80%E6%9C%AF%E9%9D%A9%E5%91%BD%E5%A6%82%E4%BD%95%E9%87%8D%E5%A1%91%E5%85%A8%E7%90%83AI%E4%B8%8E%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%A0%BC%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="DeepSeek-的“国运级”突破"><a href="#DeepSeek-的“国运级”突破" class="headerlink" title="DeepSeek 的“国运级”突破"></a>DeepSeek 的“国运级”突破</h2><p>2025 年初，中国 AI 初创公司 DeepSeek 凭借其开源推理模型<strong>DeepSeek-R 1</strong>，在全球科技界掀起巨浪。该模型在数学、编程和逻辑推理任务中表现卓越，性能对标 OpenAI 的 GPT-4 o，甚至在某些领域（如中文知识理解和代码生成）实现超越 。更令人瞩目的是，其训练成本仅为 557.6 万美元，仅为 GPT-4 o 的十分之一 ，且完全开源，迅速登顶 Hugging Face 和 Ollama 排行榜。其应用在美区 App Store 下载量超越 ChatGPT，成为全球开发者社区的焦点 。</p><p>游戏科学 CEO冯骥称此为“国运级别的突破”，不仅因技术性能，更因<strong>中国首次在 AI 底层架构上定义了新范式</strong>——通过开源生态和算法优化，打破西方依赖算力堆砌的垄断模式。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501280654098.png"></p><h2 id="低成本技术路径的颠覆性意义"><a href="#低成本技术路径的颠覆性意义" class="headerlink" title="低成本技术路径的颠覆性意义"></a>低成本技术路径的颠覆性意义</h2><p>DeepSeek 的成功直接挑战了西方 AI 发展的核心逻辑：<strong>高投入&#x3D;高壁垒</strong>。传统上，AI 大模型的训练依赖英伟达等公司的高端 GPU 集群，而 DeepSeek 仅用低端芯片便实现了同等性能，打破了“堆显卡”的垄断模式 。其核心创新在于：</p><ol><li><strong>架构革命</strong>：采用混合专家模型（MoE）与多头潜在注意力（MLA），通过动态路由和低秩压缩技术，将推理效率提升 1.8 倍，同时减少对高端 GPU 的依赖 。</li><li><strong>训练成本革命</strong>：通过 FP 8 混合精度训练和 DualPipe 算法优化，仅用 2048 块英伟达 H 800 GPU 完成训练，效率为 Meta 同类模型的 11 倍 。</li><li><strong>开源生态赋能</strong>：MIT 许可证下完全开源，并提供从 1.5 B 到 671 B 参数的多种量化模型，吸引全球超 5000 名开发者参与优化，形成“预训练-行业蒸馏-场景微调”的产业链分工 。</li></ol><p>这种模式直接冲击了英伟达等企业的商业逻辑。市场担忧，若低成本算法成为主流，高端 GPU 需求可能萎缩，而 AMD 等竞争对手则借机抢占份额 。</p><h2 id="连锁反应：美股科技股“史诗级暴跌”"><a href="#连锁反应：美股科技股“史诗级暴跌”" class="headerlink" title="连锁反应：美股科技股“史诗级暴跌”"></a>连锁反应：美股科技股“史诗级暴跌”</h2><p>DeepSeek 的冲击波迅速传导至资本市场。1 月 27 日，美股半导体板块集体崩盘：</p><ul><li>**英伟达暴跌 16.97%**，市值蒸发近 4000 亿美元；</li><li>**博通跌 17.4%**，台积电 ADR 跌 13.3%，3 倍做空半导体etf涨 22.83%。</li></ul><p>纳斯达克指数同步暴跌 3%，市场对 AI 芯片需求前景的预期发生根本性动摇。分析师直言，这标志着“AI 军备竞赛的斯普特尼克时刻”——美国的技术霸权首次遭遇实质性挑战。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501280628352.png"></p><p>中国股市同样受到影响，27 日半导体板块跌 2.9%，寒武纪跌 6.9%，其他相关板块如算力、光模块等同样暴跌，但影响并未完全释放，预计节后还会下跌。</p><h2 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h2><p>DeepSeek 的崛起让人联想到华为的“5 G 速度”奇迹，尽管受制于芯片禁令，华为通过麒麟 8000 A 芯片和鸿蒙系统的协同优化，在中低端手机上实现了 5 G 等效体验，制裁限制不了中国科技，未来几年，中国科技可能在人工智能、芯片、智能机器人等领域带来更多创新。<br>对于个人而言，在技术迭代加速的时代，被动等待意味着淘汰，持续学习跨领域技能（如 AI 工程优化）将成为核心竞争力。在这场 AI 与硬科技的全球博弈中，唯一不变的是变化本身。唯有保持开放与敏捷，才能在颠覆性浪潮中锚定自己的坐标。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>闲话漫谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Streamlit与DeepSeek API快速构建Chat应用</title>
    <link href="/2025/01/27/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/streamlit%20%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20deepseek%20%E5%AF%B9%E8%AF%9D%E5%BA%94%E7%94%A8/"/>
    <url>/2025/01/27/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/streamlit%20%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%20deepseek%20%E5%AF%B9%E8%AF%9D%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>最近 deepseek 很火，其提供的 API 调用便捷性以及极具竞争力的价格（尤其是对中国用户赠送 10 元体验金），使得个人和小型企业也能轻松接入大模型服务。本文将介绍如何利用 Streamlit 框架快速搭建一个基于 DeepSeek API 的聊天机器人应用。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li>确保已经注册并获取了 DeepSeek 的 API Key。</li><li>安装必要的 Python 库：<code>streamlit</code> 和 <code>openai</code>。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st  <br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI  <br><span class="hljs-keyword">from</span> streamlit <span class="hljs-keyword">import</span> secrets  <br>  <br><span class="hljs-comment"># 设置页面标题  </span><br>st.title(<span class="hljs-string">&quot;💬 DeepSeek Chatbot&quot;</span>)  <br>  <br><span class="hljs-comment"># 在侧边栏添加配置选项  </span><br><span class="hljs-keyword">with</span> st.sidebar:  <br>    <span class="hljs-comment"># 提供一个文本输入框让用户可以手动输入API Key（可选）  </span><br>    openai_api_key = st.text_input(<span class="hljs-string">&quot;DeepSeek API Key&quot;</span>, key=<span class="hljs-string">&quot;chatbot_api_key&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;password&quot;</span>)  <br>    <span class="hljs-string">&quot;[获取 DeepSeek API key](https://platform.deepseek.com/api_keys)&quot;</span>  <br>    <span class="hljs-keyword">if</span> st.button(<span class="hljs-string">&quot;开启新对话&quot;</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-keyword">in</span> st.session_state <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(st.session_state.messages) &gt; <span class="hljs-number">0</span>:  <br>            <span class="hljs-comment"># 保存当前对话到历史对话列表  </span><br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;history_conversations&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:  <br>                st.session_state.history_conversations = []  <br>            st.session_state.history_conversations.append(st.session_state.messages)  <br>            st.session_state.messages = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;欢迎使用对话机器人，你想知道什么?&quot;</span>&#125;]  <br>  <br>  <br>    <span class="hljs-comment"># 显示历史对话列表  </span><br>    st.subheader(<span class="hljs-string">&quot;历史对话&quot;</span>)  <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;history_conversations&quot;</span> <span class="hljs-keyword">in</span> st.session_state:  <br>        <span class="hljs-keyword">for</span> idx, conv <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(st.session_state.history_conversations):  <br>            <span class="hljs-keyword">if</span> st.button(<span class="hljs-string">f&quot;对话 <span class="hljs-subst">&#123;idx + <span class="hljs-number">1</span>&#125;</span>&quot;</span>, key=<span class="hljs-string">f&quot;load_conv_<span class="hljs-subst">&#123;idx&#125;</span>&quot;</span>):  <br>                st.session_state.messages = conv  <br>                <span class="hljs-comment"># st.success(f&quot;成功加载对话 &#123;idx + 1&#125;&quot;)  </span><br><span class="hljs-comment"># 如果用户没有提供API Key，则尝试从secrets.toml文件中获取  </span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> openai_api_key:  <br>    <span class="hljs-keyword">try</span>:  <br>        openai_api_key = secrets.deepseek_api.key  <br>    <span class="hljs-keyword">except</span> AttributeError:  <br>        <span class="hljs-keyword">pass</span>  <span class="hljs-comment"># 如果在secrets.toml中找不到API Key，则保持openai_api_key为空  </span><br>  <br><span class="hljs-comment"># 检查API Key是否已提供  </span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> openai_api_key:  <br>    st.info(<span class="hljs-string">&quot;请添加新的API Key&quot;</span>)  <br><span class="hljs-keyword">else</span>:  <br>    base_url = <span class="hljs-string">&quot;https://api.deepseek.com&quot;</span>  <br>    client = OpenAI(api_key=openai_api_key, base_url=base_url)  <br>  <br>    <span class="hljs-comment"># 初始化对话历史记录  </span><br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;messages&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:  <br>        st.session_state.messages = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;欢迎使用对话机器人，你想知道什么?&quot;</span>&#125;]  <br>  <br>    <span class="hljs-comment"># 显示对话历史  </span><br>    <span class="hljs-keyword">for</span> msg <span class="hljs-keyword">in</span> st.session_state.messages:  <br>        st.chat_message(msg[<span class="hljs-string">&quot;role&quot;</span>]).write(msg[<span class="hljs-string">&quot;content&quot;</span>])  <br>  <br>    <span class="hljs-comment"># 获取用户输入  </span><br>    <span class="hljs-keyword">if</span> prompt := st.chat_input():  <br>        st.session_state.messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;)  <br>        st.chat_message(<span class="hljs-string">&quot;user&quot;</span>).write(prompt)  <br>  <br>        <span class="hljs-comment"># 调用DeepSeek API  </span><br>        response = client.chat.completions.create(  <br>            model=<span class="hljs-string">&quot;deepseek-chat&quot;</span>,  <br>            messages=st.session_state.messages,  <br>            stream=<span class="hljs-literal">False</span>  <br>        )  <br>        assistant_reply = response.choices[<span class="hljs-number">0</span>].message.content  <br>        st.session_state.messages.append(&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;assistant&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: assistant_reply&#125;)  <br>        st.chat_message(<span class="hljs-string">&quot;assistant&quot;</span>).write(assistant_reply)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501270910376.png" alt="image.png"></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>以上代码实现了调用 API key 和构建对话界面，将密码放在了.streamlit 文件夹的 secrets.toml 里面。用户也可以在界面上输入 API key。<br>利用 session_state 记录历史对话，知识暂存记录，没有加入数据库，所以重新加载就会失效。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过上述步骤，我们成功创建了一个简易但功能齐全的聊天机器人应用。尽管市面上存在多种无需编程即可调用 API 的服务，如 Chatbox 或 AnythingLLM 等，但自己动手构建不仅能更好地满足个性化需求，还能加深对技术的理解。DeepSeek 凭借其性价比优势，极大地降低了 AI 应用的门槛，为个人开发者提供了广阔的创意空间。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 同步部署服务器和GitHub 超详细教程</title>
    <link href="/2025/01/24/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/hexo%20%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CGitHub%20%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/"/>
    <url>/2025/01/24/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/hexo%20%E5%90%8C%E6%AD%A5%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8CGitHub%20%E8%B6%85%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>之前用Hexo、GitHub Pages、netlify 搭建并托管我的个人博客。尽管这种方式极为便捷，但国内访问速度时常受限。最近买了个服务器，刚好学习 Linux 和 Web 部署的相关知识，本文记录下hexo 如何同步部署服务器和GitHub。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol><li>实现博客内容同时推送到GitHub和阿里云服务器。</li><li>掌握宝塔面板的基础网站配置方法。</li><li>学习Nginx 基础配置技巧。</li></ol><h2 id="基础条件"><a href="#基础条件" class="headerlink" title="基础条件"></a>基础条件</h2><ol><li>已在本地及GitHub上已成功搭建Hexo博客环境。</li><li>已有阿里云服务器。</li><li>已有域名和 SSL 证书。</li></ol><h2 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h2><h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><p>服务器端安装 git。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> git<br></code></pre></td></tr></table></figure><h3 id="创建博客文件夹"><a href="#创建博客文件夹" class="headerlink" title="创建博客文件夹"></a>创建博客文件夹</h3><p>服务器端创建文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> -p /blog/html<br></code></pre></td></tr></table></figure><p>设置正确的权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">chown</span> root:root /blog/html<br>sudo <span class="hljs-built_in">chmod</span> 755 /blog/html<br></code></pre></td></tr></table></figure><h3 id="创建-git-仓库"><a href="#创建-git-仓库" class="headerlink" title="创建 git 仓库"></a>创建 git 仓库</h3><p>在服务器端配置 git 仓库接收本地推送，注意设置一个全局分支名称，我的是 main。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/root</span><br>sudo git init <span class="hljs-params">--bare</span> blogit.git<span class="hljs-comment">#创建一个叫blogit的仓库</span><br>git config <span class="hljs-params">--global</span> init.defaultBranch main <span class="hljs-comment">#配置全局默认分支名</span><br><br></code></pre></td></tr></table></figure><h3 id="使用-hooks-实现自动部署"><a href="#使用-hooks-实现自动部署" class="headerlink" title="使用 hooks 实现自动部署"></a>使用 hooks 实现自动部署</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/root/</span>blogit.git<span class="hljs-regexp">/hooks/</span>post-receive<br></code></pre></td></tr></table></figure><p>创建一个钩子文件，将下面的内容，放在 post-receive 里。初学者建议学习下 vim 语法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>git --work-tree=/blog/html --git-dir=/root/blogit.git checkout -f main<br></code></pre></td></tr></table></figure><p>保存文件，给权限。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod +x <span class="hljs-regexp">/root/</span>blogit.git<span class="hljs-regexp">/hooks/</span>post-receive<br></code></pre></td></tr></table></figure><h4 id="vim-基本语法"><a href="#vim-基本语法" class="headerlink" title="vim 基本语法"></a>vim 基本语法</h4><p>点击 insert 切换模式，点击 esc 退出编辑模式，注意在英文输入法状态下才可以输入命令。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:wq</span> <span class="hljs-comment">#保存</span><br><span class="hljs-symbol">:%d</span> <span class="hljs-comment">#全部删除</span><br></code></pre></td></tr></table></figure><h3 id="修改-hexo-配置"><a href="#修改-hexo-配置" class="headerlink" title="修改 hexo 配置"></a>修改 hexo 配置</h3><p>在 hexo 的 <code>_config.yml</code> 文件deploy 设置中增加阿里云 git 信息。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">deploy:<br>  - type: git<br>    repository: git@github<span class="hljs-selector-class">.com</span>:<span class="hljs-selector-attr">[对应的项目名]</span><span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.git</span> #注意替换<span class="hljs-selector-attr">[]</span>内容<br>    branch: <span class="hljs-selector-tag">main</span><br>  - type: git<br>    repository: root@<span class="hljs-selector-attr">[域名]</span>:/root/blogit<span class="hljs-selector-class">.git</span> #注意替换<span class="hljs-selector-attr">[]</span>内容<br>    branch: main<br></code></pre></td></tr></table></figure><p>注意做这一步之前需要将本地电脑的公钥，放在服务器 authorized_keys 文件里。具体如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby">打开authorized_keys<br>vim ~<span class="hljs-regexp">/.ssh/authorized</span>_keys<br>使用inser 模式复制公钥内容，这里注意需要在本地建立公钥文件<br>英文模式下点击esc,命令行输入下面内容保存<br><span class="hljs-symbol">:wq</span><br></code></pre></td></tr></table></figure><p>这样就可以通过本地 ssh 连接服务器了，可以通过下面的代码测试是否连接成功。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">ssh <span class="hljs-symbol">root@</span>[域名]<br></code></pre></td></tr></table></figure><p>经过上述过程后，在本地文件夹 利用 hexo 三连，测试是否将博客同时发布到服务器和 GitHub。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501242034309.png" alt="成功同步"></p><h3 id="安装宝塔"><a href="#安装宝塔" class="headerlink" title="安装宝塔"></a>安装宝塔</h3><p>在阿里云里面可以重装带有宝塔的系统，也可以执行下面的命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> [ -f <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/curl ];then curl -sSO https:/</span><span class="hljs-regexp">/download.bt.cn/i</span>nstall<span class="hljs-regexp">/install_panel.sh;else wget -O install_panel.sh https:/</span><span class="hljs-regexp">/download.bt.cn/i</span>nstall/install_panel.sh;fi;bash install_panel.sh ed8484bec<br></code></pre></td></tr></table></figure><h3 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h3><p>进入宝塔页面，会推荐安装 nginx，其他工具的根据自己情况安装。</p><h3 id="配置-html-项目"><a href="#配置-html-项目" class="headerlink" title="配置 html 项目"></a>配置 html 项目</h3><p>由于我是用的 hexo 主题为 fulid 很多 css 用的是 https ，需要申请证书，如果没有添加证书，很多效果无法展示，因此需要在阿里云服务器里申请免费的 SSL 证书，个人证书只有 90 天的权限，具体步骤直接在服务器搜索，这里略过不提。</p><p>在宝塔内点击网址-html 项目-添加项目，添加域名、根目录信息，点击确定。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501242046940.png"></p><p>在新增的html网站项目里，点击部署 SSL 证书，将阿里云上的证书下载下来，把 key 和 pem 复制到对应的位置，点击确定即可。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501242050218.png"></p><p>用下面代码检查一下配置是否正常，若一切正常，重载配置，浏览域名就可以看到内容啦。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -t</span><br></code></pre></td></tr></table></figure><h3 id="nginx-配置"><a href="#nginx-配置" class="headerlink" title="nginx 配置"></a>nginx 配置</h3><p>用这种方法不用去折腾 nginx 配置，会自动生成，在宝塔网站管理界面可以看到，以下是示例，实际有 SSL 证书的会复杂一些。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  wenmao.xyz;  <span class="hljs-comment"># 替换为你的域名或IP地址</span><br>        <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">300</span>;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-attribute">chunked_transfer_encoding</span> <span class="hljs-literal">off</span>;<br><br>    <span class="hljs-attribute">root</span>   /blog/html;  <span class="hljs-comment"># 替换实际路径</span><br>    <span class="hljs-attribute">index</span>  index.html index.htm;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>    &#125;<br><br>    <span class="hljs-comment"># 访问日志和错误日志</span><br>    <span class="hljs-attribute">access_log</span>  /www/wwwlogs/hexo_blog_access.log;<br>    <span class="hljs-attribute">error_log</span>   /www/wwwlogs/hexo_blog_error.log;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>折腾了一圈，总算是成功了，这个过程中，基本熟悉了网站部署的流程，购买域名、备案、设置证书，宝塔、nginx 配置。第一次做感觉非常麻烦，完成之后梳理一遍觉得收获了不少，对 liunx、宝塔、1panel 更感兴趣了，另外过程中还进一步了解 hugo、astro、Docusaurus 等网站框架的部署，对比之后还是坚持 obsidian+hexo 的笔记流程，理由是 obsidian 是我主力的笔记软件，不用更换文档的属性，不用更换文件夹，加上hexo 配置好后，三连配合GitHub page 或者netlify 可以非常方便的部署。</p><p>总之，整个过程主要的收获初步是了解了Linux 项目部署相关知识。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/weixin_44975887/article/details/117267259">https://blog.csdn.net/weixin_44975887/article/details/117267259</a></p><h2 id="已部署博客"><a href="#已部署博客" class="headerlink" title="已部署博客"></a>已部署博客</h2><p>欢迎收藏，有什么问题可以在公众号后留言~</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//wenmao.xyz/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//wenmaochen.netlify.app/</span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//maoyu92.github.io/</span><br></code></pre></td></tr></table></figure><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明  </p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
      <tag>Linux</tag>
      
      <tag>云服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当下的力量 读书笔记</title>
    <link href="/2025/01/10/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/10/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%BD%93%E4%B8%8B%E7%9A%84%E5%8A%9B%E9%87%8F%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 当下的力量（白金版）</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/2/YueWen_848673/t7_YueWen_848673.jpg" alt=" 当下的力量（白金版）|200"></li><li>书名： 当下的力量（白金版）</li><li>作者： 埃克哈特·托利</li><li>简介： 《当下的力量（白金版）》堪称心灵读物经典，作者埃克哈特·托利指出了我们日常痛苦的主要来源——被大脑思维所控制、焦虑过去和未来而非活在当下。但实际上，我们只能活在当下，活在此时此刻。通过向当下的臣服，你才能找到真正的力量，获得内在的智慧和真正的喜悦。作者在《当下的力量》中提出了几个非常实用的方法，让自己认清时间的幻象，活在当下。《当下的力量》对于普遍焦虑、抑郁、压力大的现代大众读者来说，是一本切实有用的好书，将让我们认清时间的幻象，活在当下，找到真正的力量，发现平和与宁静的入口。</li><li>出版时间 2016-06-01 00:00:00</li><li>ISBN： 9787508661766</li><li>分类： 个人成长-励志成长</li><li>出版社： 中信出版集团</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/5b932bd05cf3215b92b7cd5">https://weread.qq.com/web/reader/5b932bd05cf3215b92b7cd5</a></li></ul></blockquote><p>这是一本既具挑战性又充满启发性的书。开篇部分可能会让一些读者感到疏远，尤其是对书中涉及的“开悟”、“临在”等概念不熟悉的读者。然而，随着阅读的深入，你会发现这些理念并非遥不可及，而是与诸如阿德勒心理学、禅宗思想有着深刻的共鸣。</p><h2 id="什么是开悟"><a href="#什么是开悟" class="headerlink" title="什么是开悟"></a>什么是开悟</h2><p>开悟是一种简单的与本体合一的自然状态，佛陀定义为”受苦的终结”。什么是本体？是最深的自我和真实的本质，在静下来，注意力集中在当下时刻时，能够感受到本体，感受到本体，并保持觉知状态就是开悟。</p><h2 id="思维与观察思考"><a href="#思维与观察思考" class="headerlink" title="思维与观察思考"></a>思维与观察思考</h2><p>这里的”思维”，“思考”，我的理解是平常的胡思乱想，或者杂念，我们无时无刻不在思考，笛卡尔说“我思故我在”，但不停的思考引起各种情绪，例如焦虑、渴望愤怒等等，带来痛苦，让我们不能达到内心宁静状态。开悟不仅是痛苦和身心内外冲突的终结，也是思考的终结。<br>如何摆脱不停的思考状态，就是做一个”观察思考者”，倾听大脑的声音，不去做任何评判。当你在观察你的思考时，就是一种自我存在的感觉而不是思维，超越了思维。这就是”临在”（无念）状态。</p><h2 id="无意识状态"><a href="#无意识状态" class="headerlink" title="无意识状态"></a>无意识状态</h2><p>普通的无意识状态指的是你认同于你的思考过程、情绪、反应、欲望和好恶。就是在日常的条件反射下的状态，包括本能反应和习惯性反应。当事情出差错了或自我受到威胁了，当生活中遇到巨大的挑战、威胁或损失（无论是真实的还是想象的）​，或当你的亲密关系发生冲突时，普通无意识的不安状态会转变为深层无意识的痛苦——这是一种更为剧烈、更为明显的痛苦或不幸的状态。<br>瓦解无意识状态的方法是观察与反思，通过练习，你自我观察的能力以及监控你内在状态的力量将会得到加强。</p><h2 id="应对思维的策略"><a href="#应对思维的策略" class="headerlink" title="应对思维的策略"></a>应对思维的策略</h2><p>面对无意思状态下的痛苦情况，有三种选择：”逃避”、“改变”、“接受”，做出了选择就要接受并坚持。<br>压力的产生是由于你在“这里”却想到“那里”去，或你在当下却想去未来。这是一种让内在分裂的方式。<br>当你工作、跑步时，全力地去做吧。充分享受能量的流动以及那个时刻的高能量。<br>不要沉湎于过去，不要寄希望于未来，不要等待，从现在开始，感受现在的意识。</p><h2 id="如何进入临在状态"><a href="#如何进入临在状态" class="headerlink" title="如何进入临在状态"></a>如何进入临在状态</h2><p>进入临在状态之前，接受自己、接受、宽恕身边人的无意识状态，观察各种情绪：愤怒、恐惧、悲伤。</p><h2 id="开悟与爱情关系"><a href="#开悟与爱情关系" class="headerlink" title="开悟与爱情关系"></a>开悟与爱情关系</h2><p>爱情关系最开始相互需要、相互支持的，爱情关系是所有人际关系中最重要的关系之一，整个过程几乎包括所有的感受，喜、怒、哀、乐，在爱情中修行，接受对方的无意思状态，观察自己的无意思状态，你的开悟不需要去等待这个世界变得明智，或别人变得有意识。不要相互指责对方的无意识行为。<br>学会在不责备对方的情况下表达你的感受，学会用一种开放的、非防御性的方式倾听你伴侣说话。</p><h2 id="开悟与痛苦"><a href="#开悟与痛苦" class="headerlink" title="开悟与痛苦"></a>开悟与痛苦</h2><p>事物有起起伏伏、荣枯、上升下降、出生死亡、一切都是自然的，没有必要为了下降阶段而感到悲伤。往往在痛苦或者低谷时，自我观察，更容易进入开悟状态，或许王阳明的龙场悟道</p><h2 id="冥想练习"><a href="#冥想练习" class="headerlink" title="冥想练习"></a>冥想练习</h2><ol><li>日常专注于当下：每次你在家中或办公室上下楼梯时，你每一步、每一刻，甚至每一次呼吸时都全神贯注，完全集中你的注意力。或者当你洗手时，关注与洗手有关的所有感觉：水的声音和感觉、手的运动、肥皂的香味等。</li><li>晚上临睡前和早晨起床的时间，请让意识流遍你的全身。闭上眼睛，平躺着。首先将注意力轮流集中在你身体的不同部位——双手、双脚、手臂、大腿、腹部、胸部、头部等。</li><li>确保身体的放松，闭上眼睛，深呼吸几次。在你呼吸时，请感受下腹部轻微的收缩与扩张。然后，请关注你整个身体内的能量场。别去思考它——感受它就可以了。</li></ol><p>我个人感觉最好的状态是在一个自然环境非常好的地方，静静的坐下来，感受风吹和树林的声音。坐姿采用敦煌莫高窟交脚菩萨的坐姿最舒服。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501101728487.jpg" alt="《灿烂敦煌》 第275窟 交脚菩萨"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当下的力量主要是告诉我们，与自己和解、与亲密关系和解、与过去与未来和解、与世界和解，通过观察自己的状态，呼吸练习，时刻保持“临在”（无念），活在当下，注重过程，最终达到内心宁静的状态。这是循序渐进的过程，也是需要刻意练习的过程，可能刚开始需要很长时间才能进入状态，或者保持不了多久，但是通过练习，我们就能逐渐控制自己的情绪，减少压力，提高注意力和精力。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>盘点快速了解就能开启新世界大门的技能</title>
    <link href="/2025/01/09/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E7%9B%98%E7%82%B9%E7%9F%AD%E6%97%B6%E5%AD%A6%E4%B9%A0%E4%BD%86%E6%89%93%E5%BC%80%E6%96%B0%E4%B8%96%E7%95%8C%E5%A4%A7%E9%97%A8%E7%9A%84%E6%8A%80%E8%83%BD/"/>
    <url>/2025/01/09/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E7%9B%98%E7%82%B9%E7%9F%AD%E6%97%B6%E5%AD%A6%E4%B9%A0%E4%BD%86%E6%89%93%E5%BC%80%E6%96%B0%E4%B8%96%E7%95%8C%E5%A4%A7%E9%97%A8%E7%9A%84%E6%8A%80%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在当今这个信息爆炸的时代，我们常常会发现有无数的新知识和技能等待着我们去探索。然而，并不是所有的学习都需要花费大量的时间才能见到成效。有些技能只需要短短几个小时的学习，就能为我们的生活和工作带来巨大的改变。今天，我们就来聊聊那些只需投入少量时间便能学会、但却能打开新世界大门的技能。</p><h2 id="1-思维导图：整理思路的艺术"><a href="#1-思维导图：整理思路的艺术" class="headerlink" title="1. 思维导图：整理思路的艺术"></a>1. 思维导图：整理思路的艺术</h2><p>思维导图可能是这几项技能中最容易入门的一个。通过简单的图形和线条，我们可以将复杂的概念和想法清晰地展示出来，帮助自己更好地梳理思路、组织信息。无论是用于学习笔记、项目规划还是日常思考，思维导图都能让你事半功倍。而且，随着对思维导图工具（如XMind、MindMaster等）的进一步熟悉，你会发现自己的创造力也在不断提升。</p><p><strong>推荐理由</strong>：提高效率，激发创意，适合所有人。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501090927753.png" alt="image.png"></p><h2 id="2-Git-GitHub：程序员的最佳伴侣"><a href="#2-Git-GitHub：程序员的最佳伴侣" class="headerlink" title="2. Git&#x2F;GitHub：程序员的最佳伴侣"></a>2. Git&#x2F;GitHub：程序员的最佳伴侣</h2><p>对于任何想要进入编程领域的人来说，Git 和 GitHub 是绝对不能错过的工具。Git 几行代码就能轻松实现代码版本控制，而 GitHub 则提供了丰富的开源资源，让你能够站在巨人的肩膀上学习和成长。通过参与 GitHub 上的开源项目，你不仅能学到实用的技术，还能结识志同道合的朋友，共同进步。</p><p><strong>推荐理由</strong>：代码管理神器，社区资源丰富。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501090929694.png" alt="image.png"></p><h2 id="3-Markdown：专注内容创作的文本格式"><a href="#3-Markdown：专注内容创作的文本格式" class="headerlink" title="3. Markdown：专注内容创作的文本格式"></a>3. Markdown：专注内容创作的文本格式</h2><p>Markdown 的魅力在于它让写作者可以完全专注于内容本身，而无需担心格式问题。作为一种轻量级标记语言，Markdown 支持几乎所有主流的文本编辑器和平台。更重要的是，它与许多现代知识管理和协作工具（如Notion、思源笔记、语雀、Obsidian）完美兼容，非常适合构建个人知识库。</p><p><strong>推荐理由</strong>：简洁高效，易于分享，适应多种场景。</p><h2 id="4-ChatGPT及类似AI助手：未来的智能伙伴"><a href="#4-ChatGPT及类似AI助手：未来的智能伙伴" class="headerlink" title="4. ChatGPT及类似AI助手：未来的智能伙伴"></a>4. ChatGPT及类似AI助手：未来的智能伙伴</h2><p>ChatGPT 的出现标志着人工智能技术进入了新的阶段。只需花几分钟了解其基本操作，你就会被它的多功能性和趣味性所吸引。从写作助手到语言翻译，再到数据分析支持，ChatGPT 及其同类产品（如通义千问、Coze、Kimi、Ollama、Dify等）正在各个领域展现出无限潜力。它们不仅提高了工作效率，也为创新提供了更多可能。</p><p><strong>推荐理由</strong>：多功能应用，提升效率。</p><h2 id="5-Python：万能钥匙般的编程语言"><a href="#5-Python：万能钥匙般的编程语言" class="headerlink" title="5. Python：万能钥匙般的编程语言"></a>5. Python：万能钥匙般的编程语言</h2><p>Python 因其语法简洁、功能强大而广受欢迎。无论你是想从事数据分析、机器学习、Web开发还是自动化脚本编写，Python 都能胜任。此外，庞大的第三方库生态系统使得 Python 成为了一个真正的“瑞士军刀”，几乎能满足所有编程需求。对于初学者来说，Python 是一个理想的起点；而对于专业人士而言，它则是不可或缺的工具。</p><p><strong>推荐理由</strong>：入门门槛低，应用范围广，持续学习价值高。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这些技能虽然看似简单，但一旦掌握，它们将会成为你通往更广阔世界的桥梁。不论是提高工作效率，还是拓宽视野，这五项技能都值得每个人去尝试和学习。</p><p>最后如果你发现有类似的工具请留言告诉我，谢谢~</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> AI 辅助 制作 年终总结PPT</title>
    <link href="/2025/01/03/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%20%E8%BE%85%E5%8A%A9%20%E5%88%B6%E4%BD%9C%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93PPT/"/>
    <url>/2025/01/03/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%20%E8%BE%85%E5%8A%A9%20%E5%88%B6%E4%BD%9C%20%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93PPT/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>当下AI 已然深度融入并不可避免地改变我们的生活。岁末年终，又到了总结复盘时刻，今天就用通义千问辅助年终总结ppt制作，看看它究竟能带来怎样的效果。</p><p>以往我们做 PPT 是先拟好大纲，然后直接使用 PPT 制作，现在的流程更新为，先制作大纲 markdown 大纲文件，然后用 AI 进行优化，导入各种 AI PPT 工具生成初步草稿，再进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs d2">direction: right<br>制作大纲 -&gt; AI 优化 -&gt; AI PPT生成 -&gt; PPT修改<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501071557394.png" alt="PPT制作流程"></p><h2 id="1-制作大纲文件"><a href="#1-制作大纲文件" class="headerlink" title="1.制作大纲文件"></a>1.制作大纲文件</h2><p>首先梳理思路，整理出 markdown 格式的大纲文件。大纲内容包括了 PPT 的<strong>汇报内容</strong>、<strong>页面框架</strong>、<strong>设计建议</strong>，以下是示例文件。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean">##  <span class="hljs-number">1.</span>封面（第<span class="hljs-number">1</span>页）<br>- **项目名称**：<br>- **汇报人**：<br>- **日期**：<span class="hljs-number">2024</span> 年 <span class="hljs-number">12</span> 月<br>## <span class="hljs-number">2.</span>目录（第<span class="hljs-number">2</span>页）<br>- 工作回顾<br>- 工作总结<br>- 思考与展望<br>## <span class="hljs-number">3.</span>工作回顾（第<span class="hljs-number">3</span>页）<br>### <span class="hljs-number">3.1</span> ***项目（第<span class="hljs-number">4</span>~<span class="hljs-number">5</span>页）<br>#### <span class="hljs-number">3.1</span><span class="hljs-number">.1</span> 服务内容（第<span class="hljs-number">4</span>页）<br>（服务体系）<br>快报、专题报告、现场调查<br>通过数据分析、现场调查，给业主提供全方位的服务<br>#### <span class="hljs-number">3.1</span><span class="hljs-number">.2</span>工作亮点及成效（第<span class="hljs-number">5</span>页）<br>- 全年达标<br>### <span class="hljs-number">3.2</span> ***项目（第<span class="hljs-number">6</span>~<span class="hljs-number">7</span>页）<br>#### <span class="hljs-number">3.2</span><span class="hljs-number">.1</span> 服务内容（第<span class="hljs-number">6</span>页）<br>#### <span class="hljs-number">3.2</span><span class="hljs-number">.2</span> 工作亮点及成效（第<span class="hljs-number">7</span>页）<br>- 得到认可<br>## <span class="hljs-number">4.</span>工作总结（第<span class="hljs-number">8</span>页）<br>- 收获<br>- []<br>- 存在的问题（第<span class="hljs-number">9</span>页）<br>- <br>- <br>## <span class="hljs-number">5.</span>工作计划及展望（第<span class="hljs-number">10</span>页）<br>- <br>-  <br>## <span class="hljs-number">6.</span>谢谢（第<span class="hljs-number">11</span>页）<br><br>## 设计建议：<br>- **视觉设计**：每一页PPT应保持简洁明了，使用统一的配色方案和字体，确保信息传达清晰。<br>- **图表与图片**：适当添加图表、图片，增强视觉效果和说服力。<br>- **关键词突出**：重要信息可以通过加粗、变色等方式突出显示，吸引观众的注意力。<br><br></code></pre></td></tr></table></figure><h2 id="2-AI-优化提示词"><a href="#2-AI-优化提示词" class="headerlink" title="2. AI 优化提示词"></a>2. AI 优化提示词</h2><p>在准备好大纲后，可以将其交给AI助手如通义千问，与之沟通确认页面内容及分页布局是否合理。通过 AI 优化提示词，确认无误后点击 PPT 创作。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501071141171.png" alt="image.png"></p><h2 id="3-AI-PPT生成"><a href="#3-AI-PPT生成" class="headerlink" title="3. AI PPT生成"></a>3. AI PPT生成</h2><p>在下一页面进一步修改大纲，建议在上一个页面就将框架及页面结构通过文字沟通清楚，选择合适的 PPT 类型和模板，确认后即可得到 PPT 初稿。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202501031340336.png" alt="image.png"></p><h2 id="4-PPT-修改与完善"><a href="#4-PPT-修改与完善" class="headerlink" title="4. PPT 修改与完善"></a>4. PPT 修改与完善</h2><p>对生成的PPT进行细节上的调整，包括文字编辑、图示优化等，直到满意为止。<br>以上只是一个简单的流程介绍，其他产品比如 kimi 也免费支持 PPT 创作功能，都大同小异，建议选择自己喜欢的多尝试一下。如果有更好的方法也请留言告诉我，感谢~。<br>祝大家新年快乐，工作顺心。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>办公技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-docx 制作水质月报</title>
    <link href="/2024/12/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python-docx%20%E5%88%B6%E4%BD%9C%E6%B0%B4%E8%B4%A8%E6%9C%88%E6%8A%A5/"/>
    <url>/2024/12/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python-docx%20%E5%88%B6%E4%BD%9C%E6%B0%B4%E8%B4%A8%E6%9C%88%E6%8A%A5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在鼓捣用 python 制作水质分析月报，感觉还是蛮好玩的，对于一些高频的报告还是比较好用的，只要定好思路，做好模板，以后只需要更新数据表，然后运行代码就可以了。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>安装关键库 python-docx</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pip install python-docx -i https:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/pypi/</span>simple<br></code></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><strong>导入库和加载数据</strong><br>在开始之前，我们需要导入所需的库，并加载我们要分析的数据集。这通常包括站点信息和水质监测数据。</li><li><strong>数据预处理</strong></li></ol><ul><li>将日期列转换为 <code>datetime</code> 类型以方便时间筛选。</li><li>根据给定的月份筛选出当月的数据。</li><li>合并来自不同来源的数据（如站点信息和水质数据）。</li></ul><ol start="3"><li><strong>统计分析</strong></li></ol><ul><li>计算各项水质指标的统计数据。</li><li>比较当前月份与去年同期的数据变化。</li><li>分析水质等级分布情况。</li></ul><ol start="5"><li><strong>图表生成</strong></li></ol><ul><li>使用 <code>matplotlib</code> 生成饼图、柱状图和折线图等，直观展示水质状况和趋势。</li><li>保存生成的图表到本地文件系统，以便后续插入到 Word 文档中。</li></ul><ol start="6"><li><strong>文档创建与编辑</strong></li></ol><ul><li>创建一个新的 Word 文档或打开现有的模板。</li><li>添加标题、段落、表格和图片到文档中。</li><li>设置文本样式和对齐方式，确保文档的专业性和可读性。</li><li>保存最终的 Word 文档。</li></ul><h2 id="示例代码解析"><a href="#示例代码解析" class="headerlink" title="示例代码解析"></a>示例代码解析</h2><p>以下简化版代码片段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docx <span class="hljs-keyword">import</span> Document<br><span class="hljs-keyword">from</span> docx.shared <span class="hljs-keyword">import</span> Pt, Inches<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 加载数据</span><br>site_df = pd.read_excel(<span class="hljs-string">&#x27;datas/site_info.xlsx&#x27;</span>)<br>water_quality_df = pd.read_excel(<span class="hljs-string">&#x27;datas/Water_quality_monitoring_data.xlsx&#x27;</span>)<br>Month = <span class="hljs-string">&#x27;2024-06&#x27;</span><br><br><span class="hljs-comment"># 数据预处理</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_monthly_data</span>(<span class="hljs-params">month, df</span>):<br>    df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br>    <span class="hljs-keyword">return</span> df[df[<span class="hljs-string">&#x27;监测时间&#x27;</span>].dt.strftime(<span class="hljs-string">&#x27;%Y-%m&#x27;</span>) == month]<br><br><span class="hljs-comment"># 统计分析</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_water_quality_stats</span>(<span class="hljs-params">df</span>):<br>    <span class="hljs-comment"># 这里省略了具体的统计计算过程</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 图表生成</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_pie_chart</span>(<span class="hljs-params">grade_counts, save_path=<span class="hljs-string">&#x27;water_quality_pie.png&#x27;</span></span>):<br>    plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>    plt.pie(grade_counts, labels=grade_counts.index, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>)<br>    plt.savefig(save_path)<br>    plt.close()<br><br><span class="hljs-comment"># df数据转换表格</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_table_to_doc</span>(<span class="hljs-params">df, document</span>):<br>    table = document.add_table(rows=<span class="hljs-number">1</span>, cols=<span class="hljs-built_in">len</span>(df.columns))<br>    <span class="hljs-keyword">for</span> j, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(df.columns):<br>        table.cell(<span class="hljs-number">0</span>, j).text = <span class="hljs-built_in">str</span>(column)<br>    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> df.iterrows():<br>        row_cells = table.add_row().cells<br>        <span class="hljs-keyword">for</span> j, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(row):<br>            row_cells[j].text = <span class="hljs-built_in">str</span>(value)<br><br><span class="hljs-comment"># 主函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    document = Document()<br>    monthly_data = get_monthly_data(Month, water_quality_df)<br>    merged_data = pd.merge(monthly_data, site_df, on=<span class="hljs-string">&#x27;断面名称&#x27;</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br>    <span class="hljs-comment"># 添加标题</span><br>    document.add_heading(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Month&#125;</span>水质月报&#x27;</span>, level=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 添加表格</span><br>    add_table_to_doc(merged_data, document)<br>    <span class="hljs-comment"># 添加统计结果</span><br>    result_text, grade_counts = calculate_water_quality_stats(merged_data)<br>    document.add_paragraph(result_text)<br>    <span class="hljs-comment"># 添加图表</span><br>    create_pie_chart(grade_counts)<br>    document.add_picture(<span class="hljs-string">&#x27;water_quality_pie.png&#x27;</span>, width=Inches(<span class="hljs-number">6</span>))<br>    <span class="hljs-comment"># 保存文档</span><br>    document.save(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;Month&#125;</span>_monthly_report.docx&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>按照上面的步骤基本就能够做出一个月报了，尝试了一段时间发现并没有 word 、excel 直接编辑方便，好处就是对于一些固定格式的文档可以节约很多精力。<br>用了 python-docx 后发现，还有一个包也很强大-docxtpl，充分结合了 word 、excel 和 python 的优势，可以批量制作文档，docxtpl 也是基于 python-docx 的，只能说对于重复报告，更加擅长吧。<br>后面有应用场景的话，我也会边用边记录一下。</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412201646549.png" alt="image.png"></p><p>从预览效果也可看出，还是非常简陋的，只进行了，简单的表格、图片、文字插入，还有很多可以丰富的，只是 python 可以将画图、计算自动化，也是非常节约时间了。</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="创建一个新的-Word-文档"><a href="#创建一个新的-Word-文档" class="headerlink" title="创建一个新的 Word 文档"></a>创建一个新的 Word 文档</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docx <span class="hljs-keyword">import</span> Document<br><br><span class="hljs-comment"># 创建一个新的Document对象</span><br>document = Document()<br><span class="hljs-comment"># 读取本地文档</span><br>document = Document(<span class="hljs-string">&#x27;datas/Monthly_report_template.docx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="插入段落"><a href="#插入段落" class="headerlink" title="插入段落"></a>插入段落</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加一个段落</span><br>paragraph = document.add_paragraph(<span class="hljs-string">&#x27;这是一个新的段落。&#x27;</span>)<br><br><span class="hljs-comment"># 在指定段落后插入新段落</span><br>new_paragraph = paragraph.insert_paragraph_before(<span class="hljs-string">&#x27;这是插入的新段落。&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="修改段落样式"><a href="#修改段落样式" class="headerlink" title="修改段落样式"></a>修改段落样式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docx.shared <span class="hljs-keyword">import</span> Pt<br><span class="hljs-keyword">from</span> docx.enum.text <span class="hljs-keyword">import</span> WD_PARAGRAPH_ALIGNMENT<br><br><span class="hljs-comment"># 设置段落格式</span><br>paragraph.alignment = WD_PARAGRAPH_ALIGNMENT.CENTER  <span class="hljs-comment"># 居中对齐</span><br>paragraph.style = <span class="hljs-string">&#x27;Heading 1&#x27;</span>  <span class="hljs-comment"># 应用标题1样式</span><br><br><span class="hljs-comment"># 设置字体大小和类型</span><br>run = paragraph.add_run(<span class="hljs-string">&#x27;这是加粗并改变字体大小的文本。&#x27;</span>)<br>run.bold = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 加粗</span><br>run.italic = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 斜体</span><br>run.underline = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 下划线</span><br>run.font.size = Pt(<span class="hljs-number">20</span>)  <span class="hljs-comment"># 设置字体大小为20磅</span><br>run.font.name = <span class="hljs-string">&#x27;Arial&#x27;</span>  <span class="hljs-comment"># 设置字体名称为Arial</span><br></code></pre></td></tr></table></figure><h3 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加一个3行4列的表格</span><br>table = document.add_table(rows=<span class="hljs-number">3</span>, cols=<span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 设置表格样式</span><br>table.style = <span class="hljs-string">&#x27;Table Grid&#x27;</span><br><br><span class="hljs-comment"># 填充表格内容</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        table.cell(i, j).text = <span class="hljs-string">f&#x27;Row <span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>, Col <span class="hljs-subst">&#123;j+<span class="hljs-number">1</span>&#125;</span>&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> docx.shared <span class="hljs-keyword">import</span> Inches<br><br><span class="hljs-comment"># 插入图片，宽度为6英寸</span><br>document.add_picture(<span class="hljs-string">&#x27;example.png&#x27;</span>, width=Inches(<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><h3 id="添加页眉和页脚"><a href="#添加页眉和页脚" class="headerlink" title="添加页眉和页脚"></a>添加页眉和页脚</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 获取第一节</span><br><span class="hljs-attr">section</span> = document.sections[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 添加页眉</span><br><span class="hljs-attr">5header</span> = section.header<br><span class="hljs-attr">6header_paragraph</span> = header.add_paragraph(<span class="hljs-string">&#x27;这是页眉文本。&#x27;</span>)<br><br><span class="hljs-comment"># 添加页脚</span><br><span class="hljs-attr">footer</span> = section.footer<br><span class="hljs-attr">footer_paragraph</span> = footer.add_paragraph(<span class="hljs-string">&#x27;这是页脚文本。&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="添加分页符"><a href="#添加分页符" class="headerlink" title="添加分页符"></a>添加分页符</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 添加分页符</span><br>document.add_page_break()<br></code></pre></td></tr></table></figure><h3 id="添加标题"><a href="#添加标题" class="headerlink" title="添加标题"></a>添加标题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加不同级别的标题</span><br>document.add_heading(<span class="hljs-string">&#x27;一级标题&#x27;</span>, level=<span class="hljs-number">1</span>)<br>document.add_heading(<span class="hljs-string">&#x27;二级标题&#x27;</span>, level=<span class="hljs-number">2</span>)<br>document.add_heading(<span class="hljs-string">&#x27;三级标题&#x27;</span>, level=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="添加编号或项目符号列表"><a href="#添加编号或项目符号列表" class="headerlink" title="添加编号或项目符号列表"></a>添加编号或项目符号列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加编号列表</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    paragraph = document.add_paragraph(<span class="hljs-string">f&#x27;编号项 <span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>)<br>    paragraph.style = <span class="hljs-string">&#x27;List Number&#x27;</span><br><br><span class="hljs-comment"># 添加项目符号列表</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    paragraph = document.add_paragraph(<span class="hljs-string">f&#x27;项目符号项 <span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>)<br>    paragraph.style = <span class="hljs-string">&#x27;List Bullet&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="保存文档"><a href="#保存文档" class="headerlink" title="保存文档"></a>保存文档</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存文档到文件</span><br>document.save(<span class="hljs-string">&#x27;output.docx&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h3><p>Style 非必选，默认有比较多的样式类型。普通网格表就用 Table Grid。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">table</span> = document.add_table(rows, cols,style=<span class="hljs-string">&#x27;Table Grid&#x27;</span>)<br></code></pre></td></tr></table></figure><p>Style 样式默认值</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Normal</span> <span class="hljs-built_in">Table</span><br><span class="hljs-built_in">Table</span> <span class="hljs-built_in">Grid</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Shading</span><br><span class="hljs-variable">Liqht</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Shading</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-variable">List1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">List</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">ColorfulShading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">ColorfulShading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Light</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">1</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">2</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-built_in">Medium</span> <span class="hljs-built_in">Grid</span> <span class="hljs-number">3</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-variable">Dark</span> <span class="hljs-built_in">List</span><br><span class="hljs-variable">Dark</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Dark</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Dark</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Dark</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Dight</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span><br><span class="hljs-variable">Dark</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Shading</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Shading</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">List</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">1</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">2</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">3</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">4</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">5</span><br><span class="hljs-variable">Colorful</span> <span class="hljs-built_in">Grid</span> <span class="hljs-variable">Accent</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><p><a href="https://blog.pangao.vip/python-docx%E5%A4%84%E7%90%86word%E6%96%87%E6%A1%A3/">https://blog.pangao.vip/python-docx%E5%A4%84%E7%90%86word%E6%96%87%E6%A1%A3/</a></p><p><a href="https://pydocx.readthedocs.io/en/latest/enumerated_list_detection.html">https://pydocx.readthedocs.io/en/latest/enumerated_list_detection.html</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>办公技巧 word 图片域转为图片</title>
    <link href="/2024/12/17/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%8A%9E%E5%85%AC%E6%8A%80%E5%B7%A7%20word%20%E6%89%B9%E9%87%8F%E5%B0%86%E5%9B%BE%E7%89%87%E5%9F%9F%E8%BD%AC%E4%B8%BA%E5%9B%BE%E7%89%87/"/>
    <url>/2024/12/17/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%8A%9E%E5%85%AC%E6%8A%80%E5%B7%A7%20word%20%E6%89%B9%E9%87%8F%E5%B0%86%E5%9B%BE%E7%89%87%E5%9F%9F%E8%BD%AC%E4%B8%BA%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前写过一篇利用 word 邮件功能实现批量生成带图片的文稿，其中有个问题没有解决-转出的 word 是图片域的集合，他有好有坏，好处就是动态更新，坏处就是不利于分享，在其他人的电脑上就会识别不到路径，图片无法显示。我尝试了很多办法，也没有找到批量将图片域转为图片的方式。今天介绍我目前用的笨办法，通过 vba 将选中的图片域转为图片。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>我是不会写 vba 的，下面的代码是利用 word 的录制宏功能，生成初步代码后，用 AI 软件优化而来。</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> ConvertFieldToInlinePicture()<br>    <span class="hljs-keyword">Dim</span> fld <span class="hljs-keyword">As</span> Field<br>    <span class="hljs-keyword">Dim</span> rng <span class="hljs-keyword">As</span> Range<br>    <span class="hljs-keyword">Dim</span> inlineShape <span class="hljs-keyword">As</span> inlineShape<br>    <br>    <span class="hljs-comment">&#x27; 检查是否有选中的域</span><br>    <span class="hljs-keyword">If</span> Selection.Fields.Count &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><br>        <span class="hljs-keyword">Set</span> fld = Selection.Fields(<span class="hljs-number">1</span>)        <br>        <span class="hljs-comment">&#x27; 将域结果复制到剪贴板</span><br>        fld.Result.Copy        <br>        <span class="hljs-comment">&#x27; 删除域</span><br>        fld.Delete        <br>        <span class="hljs-comment">&#x27; 粘贴并保留格式</span><br>        <span class="hljs-keyword">On</span> <span class="hljs-keyword">Error</span> <span class="hljs-keyword">Resume</span> <span class="hljs-keyword">Next</span> <span class="hljs-comment">&#x27; 忽略接下来的错误</span><br>        Selection.PasteAndFormat (wdChartPicture)<br>        <span class="hljs-keyword">If</span> Err.Number &lt;&gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span><br>            MsgBox <span class="hljs-string">&quot;无法将内容粘贴为内嵌图片。&quot;</span> &amp; vbCrLf &amp; <span class="hljs-string">&quot;错误代码: &quot;</span> &amp; Err.Number &amp; vbCrLf &amp; <span class="hljs-string">&quot;错误描述: &quot;</span> &amp; Err.Description, vbExclamation<br>            Err.Clear<br>            <span class="hljs-keyword">On</span> <span class="hljs-keyword">Error</span> <span class="hljs-keyword">GoTo</span> <span class="hljs-number">0</span> <span class="hljs-comment">&#x27; 停止忽略错误</span><br>            <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">Sub</span><br>        <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br>        <span class="hljs-keyword">On</span> <span class="hljs-keyword">Error</span> <span class="hljs-keyword">GoTo</span> <span class="hljs-number">0</span> <span class="hljs-comment">&#x27; 停止忽略错误     </span><br>        <span class="hljs-comment">&#x27; 如果需要，可以在这里添加对新内嵌图片的进一步处理</span><br>        <span class="hljs-comment">&#x27; 例如调整大小、设置环绕方式等</span><br>    <span class="hljs-keyword">Else</span><br>        MsgBox <span class="hljs-string">&quot;请先选择一个域。&quot;</span>, vbInformation<br>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span><br><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span><br><br></code></pre></td></tr></table></figure><p>将上面的代码，放入 vba 中，具体方法是开发工具-宏-创建，最好在所有活动文档中创建，这样都可以使用了。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412181526902.png" alt="image.png"></p><h2 id="宏赋按钮"><a href="#宏赋按钮" class="headerlink" title="宏赋按钮"></a>宏赋按钮</h2><p>通过开始-选项-快捷访问工具栏-宏-添加-修改名称和图标，创建好快捷图标。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412181528443.png" alt="image.png"></p><p>这样选中对应的图片域点击按钮就可以使用啦。</p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><p>也希望大家如果有更好的方法，请留言告诉我，或者对代码的改进建议，也请留言。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记_控糖革命</title>
    <link href="/2024/12/15/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD/"/>
    <url>/2024/12/15/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%8E%A7%E7%B3%96%E9%9D%A9%E5%91%BD/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 控糖革命</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/64/cpplatform_qpqefbrrjjgqq7t62wt1ca/t7_cpplatform_qpqefbrrjjgqq7t62wt1ca1706772686.jpg" alt=" 控糖革命|200"></li><li>书名： 控糖革命</li><li>作者： 【法】杰西·安佐斯佩</li><li>简介： 对于现代人来说，忙着减肥、忙着美肤、忙着健身，但同时失眠、焦虑、痤疮、糖尿病等亚健康问题又如影随形。法国“葡萄糖女神”、生物化学家杰西·安佐斯佩告诉你，这些亚健康问题往往都是由我们体内的血糖水平变化引起的，只是我们不自知而已。若置之不理，皮肤问题、情绪问题往往就会接踵而至，情况严重的话，更会引发 2 型糖尿病、多囊卵巢综合征等身体问题。</li><li>杰西·安佐斯佩在《控糖革命》一书中，提出了三个关键性的、颠覆常识的观点：</li><li><ol><li>不是只有糖尿病人才需要关心血糖，80%的现代人都有血糖方面的问题；</li></ol></li><li><ol start="2"><li>我们不只要控制血糖，更重要的是要控制血糖峰值的变化；</li></ol></li><li><ol start="3"><li>比节食更有效的控糖方法是改变吃的顺序。</li></ol></li><li>全书分为三大部分——为什么要控糖、出现葡萄糖峰值有哪些危害、轻松控糖的 10 个小窍门，通过 8 个章节，系统阐释了如何在不节食、不放弃我们喜爱的食物的情况下，用 10 个简单而令人惊讶的方法平衡我们的血糖水平，提升和改善我们的健康状况，包括睡眠、情绪、健康、皮肤、体重，甚至减缓衰老。</li><li>出版时间 2024-01-28 00:00:00</li><li>ISBN： 9787573908896</li><li>分类： 医学健康-健康</li><li>出版社： 浙江科学技术出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/819321e0813ab880ag01960c">https://weread.qq.com/web/reader/819321e0813ab880ag01960c</a></li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本书看的很快，知识点非常好总结，直接将大小标题列出来就可以了，作为控糖的基本知识真的非常好用。<br>最近周围亲戚接二连三的生病，各种癌症、糖尿病，读这本书的欲望更强烈了。<br>结合医生的建议和自身的一些体验，感觉书中提到的很多知识点是非常有益的，书中原理讲得很细，且配图和参考文献都非常全，这篇总结是书中的核心知识点，记录下来，以备自己查看和需要的人了解如何控糖。如果需要进一步了解，还是需要阅读原文。</p><h2 id="为什么要控糖"><a href="#为什么要控糖" class="headerlink" title="为什么要控糖"></a>为什么要控糖</h2><p>葡萄糖是人体能量来源之一，人类早期获取较难，现在各种科技水平提高，葡萄糖、蔗糖、果糖、淀粉获取过于容易，而易于吸收的糖的摄入会引起体内葡萄糖出现峰值。葡萄糖波动剧烈会对人体产生各种危害，所以要控糖。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412151554562.png" alt="一天的血糖波动"></p><h2 id="葡萄糖峰值的危害"><a href="#葡萄糖峰值的危害" class="headerlink" title="葡萄糖峰值的危害"></a>葡萄糖峰值的危害</h2><p>短期影响包括：持续的饥饿感；食欲旺盛；慢性疲劳；糟糕的睡眠；感冒；妊娠糖尿病；潮热和盗汗；偏头痛；记忆和认知问题；1 型糖尿病。<br>长期危害包括：痤疮和皮肤问题；衰老和关节炎；阿尔兹海默症和痴呆；癌症风险加大；精神障碍；心脏病；不孕症和多囊卵巢综合征；胰岛素低糖和 2 型糖尿病；非酒精性脂肪肝；皱纹和白内障。</p><p>反正就是危害相当大，我们需要尽量降低葡萄糖峰值和低估。</p><h2 id="控糖的-10-个小窍门"><a href="#控糖的-10-个小窍门" class="headerlink" title="控糖的 10 个小窍门"></a>控糖的 10 个小窍门</h2><ol><li>使用正确的饮食顺序：蔬菜-蛋白质-碳水；</li><li>餐前增加绿色开胃菜，细嚼慢咽，时间尽量长一点。</li><li>停止计算热量，因为不准，且无意义。</li><li>平稳早餐后的血糖</li><li>所有的糖都一样</li><li>餐后甜点（水果）而不是零食</li><li>吃饭前后 20 分钟喝 15 ml 的醋汁（兑热水满饮）</li><li>饭后运动（饭后 2 h 内，可以中等强度运动，可以阻抗运动）</li><li>零食选择咸香美味的（少糖，多蛋白质）</li><li>吃碳水前先吃蛋白质或者蔬菜，不要空腹吃碳水。</li></ol><h2 id="控糖饮食"><a href="#控糖饮食" class="headerlink" title="控糖饮食"></a>控糖饮食</h2><p>选择升糖慢的食物，少吃升糖快的食物，或者在吃升糖快的食物前，先吃升糖慢的食物。<br>低 GI 的蔬菜推荐：<br>芦笋、卷心菜，西葫芦、胡萝卜、西蓝花、甘蓝、茄子、莴苣、豌豆苗、番茄、绿豆芽、豆类；</p><p>更多可以参考食物 GI 值。</p><h2 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h2><p>选择低 GI 的食物、细嚼慢咽、注意食物顺序、饭后运动。</p><p>饮食习惯非常重要，默默的影响我们的一生，且难以察觉，因此养成好的习惯也可以让我们身体更加健康，精力更加充沛。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年 阅读与写作总结</title>
    <link href="/2024/12/09/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2024%E5%B9%B4%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%86%99%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/09/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2024%E5%B9%B4%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E5%86%99%E4%BD%9C%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>2024 年马上就要过去了，对这一年业余时间阅读和写作做一些总结。</p><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>2024 年的春节，我在新疆度过。冬季的伊犁比较冷，大部分时间我都待在室内，从那时起，我逐渐养成了持续阅读的习惯。起初，我的选择较为随意，多为历史书或小说以打发时间，后来，我开始认真读一些个人成长、教育学习等方面的书。</p><p>这一年对我影响最大的一本是《卡片笔记写作法：如何实现从阅读到写作》，书中写了很多关于如何学习，如何进行卡片笔记写作的方法，让我眼前一亮，尤其是尼克拉斯·卢曼的学习、写作经历，他强调要坚持记录笔记，可以是你感兴趣的任意方向，不要做计划，而是要做专家，也就是所在你短期感兴趣的领域持续发力，持续做笔记，然后再归纳整理，找到方向。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412281121052.png"></p><h3 id="阅读流水线"><a href="#阅读流水线" class="headerlink" title="阅读流水线"></a>阅读流水线</h3><p>2024 年看了很多书，按照时间顺序将他们梳理出来，推荐的有：</p><ul><li>卓有成效的管理者</li><li>自控力：斯坦福大学广受欢迎的心理学课程</li><li>在峡江的转弯处：陈行甲人生笔记</li><li>情商：为什么情商比智商更重要</li><li>掌控习惯：如何养成好习惯并戒除坏习惯（《原子习惯》中文版）（新版）</li><li>被讨厌的勇气：“自我启发之父”阿德勒的哲学课</li><li>正面管教（修订版）</li><li>宝贵的人生建议</li><li>锻炼</li><li>卡片笔记写作法：如何实现从阅读到写作</li><li>知道做到：跃迁式学习</li><li>《坛经》哲学王子带你领会人类最高智慧</li></ul><p>完整阅读记录如下。</p><table><thead><tr><th>书名</th><th>作者</th><th>开始阅读日期</th><th>推荐分数</th></tr></thead><tbody><tr><td>卓有成效的管理者</td><td>彼得·德鲁克</td><td>2024-11-23</td><td>5</td></tr><tr><td>情商：为什么情商比智商更重要</td><td>丹尼尔·戈尔曼</td><td>2024-10-23</td><td>5</td></tr><tr><td>全球通史：从史前到 21 世纪（第 7 版新校本上下册套装）</td><td>斯塔夫里阿诺斯</td><td>2024-10-13</td><td>4</td></tr><tr><td>自控力：斯坦福大学广受欢迎的心理学课程</td><td>凯利·麦格尼格尔</td><td>2024-10-03</td><td>5</td></tr><tr><td>西游记</td><td>吴承恩</td><td>2024-08-30</td><td>4</td></tr><tr><td>追问（独家首发）</td><td>丁捷</td><td>2024-08-28</td><td>2</td></tr><tr><td>我在北京送快递</td><td>胡安焉</td><td>2024-08-01</td><td>2</td></tr><tr><td>正面管教（修订版）</td><td>简•尼尔森</td><td>2024-07-28</td><td>5</td></tr><tr><td>人体简史</td><td>【英】比尔·布莱森</td><td>2024-07-24</td><td>3</td></tr><tr><td>周恩来的故事</td><td>石仲泉陈登才主编</td><td>2024-07-23</td><td>2</td></tr><tr><td>宝贵的人生建议</td><td>【美】凯文·凯利</td><td>2024-07-17</td><td>5</td></tr><tr><td>在峡江的转弯处：陈行甲人生笔记</td><td>陈行甲</td><td>2024-07-14</td><td>5</td></tr><tr><td>《坛经》哲学王子带你领会人类最高智慧!</td><td></td><td>2024-07-02</td><td>5</td></tr><tr><td>好运设计（独家首发）</td><td>史铁生</td><td>2024-06-20</td><td>3</td></tr><tr><td>被讨厌的勇气：“自我启发之父”阿德勒的哲学课</td><td>岸见一郎古贺史健</td><td>2024-06-17</td><td>5</td></tr><tr><td>锻炼</td><td>丹尼尔·利伯曼</td><td>2024-05-31</td><td>5</td></tr><tr><td>魏晋南北朝史（中国断代史系列）</td><td>王仲荦</td><td>2024-05-22</td><td>2</td></tr><tr><td>中国茶图鉴</td><td>李韬</td><td>2024-05-06</td><td>2</td></tr><tr><td>中国历代政治得失</td><td>钱穆</td><td>2024-04-26</td><td>2</td></tr><tr><td>遥远的向日葵地</td><td>李娟</td><td>2024-04-23</td><td>3</td></tr><tr><td>重来：更为简单有效的商业思维</td><td>贾森·弗里德戴维·海涅迈尔·汉森</td><td>2024-04-23</td><td>4</td></tr><tr><td>六祖坛经</td><td>慧能</td><td>2024-04-18</td><td>3</td></tr><tr><td>知道做到：跃迁式学习</td><td>彼得•霍林斯</td><td>2024-04-07</td><td>5</td></tr><tr><td>读一页就上瘾的唐朝史</td><td>范西园</td><td>2024-03-17</td><td>2</td></tr><tr><td>掌控习惯：如何养成好习惯并戒除坏习惯（《原子习惯》中文版）（新版）</td><td>詹姆斯·克利尔</td><td>2024-03-11</td><td>5</td></tr><tr><td>费尔德曼发展心理学（原书第 4 版）</td><td>罗伯特·S. 费尔德曼</td><td>2024-02-26</td><td>4</td></tr><tr><td>卡片笔记写作法：如何实现从阅读到写作</td><td>申克·阿伦斯</td><td>2024-02-17</td><td>5</td></tr><tr><td>Python 工匠：案例、技巧与工程实践</td><td>朱雷</td><td>2024-02-13</td><td>3</td></tr><tr><td>战国：七雄博弈</td><td>朱良</td><td>2024-02-12</td><td>2</td></tr><tr><td>长安的荔枝</td><td>马伯庸</td><td>2024-02-10</td><td>2</td></tr><tr><td>春秋：五霸迭兴</td><td>朱良</td><td>2024-02</td><td>2</td></tr></tbody></table><h2 id="写作与发表"><a href="#写作与发表" class="headerlink" title="写作与发表"></a>写作与发表</h2><p>通过《卡片笔记写作法：如何实现从阅读到写作》、《知道做到》两本书，我开始使用 obsidian 记录笔，obsidian 自由度非常高，markdown 格式非常适合迁移到其他平台。随后开始整理输出到 CSDN 、微信公众号和个人博客。之前也零散的发过，不过今年我基本保持至少每周发一篇的更新频率。</p><p>因为个人精力有限，我写的方向内容非常散乱，和我工作、兴趣相关的我都会写，包括 python 数据分析、办公技巧、应用工具推荐、读书笔记以及环保工作的总结、知识点等，核心就是觉得有用的、值得推荐的或者需要反复看的内容都会整理发布，我把账号当做一个笔记本，或者知识库。我们身处一个知识爆炸的时代，完全可以容得这一小小的浪花。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412290803527.png"></p><p>写作和发表我对各种知识点了解更加深入，好记性不如烂笔头，况且我的记忆力非常不好，有时候重读自己过去笔记，也像是第一次学习一样，有的知识点并不需要完全记在脑海里。总之记录和发表是践行卢曼笔记法和费曼学习法的方式。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412290800543.png"></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>在过去的一年里，我沉浸在多个充满魅力的领域中，每一次书中崭新视角的发现、每一段编程解决问题后的兴奋和喜悦、每一次与新朋友的交流以及评论区的沟通碰撞，都为我的业余时光注入了满满的获得感与成就感。然而，这期间也不乏困惑与徘徊——面对众多的兴趣点和学习方向，有限的时间让我意识到必须有所取舍。深入任何一个领域，都需要系统的学习和实践，尤其是在特定的应用环境中才能真正精进。</p><p>展望新的一年，我决定将重心更多地放在环保业务上，我会将整理的相关资料发布在我的个人账号上，以便自己随时查阅的同时，也能成为有需要者的手边资源。</p><p>人生短暂，能够在有限的时间里做自己热爱的事，已是莫大的幸运。在这个充满无限可能的时代，珍惜每一天，用心经营每一个当下，便是对时间最美好的回答。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>读书笔记-卓有成效的管理者</title>
    <link href="/2024/12/09/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85/"/>
    <url>/2024/12/09/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 卓有成效的管理者</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/94/YueWen_25131310/t7_YueWen_25131310.jpg" alt=" 卓有成效的管理者|200"></li><li>书名： 卓有成效的管理者</li><li>作者： 彼得·德鲁克</li><li>简介： 德鲁克以卓越的睿智告知读者：不是只有管理别人的人才称得上是管理者，在当今知识社会中，知识工作者即为管理者。管理者的工作必须卓有成效，卓有成效是可以学习的。全书共 7 章前前 5 章主要讲管理者如何管理自己；最后两章是管理者如何决策。本书提出的管理理念经得起时间和实践的考验。本书已经成为世界上众多企业管理者的必读书籍。</li><li>出版时间 2018-07-01 00:00:00</li><li>ISBN： 9787111604020</li><li>分类： 经济理财-管理</li><li>出版社： 机械工业出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/65832ed0717f792e6582b00">https://weread.qq.com/web/reader/65832ed0717f792e6582b00</a></li></ul></blockquote><p>彼得·德鲁克（Peter F.Drucker，1909年11月19日~2005年11月11日），被誉为现代管理学之父，这本《卓有成效的管理者》成书于 1966 年，距今已接近 60 年，内容不仅丝毫不过时，而且引人深省，给人方向，真是一本好书。</p><h2 id="写作对象"><a href="#写作对象" class="headerlink" title="写作对象"></a>写作对象</h2><p>的写作对象是所有的知识工作者，知识工作者与手工业者、体力劳动者不同，成果是难以量化的，必须也只能用是否有效来衡量。那么成为一个有效的管理者就非常重要。</p><p>需要重点注意的是书中的管理者可以替换为一切知识工作者，因为所有的知识工作者在自己的岗位上都要面临筹划、协作、决策与执行。</p><p>书中的两个前提是：<br>·管理者的工作必须卓有成效；<br>·卓有成效是可以学会的。</p><h2 id="卓有成效管理者的-5-个要素"><a href="#卓有成效管理者的-5-个要素" class="headerlink" title="卓有成效管理者的 5 个要素"></a>卓有成效管理者的 5 个要素</h2><ol><li>记录时间，知道时间是怎么利用的。</li><li>关注贡献</li><li>充分发挥人的长处</li><li>聚焦要事</li><li>做出有效的决策</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412090947297.png" alt="image.png"></p><h3 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h3><p> 有效的管理者知道应该将他们的时间用在什么地方。他们所能控制的时间非常有限，他们会有系统地工作，来善用这有限的时间。<br> 时间管理也是比较热门的词语了，市面上有很多时间管理相关的工具，曾看过艾力老师的 34 枚时间管理法、暗时间等书，我也实践了一段时间，确实在记录的日子或更加重视时间，但长期的记录也会懈怠或者消耗意志力和注意力，个人觉得最重要的建立时间管理，心中有复盘和计划，什么时间必须花费且有意义的，什么时间是浪费掉的，定期总结，及时纠正。</p><h3 id="外部贡献"><a href="#外部贡献" class="headerlink" title="外部贡献"></a>外部贡献</h3><p>有效的管理者重视对外界的贡献。他们并非为工作而工作，而是为成果而工作。他们不会一接到工作就一头钻进去，更不会一开头就探究工作的技术和手段，他们会首先自问：“别人期望我做出什么成果？”<br>外部贡献是成就感的来源，也是衡量管理是否有效的依据，</p><h3 id="善用长处"><a href="#善用长处" class="headerlink" title="善用长处"></a>善用长处</h3><p>有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。他们还善于抓住有利形势，做他们能做的事。他们不会把工作建立在自己的短处上，也绝不会去做自己做不了的事。<br>这一章讲如何对待人，也是本书”以人为本”的核心体现。每个人的性格不一样，但性格并不是影响一个人是否成功的关键，关键是他是否有长处，了解自己与了解他人同样重要，懂得自我管理，善于了解自己的性格和优缺点，</p><h3 id="聚焦要事"><a href="#聚焦要事" class="headerlink" title="聚焦要事"></a>聚焦要事</h3><p>有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。他们会按照工作的轻重缓急设定优先次序，而且坚守优先次序。他们别无选择，只能要事第一。重要的事先做，不重要的事放一放，甚至不做，两种事都做，反倒会一事无成。</p><h3 id="有效决策"><a href="#有效决策" class="headerlink" title="有效决策"></a>有效决策</h3><p>有效的管理者必须善于做有效的决策。他们知道有效的决策事关处事的条理和秩序问题，也就是如何按正确的次序采取正确的步骤。他们知道一项有效的决策，总是在“不同意见讨论”的基础上做出的判断，它绝不会是“一致意见”的产物。他们知道快速的决策多为错误的决策，真正不可或缺的决策数量并不多，但一定是根本性的决策。他们需要的是正确的战略，而不是令人眼花缭乱的战术，同时没有行动的决策并不是决策，更谈不上有效性。</p><h2 id="有效管理者的特点"><a href="#有效管理者的特点" class="headerlink" title="有效管理者的特点"></a>有效管理者的特点</h2><ol><li>注重自我提升，终身学习；</li><li>自身的进步与组织的成长相一致；</li><li>懂得自我管理，善于了解自己的性格和优缺点。</li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果读了本文，如果你觉得上面的总结知识假大空，或者是职场 PUA，那可能是我总结的不好，建议阅读原文。<br>王阳明因为娄亮的一句:“圣人必可学而至”, 就以此为人生理想, 知行合一, 最终成为圣人，周恩来中学立志“为中华崛起而读书”，并作为人生理想和目标，最终成为人民尊敬的周总理，推动中国的独立、统一和发展。这些圣贤都拥有超凡的毅力和品格，我们可能难以做到，但是有效的管理者并不想圣贤一样遥不可及。因此本书有理论、有方法，也是他长盛不衰的重要原因吧。<br>读本书也让我想到利己与利他，如果一心以利他为目标，可能没有抓手，且要求过高，因为人性使然，但如果先利己，再利他，利己的同时不干扰他人，以利己之心推己及人，已所不欲，勿施于人。这种思维方式在从小主要受集体主义思想影响的环境下，可能比较小众，可换个思路，只要每个人都做好自己，都成为有效的管理者，集体、组织不是自然而然的前进了么。<br>躺平是不纯在的，因为人都有向上的心，都有获得成就感的需求的，内卷也是不存在的，我们应该注重外部贡献，做对大家有意义的事情，不是卷别人，而是提升自己，为自己和组织做贡献。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>办公技巧之 批量制作含有图片的文稿</title>
    <link href="/2024/12/06/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Excel%20%E6%89%B9%E9%87%8F%E5%88%B6%E4%BD%9C%E5%B8%A6%E6%9C%89%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%87%E7%A8%BF/"/>
    <url>/2024/12/06/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Excel%20%E6%89%B9%E9%87%8F%E5%88%B6%E4%BD%9C%E5%B8%A6%E6%9C%89%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>之前发布过 Excel 邮件功能批量制作文稿，但当时没有解决图片插入的问题，今天记录一下批量制作含有图片的文稿。</p><h2 id="案例需求介绍"><a href="#案例需求介绍" class="headerlink" title="案例需求介绍"></a>案例需求介绍</h2><p>制作入河排污口一口一档，介绍排口基本信息和排口图片。</p><h3 id="效果示例"><a href="#效果示例" class="headerlink" title="效果示例"></a>效果示例</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061645176.png" alt="image.png"></p><h2 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h2><p>需要资料有：</p><ul><li>排污口基础信息表</li><li>排污口各类照片</li></ul><h3 id="排污口基础信息表"><a href="#排污口基础信息表" class="headerlink" title="排污口基础信息表"></a>排污口基础信息表</h3><p>Excel 表格需要包括所需的字段，重要是对应图片的路径。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061648162.png" alt="image.png"></p><p>路径示例</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\<span class="hljs-number">00</span>一口一策\文档图片\image1.png<br></code></pre></td></tr></table></figure><p>建议将批量名称与图片名称对应，这样可以直接用公式快速生产文件名。推荐结合 quicker 中的批量重命名应用。</p><h2 id="制作文档模板"><a href="#制作文档模板" class="headerlink" title="制作文档模板"></a>制作文档模板</h2><h3 id="文本变量"><a href="#文本变量" class="headerlink" title="文本变量"></a>文本变量</h3><ol><li>制作空白模板，做好文档框架，将变量处删除</li><li>邮件-选择收件人（下拉）-使用现有列表-选择 excel</li><li>邮件-插入合并域，在对应位置选择变量名</li></ol><p>以上就是普通文字的设置方法，效果如下。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061658588.png" alt="image.png"><br>点击预览结果，就可以看到实例化变量。</p><h3 id="图片变量"><a href="#图片变量" class="headerlink" title="图片变量"></a>图片变量</h3><ol><li>插入图片域，插入-文件部件-域，选择<strong>IncludePicture</strong>，在【文件名或 URL】中输入一个文件名，比如“卫星图”，再勾选【未随文档存储的数据】-【确定】。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061706772.png" alt="image.png"></p><ol start="2"><li>点击确定后，有个占位图片框，提前调整为想要的大小。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061707274.png" alt="image.png"></p><p>按<strong>Alt+F 9</strong>组合键切换到域代码，或者选择有灰色域块的位置右键点击切换域代码，选中代码中的“卫星图”三个字，按<strong>CTRL+F 9</strong>，插入域代码的外括号，然后在括号内输入“ if true ”，再选中代码中的“卫星图”三个字。点【邮件】-【插入合并域】-【卫星图】。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061718721.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202412061720640.png" alt="image.png"></p><p>按<strong>Alt+F 9</strong>组合键，切换到图片，这时就显示出来图片了。</p><p>然后点击预览结果，可以预览各项效果，点击完成并合并，就可以输出结果了。<br>做好模版后，只需要维护表格就行了，批量生产几百份文稿，成就感满满。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>办公技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>效率工具清单 v1.0</title>
    <link href="/2024/12/05/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E6%B8%85%E5%8D%95%20v1.0/"/>
    <url>/2024/12/05/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7%E6%B8%85%E5%8D%95%20v1.0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>总结工作以来觉得好用的工具和网站，我选择原则一是工作中高频应用，二是提高工作效率，从中受益匪浅的工具，三是开源免费，成本比较低的软件。列出来主要是方便自己查询，并让需要的人少走弯路。<br>随着时间推移，软件工具也在迅速迭代。因此，我会定期修改更新这份清单，以保持这份清单的时效性和实用性。注意排名有先后，全是个人喜好，请谨慎查看。</p><h2 id="笔记与写作"><a href="#笔记与写作" class="headerlink" title="笔记与写作"></a>笔记与写作</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>Obsidian</td><td>最好用的笔记软件，支持双链、扩展性强，五星好评。</td></tr><tr><td>语雀</td><td>多端同步，功能齐全</td></tr><tr><td>Flomo</td><td>碎片笔记，obsidian 中 Thino 可平替</td></tr><tr><td>FlowUs</td><td>优点在免费公开文档</td></tr><tr><td>Mdnice</td><td>Markdown 排版</td></tr></tbody></table><h2 id="效率工具"><a href="#效率工具" class="headerlink" title="效率工具"></a>效率工具</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>Quicker</td><td>快捷呼出的工具箱，插件市场强大，常用功能：批量重命名，拾色器，ever 智识、截图..</td></tr><tr><td>Listary</td><td>最好用的搜索启动工具，一直被模仿，从未被超越。</td></tr><tr><td>Everything</td><td>经典全盘搜索工具</td></tr><tr><td>OneCommander</td><td>开源资源管理器</td></tr><tr><td>Quicklook</td><td>预览软件，丰富插件，空格就能预览图片、文档、视频…</td></tr><tr><td>iTab</td><td>好用的浏览器启动页插件</td></tr><tr><td>滴答清单</td><td>待办清单软件</td></tr><tr><td>360 好压</td><td>当bandzip 出现广告的时候，你就是最棒的压缩软件</td></tr><tr><td>Windows 便笺</td><td>拒绝一切花里胡哨</td></tr><tr><td>TreeSize</td><td>快速查看文件夹组织结构与大小</td></tr></tbody></table><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>Adobe Acrobat</td><td>功能齐全的 pdf 处理器</td></tr><tr><td>Zotero</td><td>开源文献管理工具，扩展性强</td></tr><tr><td>微信读书</td><td>出版书齐全，支持导入本地书籍，多端同步</td></tr><tr><td>Z-library</td><td>免费电子书下载</td></tr><tr><td>书童图书馆</td><td>论文下载</td></tr><tr><td>Notepad++</td><td>文本类都能打开的阅读器</td></tr><tr><td>菜鸟教程</td><td>计算机相关教程网，根本学不完</td></tr></tbody></table><h2 id="思维导图及流程图"><a href="#思维导图及流程图" class="headerlink" title="思维导图及流程图"></a>思维导图及流程图</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>visio</td><td>流程图绕不开的软件，胜在标准</td></tr><tr><td>Excalidraw</td><td>功能强大的白班绘图工具，扩展性强。</td></tr><tr><td>Obsidian mindmap</td><td>在笔记中也能绘制思维导图</td></tr><tr><td>Mindmaster</td><td>7.3.1 版本就够用了。</td></tr></tbody></table><h2 id="Chat-类-AI"><a href="#Chat-类-AI" class="headerlink" title="Chat 类 AI"></a>Chat 类 AI</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>通义千问</td><td>用了快一年了，你就问吧，代码模式，ppt 模式真香</td></tr><tr><td>秘塔搜索</td><td>在线搜索强无敌</td></tr></tbody></table><h2 id="图片类"><a href="#图片类" class="headerlink" title="图片类"></a>图片类</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>Adobe Photoshop</td><td>学了不亏</td></tr><tr><td>Honeyview</td><td>小巧的图片阅读器</td></tr><tr><td>佐糖</td><td>网页图片处理工具</td></tr><tr><td>Picasa 3</td><td>Google 图片管理软件，已停止更新，并不妨碍其好用</td></tr><tr><td>Unsplash</td><td>开源图片下载网站</td></tr><tr><td>Pixabay</td><td>开源图片下载网站</td></tr><tr><td>Pexels</td><td>开源图片下载网站</td></tr><tr><td>拾光壁纸</td><td>最好用的壁纸应用，美图查看器，Windows 商店可下载</td></tr></tbody></table><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>VS code</td><td>绕不开的 IDE 扩展强大，支持 jupyter notebook</td></tr><tr><td>Pycharm</td><td>专业的 IDE, 智能提示和纠错</td></tr><tr><td>Cursor</td><td>智能 IDE</td></tr></tbody></table><h2 id="地图-GIS"><a href="#地图-GIS" class="headerlink" title="地图 GIS"></a>地图 GIS</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>Omap</td><td>奥维地图，简单好用，功能强大</td></tr><tr><td>QGIS</td><td>开源，界面有好，适合新手的第一款 GIS</td></tr><tr><td>Arcgis&#x2F;Arcgis pro</td><td>专业、且永远绕不开的 GIS 软件</td></tr></tbody></table><h2 id="BI"><a href="#BI" class="headerlink" title="BI"></a>BI</h2><table><thead><tr><th>名称</th><th>推荐语</th></tr></thead><tbody><tr><td>Tableau</td><td>BI 界的 office</td></tr><tr><td>PowerBI</td><td>BI 界的 wps</td></tr></tbody></table><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 坐标系转换web应用构建与发布</title>
    <link href="/2024/11/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%E5%8F%8Aweb%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/"/>
    <url>/2024/11/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%E5%8F%8Aweb%E5%BA%94%E7%94%A8%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间发了一篇​文章<a href="https://mp.weixin.qq.com/s/2nY7TGi8zLl4Dp-4x6Niag">GCJ02、WGS84、BD-09 、CGCS-2000坐标系互转</a>，网友@文祥 留言说有个 python 库可以实现坐标系转换。于是，我就找了下这个项目 coordTransform。真的可以，感谢网友留言~</p><p>直接使用 pip install coordTransform，引用代码会报错，于是直接找到了 github项目代码原文。测试发现结果是正确的。具体代码我就不贴了，后文有地址，感兴趣的可以查看，主要讲一下我基于这个项目做了个 web 应用。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411222054380.png" alt="image.png"></p><h2 id="坐标转换应用"><a href="#坐标转换应用" class="headerlink" title="坐标转换应用"></a>坐标转换应用</h2><p>Web 应用是一个基于 Streamlit 框架开发的坐标转换工具，支持多种地理坐标系之间的相互转换。用户可以通过单点转换和批量转换两种方式，方便快捷地完成坐标系的转换操作。</p><h3 id="单点转换"><a href="#单点转换" class="headerlink" title="单点转换"></a>单点转换</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411222056985.png"></p><h3 id="批量转换"><a href="#批量转换" class="headerlink" title="批量转换"></a>批量转换</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411222057400.png"></p><p>输入文件点击转换即可。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411222059286.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Web 应用代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> coord <span class="hljs-keyword">import</span> gcj02_to_bd09, bd09_to_gcj02, wgs84_to_gcj02, gcj02_to_wgs84, bd09_to_wgs84, wgs84_to_bd09  <span class="hljs-comment"># 导入坐标转换函数  </span><br><br><span class="hljs-comment"># 设置页面标题和布局</span><br><br>st.set_page_config(page_title=<span class="hljs-string">&quot;坐标转换工具&quot;</span>, layout=<span class="hljs-string">&quot;centered&quot;</span>)<br>st.title(<span class="hljs-string">&quot;坐标转换工具&quot;</span>) <br><br><span class="hljs-comment"># 使用tabs切换单点转换和批量转换</span><br>tab1, tab2 = st.tabs([<span class="hljs-string">&quot;单点转换&quot;</span>, <span class="hljs-string">&quot;批量转换&quot;</span>])<br>  <br><br><span class="hljs-keyword">with</span> tab1:<br>    <span class="hljs-keyword">with</span> st.form(key=<span class="hljs-string">&#x27;single_point_form&#x27;</span>):<br>        st.subheader(<span class="hljs-string">&quot;单点转换&quot;</span>)<br>        col00, col01 = st.columns(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">with</span> col00:<br>            source_system = st.selectbox(<span class="hljs-string">&quot;源坐标系&quot;</span>, [<span class="hljs-string">&quot;WGS84&quot;</span>, <span class="hljs-string">&quot;GCJ-02&quot;</span>, <span class="hljs-string">&quot;BD-09&quot;</span>])<br><br>        <span class="hljs-keyword">with</span> col01: <br>            target_system_options = [<span class="hljs-string">&quot;WGS84&quot;</span>, <span class="hljs-string">&quot;GCJ-02&quot;</span>, <span class="hljs-string">&quot;BD-09&quot;</span>]<br>            target_system_options.remove(source_system)<br>            target_system = st.selectbox(<span class="hljs-string">&quot;目标坐标系&quot;</span>, target_system_options)<br>        col1, col2 = st.columns(<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">with</span> col1:<br>            lng = st.number_input(<span class="hljs-string">&quot;经度&quot;</span>, value=<span class="hljs-number">108.81001</span>)<br>        <span class="hljs-keyword">with</span> col2:<br>            lat = st.number_input(<span class="hljs-string">&quot;纬度&quot;</span>, value=<span class="hljs-number">36.125376</span>)<br>        submit_button = st.form_submit_button(label=<span class="hljs-string">&#x27;转换&#x27;</span>)<br>        <span class="hljs-keyword">if</span> submit_button:<br>            <span class="hljs-keyword">if</span> source_system == <span class="hljs-string">&quot;WGS84&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;GCJ-02&quot;</span>:<br>                result = wgs84_to_gcj02(lng, lat)<br>            <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;GCJ-02&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;WGS84&quot;</span>:<br>                result = gcj02_to_wgs84(lng, lat)<br>            <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;GCJ-02&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;BD-09&quot;</span>:<br>                result = gcj02_to_bd09(lng, lat)<br>            <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;BD-09&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;GCJ-02&quot;</span>:<br>                result = bd09_to_gcj02(lng, lat)<br>            <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;BD-09&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;WGS84&quot;</span>:<br>                result = bd09_to_wgs84(lng, lat)<br>            <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;WGS84&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;BD-09&quot;</span>:<br>                result = wgs84_to_bd09(lng, lat)<br>            <span class="hljs-keyword">else</span>:<br>                result = (lng, lat)<br>            st.write(<span class="hljs-string">f&quot;转换结果：经度=<span class="hljs-subst">&#123;result[<span class="hljs-number">0</span>]&#125;</span>, 纬度=<span class="hljs-subst">&#123;result[<span class="hljs-number">1</span>]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">with</span> tab2:<br>    st.subheader(<span class="hljs-string">&quot;批量转换&quot;</span>)<br>    st.info(<span class="hljs-string">&quot;请上传包含经度和纬度列的CSV文件。\n文件格式示例：&quot;</span>)<br>    st.write(pd.DataFrame(&#123;<span class="hljs-string">&quot;经度&quot;</span>: [<span class="hljs-number">120.0</span>, <span class="hljs-number">121.0</span>], <span class="hljs-string">&quot;纬度&quot;</span>: [<span class="hljs-number">30.0</span>, <span class="hljs-number">31.0</span>]&#125;))<br>    uploaded_file = st.file_uploader(<span class="hljs-string">&quot;上传CSV文件&quot;</span>, <span class="hljs-built_in">type</span>=[<span class="hljs-string">&quot;csv&quot;</span>])<br>    <span class="hljs-keyword">if</span> uploaded_file <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        df = pd.read_csv(uploaded_file)<br>        required_columns = &#123;<span class="hljs-string">&quot;经度&quot;</span>, <span class="hljs-string">&quot;纬度&quot;</span>&#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> required_columns.issubset(df.columns):<br>            st.error(<span class="hljs-string">&quot;CSV文件必须包含“经度”和“纬度”两列。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">with</span> st.form(key=<span class="hljs-string">&#x27;batch_conversion_form&#x27;</span>):<br>                col1, col2 = st.columns(<span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">with</span> col1:<br>                    source_system = st.selectbox(<span class="hljs-string">&quot;源坐标系（批量）&quot;</span>, [<span class="hljs-string">&quot;WGS84&quot;</span>, <span class="hljs-string">&quot;GCJ-02&quot;</span>, <span class="hljs-string">&quot;BD-09&quot;</span>])<br>                <span class="hljs-keyword">with</span> col2:<br>                    target_system_options = [<span class="hljs-string">&quot;WGS84&quot;</span>, <span class="hljs-string">&quot;GCJ-02&quot;</span>, <span class="hljs-string">&quot;BD-09&quot;</span>]<br>                    target_system_options.remove(source_system)<br>                    target_system = st.selectbox(<span class="hljs-string">&quot;目标坐标系（批量）&quot;</span>, target_system_options)<br>                batch_convert_button = st.form_submit_button(label=<span class="hljs-string">&#x27;批量转换&#x27;</span>)<br>                <span class="hljs-keyword">if</span> batch_convert_button:<br>                    results = []<br>                    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():<br>                        lng, lat = row[<span class="hljs-string">&#x27;经度&#x27;</span>], row[<span class="hljs-string">&#x27;纬度&#x27;</span>]<br>                        <span class="hljs-keyword">if</span> source_system == <span class="hljs-string">&quot;WGS84&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;GCJ-02&quot;</span>:<br>                            result = wgs84_to_gcj02(lng, lat)<br>                        <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;GCJ-02&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;WGS84&quot;</span>:<br>                            result = gcj02_to_wgs84(lng, lat)<br>                        <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;GCJ-02&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;BD-09&quot;</span>:<br>                            result = gcj02_to_bd09(lng, lat)<br>                        <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;BD-09&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;GCJ-02&quot;</span>:<br>                            result = bd09_to_gcj02(lng, lat)<br>                        <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;BD-09&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;WGS84&quot;</span>:<br>                            result = bd09_to_wgs84(lng, lat)<br>                        <span class="hljs-keyword">elif</span> source_system == <span class="hljs-string">&quot;WGS84&quot;</span> <span class="hljs-keyword">and</span> target_system == <span class="hljs-string">&quot;BD-09&quot;</span>:<br>                            result = wgs84_to_bd09(lng, lat)<br>                        <span class="hljs-keyword">else</span>:<br>                            result = (lng, lat)<br>                        results.append(result)<br>                    df[<span class="hljs-string">&#x27;转换后经度&#x27;</span>] = [r[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results]<br>                    df[<span class="hljs-string">&#x27;转换后纬度&#x27;</span>] = [r[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results]<br>                    st.dataframe(df)<br><span class="hljs-comment"># 添加一些样式</span><br>st.markdown(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;style&gt;</span><br><span class="hljs-string">body &#123;</span><br><span class="hljs-string">    font-family: Arial, sans-serif;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&lt;/style&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>, unsafe_allow_html=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>注意这里的 from coord import gcj 02_to_bd 09 就是用 coordTransform 项目中的代码。<br>有了这个工具就不用 qgis、奥维地图这些工具转了，相当 nice，最后非常感谢网友的留言。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411222117873.jpg"></p><h2 id="工具发布"><a href="#工具发布" class="headerlink" title="工具发布"></a>工具发布</h2><p>为了让更多人受益于这一工具，我已经将其部署至互联网上。目前有两个工具坐标转换和雨型计算。个人精力有限，维护可能不及时，界面也非常简陋，如果大家有好的想法也可以留言。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411271914697.png"></p><ul><li>公开网址： <a href="https://tboxes.streamlit.app/">https://tboxes.streamlit.app/</a></li><li>GitHub 地址： <a href="https://github.com/maoyu92/openurl">https://github.com/maoyu92/openurl</a></li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://github.com/pkufool/coordTransform">https://github.com/pkufool/coordTransform</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>streamlit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Streamlit 技巧 几个被忽视但重要的功能和机制</title>
    <link href="/2024/11/13/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Streamlit%20%E6%8A%80%E5%B7%A7%20%E5%87%A0%E4%B8%AA%E8%A2%AB%E5%BF%BD%E8%A7%86%E4%BD%86%E9%87%8D%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/11/13/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/Streamlit%20%E6%8A%80%E5%B7%A7%20%E5%87%A0%E4%B8%AA%E8%A2%AB%E5%BF%BD%E8%A7%86%E4%BD%86%E9%87%8D%E8%A6%81%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在使用 Streamlit 构建数据应用的过程中，我逐渐发现了一些非常有用但可能容易被忽视的功能与机制。为了更好地记录和分享这些知识，本文将详细介绍这些功能，希望能为同样使用 Streamlit 的同学们提供一些帮助。</p><h2 id="Tabs-组件"><a href="#Tabs-组件" class="headerlink" title="Tabs 组件"></a>Tabs 组件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><br>tab1, tab2, tab3 = st.tabs([<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Owl&quot;</span>])<br><br><span class="hljs-keyword">with</span> tab1:<br>    st.header(<span class="hljs-string">&quot;A cat&quot;</span>)<br>    st.image(<span class="hljs-string">&quot;https://static.streamlit.io/examples/cat.jpg&quot;</span>, width=<span class="hljs-number">200</span>)<br><span class="hljs-keyword">with</span> tab2:<br>    st.header(<span class="hljs-string">&quot;A dog&quot;</span>)<br>    st.image(<span class="hljs-string">&quot;https://static.streamlit.io/examples/dog.jpg&quot;</span>, width=<span class="hljs-number">200</span>)<br><span class="hljs-keyword">with</span> tab3:<br>    st.header(<span class="hljs-string">&quot;An owl&quot;</span>)<br>    st.image(<span class="hljs-string">&quot;https://static.streamlit.io/examples/owl.jpg&quot;</span>, width=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411132138391.png"></p><h2 id="控件中的-key-的应用"><a href="#控件中的-key-的应用" class="headerlink" title="控件中的 key 的应用"></a>控件中的 key 的应用</h2><p>Key 是为了区分组件的键。如果空间名称完全相同就会报错，需要用 key 进行区分。</p><h2 id="Fragment-局部刷新"><a href="#Fragment-局部刷新" class="headerlink" title="Fragment 局部刷新"></a>Fragment 局部刷新</h2><p> Streamlit 默认是全页刷新，通过@st. Fragment 装饰器，可以实现实现局部刷新的效果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-meta">@st.fragment</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">release_the_balloons</span>():<br>    st.button(<span class="hljs-string">&quot;Release the balloons&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Fragment rerun&quot;</span>)<br>    st.balloons()<br><br><span class="hljs-keyword">with</span> st.spinner(<span class="hljs-string">&quot;Inflating balloons...&quot;</span>):<br>    time.sleep(<span class="hljs-number">5</span>)<br>release_the_balloons()<br>st.button(<span class="hljs-string">&quot;Inflate more balloons&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;Full rerun&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Session-State"><a href="#Session-State" class="headerlink" title="Session State"></a>Session State</h2><p><code>Session State</code> 是 Streamlit 提供的一种机制，用于在用户会话之间保持变量的状态。在 Web 应用中，通常每个用户的请求都是独立的，这意味着每次刷新页面或导航到新页面时，变量的状态都会丢失。然而，在某些情况下，我们希望某些变量的状态能够在用户的整个会话期间保持不变，这就是 <code>Session State</code> 发挥作用的地方。</p><h4 id="示例-1：简单的计数器"><a href="#示例-1：简单的计数器" class="headerlink" title="示例 1：简单的计数器"></a>示例 1：简单的计数器</h4><p>这个示例展示了一个简单的计数器，用户每次点击按钮时，计数器的值会增加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><br><span class="hljs-comment"># 初始化 session state</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;counter&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:<br>    st.session_state.counter = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 增加计数器的按钮</span><br>increment_button = st.button(<span class="hljs-string">&#x27;Increment Counter&#x27;</span>)<br><br><span class="hljs-keyword">if</span> increment_button:<br>    st.session_state.counter += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 显示当前计数器的值</span><br>st.write(<span class="hljs-string">f&#x27;Counter: <span class="hljs-subst">&#123;st.session_state.counter&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="示例-2：用户登录状态"><a href="#示例-2：用户登录状态" class="headerlink" title="示例 2：用户登录状态"></a>示例 2：用户登录状态</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><br><span class="hljs-comment"># 初始化 session state</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;logged_in&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> st.session_state:<br>    st.session_state.logged_in = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 登录表单</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> st.session_state.logged_in:<br>    username = st.text_input(<span class="hljs-string">&#x27;Username&#x27;</span>)<br>    password = st.text_input(<span class="hljs-string">&#x27;Password&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;password&#x27;</span>)<br>    login_button = st.button(<span class="hljs-string">&#x27;Login&#x27;</span>)<br><br>    <span class="hljs-keyword">if</span> login_button:<br>        <span class="hljs-keyword">if</span> username == <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">and</span> password == <span class="hljs-string">&#x27;password&#x27;</span>:<br>            st.session_state.logged_in = <span class="hljs-literal">True</span><br>            st.success(<span class="hljs-string">&#x27;Logged in successfully!&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            st.error(<span class="hljs-string">&#x27;Invalid credentials&#x27;</span>)<br><br><span class="hljs-comment"># 显示欢迎信息</span><br><span class="hljs-keyword">if</span> st.session_state.logged_in:<br>    st.write(<span class="hljs-string">f&#x27;Welcome, <span class="hljs-subst">&#123;username&#125;</span>!&#x27;</span>)<br>    logout_button = st.button(<span class="hljs-string">&#x27;Logout&#x27;</span>)<br>    <span class="hljs-keyword">if</span> logout_button:<br>        st.session_state.logged_in = <span class="hljs-literal">False</span><br>        st.success(<span class="hljs-string">&#x27;Logged out successfully!&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="St-Form-表单"><a href="#St-Form-表单" class="headerlink" title="St. Form 表单"></a>St. Form 表单</h2><p>使用 <code>st.form</code> 创建一个表单，需要给表单分配一个唯一的 <code>key</code>，这个 <code>key</code> 用于标识不同的表单实例。在表单内部，可以添加各种输入控件，如文本输入框、选择框等。<br>在表单内部，你可以像在其他地方一样添加各种输入控件。这些控件的值会被保存在一个表单状态中，直到用户点击提交按钮。<br>使用 <code>st.form_submit_button</code> 添加一个提交按钮。当用户点击这个按钮时，表单内的所有输入控件的值都会被捕获，并可以通过条件语句来处理这些值。</p><p>以下是一个完整的示例，展示了如何使用 <code>st.form</code> 创建一个包含多个输入控件的表单，并在用户提交表单后验证输入的有效性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">with</span> st.form(key=<span class="hljs-string">&quot;form1&quot;</span>):<br>    respond_info = &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;team&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;share_info&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;email_info&quot;</span>: <span class="hljs-literal">None</span>,<br>        <span class="hljs-string">&quot;age_info&quot;</span>: <span class="hljs-literal">None</span><br>    &#125;<br><br>    respond_info[<span class="hljs-string">&quot;name&quot;</span>] = st.text_input(label=<span class="hljs-string">&quot;Name&quot;</span>)<br>    respond_info[<span class="hljs-string">&quot;team&quot;</span>] = st.selectbox(<br>        label=<span class="hljs-string">&quot;favorate team:&quot;</span>,<br>        options=[<span class="hljs-string">&quot;Arsenal&quot;</span>, <span class="hljs-string">&quot;Man City&quot;</span>, <span class="hljs-string">&quot;Man United&quot;</span>, <span class="hljs-string">&quot;Chelsea&quot;</span>, <span class="hljs-string">&quot;Liverpool&quot;</span>]<br>    )<br>    respond_info[<span class="hljs-string">&quot;share_info&quot;</span>] = st.radio(label=<span class="hljs-string">&quot;share my information:&quot;</span>, options=[<span class="hljs-string">&quot;yes&quot;</span>, <span class="hljs-string">&quot;no&quot;</span>])<br>    respond_info[<span class="hljs-string">&quot;email_info&quot;</span>] = st.checkbox(label=<span class="hljs-string">&quot;Receive Email notification&quot;</span>)<br>    respond_info[<span class="hljs-string">&quot;age_info&quot;</span>] = st.slider(label=<span class="hljs-string">&quot;age&quot;</span>, min_value=<span class="hljs-number">0</span>, max_value=<span class="hljs-number">100</span>)<br>    <span class="hljs-comment"># submit button</span><br>    form_submitted = st.form_submit_button(label=<span class="hljs-string">&quot;Submit!&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_form_valid</span>():<br>        vals = respond_info.values()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">all</span>([<span class="hljs-literal">True</span> <span class="hljs-keyword">if</span> val <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-literal">None</span>, <span class="hljs-string">&quot;&quot;</span>] <span class="hljs-keyword">else</span> <span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> vals ])<br><br>    <span class="hljs-comment"># check format</span><br>    <span class="hljs-keyword">if</span> form_submitted:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_form_valid():<br>            st.warning(<span class="hljs-string">&quot;Please fill in all form values!&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># st.balloons()</span><br>            st.write(<span class="hljs-string">&quot;form submitted!&quot;</span>)<br><br><br><span class="hljs-built_in">print</span>(respond_info)<br>respond_info<br></code></pre></td></tr></table></figure><h2 id="St-Cache-data"><a href="#St-Cache-data" class="headerlink" title="St. Cache_data"></a>St. Cache_data</h2><p><code>st.cache_data</code> 是 Streamlit 提供的一个装饰器，用于缓存函数的输出结果。它可以帮助减少数据加载或计算的时间，提高应用的响应速度。当一个带有 <code>@st.cache_data</code> 装饰器的函数被调用时，Streamlit 会检查函数的输入参数是否已经存在于缓存中。如果存在，则直接从缓存中读取结果；如果不存在，则执行函数并将其输出结果存储到缓存中。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>下面是一个简单的例子，展示了如何使用 <code>st.cache_data</code> 缓存一个模拟的耗时数据加载过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 模拟一个耗时的数据加载函数</span><br><span class="hljs-meta">@st.cache_data</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">n_rows</span>):<br>    <span class="hljs-comment"># 模拟长时间的数据加载过程</span><br>    time.sleep(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 假设需要5秒来加载数据</span><br>    data = &#123;<span class="hljs-string">&#x27;column1&#x27;</span>: <span class="hljs-built_in">range</span>(n_rows), <span class="hljs-string">&#x27;column2&#x27;</span>: <span class="hljs-built_in">range</span>(n_rows)&#125;<br>    <span class="hljs-keyword">return</span> pd.DataFrame(data)<br><br><span class="hljs-comment"># 用户界面部分</span><br>st.title(<span class="hljs-string">&#x27;使用 st.cache_data 加速数据加载&#x27;</span>)<br><br><span class="hljs-comment"># 获取用户输入</span><br>n_rows = st.number_input(<span class="hljs-string">&#x27;请输入行数&#x27;</span>, min_value=<span class="hljs-number">1</span>, value=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># 显示加载中的提示信息</span><br><span class="hljs-keyword">with</span> st.spinner(<span class="hljs-string">&#x27;正在加载数据...&#x27;</span>):<br>    df = load_data(n_rows)<br><br><span class="hljs-comment"># 显示数据</span><br>st.write(df)<br>st.success(<span class="hljs-string">&#x27;数据加载完成！&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>load_data</code> 函数被 <code>@st.cache_data</code> 装饰器修饰。第一次加载指定数量的数据时，会实际执行 <code>time.sleep(5)</code> 模拟的长时间加载过程，并将结果缓存起来。当用户再次请求相同数量的数据时，Streamlit 将直接从缓存中获取结果，而不需要再次等待 5 秒。</p><h2 id="批处理命令及开机启动"><a href="#批处理命令及开机启动" class="headerlink" title="批处理命令及开机启动"></a>批处理命令及开机启动</h2><p>在服务器上部署 web 项目时，需要设置批处理命令，包括启动 python 环境，指定 python 文件等。<br>下面为一个例子。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bat">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-comment">rem 初始化 Conda</span><br><span class="hljs-keyword">call</span> &quot;C:\Users\htwl\anaconda3\Scripts\activate&quot;<br><span class="hljs-comment"></span><br><span class="hljs-comment">rem 激活 Conda 环境</span><br><span class="hljs-keyword">call</span> conda activate streamlit_env<br><span class="hljs-comment"></span><br><span class="hljs-comment">rem 切换到目标目录</span><br><span class="hljs-built_in">cd</span> /d D:\baibaoxiang<br><span class="hljs-comment"></span><br><span class="hljs-comment">rem 运行 Streamlit 应用</span><br><span class="hljs-keyword">call</span> streamlit run D:\baibaoxiang\app.py<br></code></pre></td></tr></table></figure><ul><li><code>@echo off</code>：关闭命令回显，使输出更干净。</li><li><code>call &quot;C:\Users\htwl\anaconda3\Scripts\activate&quot;</code>：调用 Conda 的激活脚本。</li><li><code>call conda activate streamlit_env</code>：激活指定的 Conda 环境。</li><li><code>cd /d D:\baibaoxiang</code>：切换到目标目录。</li><li><code>call streamlit run D:\baibaoxiang\app.py</code>：运行 Streamlit 应用。</li></ul><p>将上面内容放在. Bat 文件内，将文件复制到 windows 开始菜单的启动文件夹内。实现开机自动运行。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">C</span>:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411141706855.png"></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>streamlit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>marimo 初体验 能替代jupyter streamlit么？</title>
    <link href="/2024/11/06/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/marimo%20%E5%88%9D%E4%BD%93%E9%AA%8C%20%E8%83%BD%E6%9B%BF%E4%BB%A3jupyter%20streamlit%E4%B9%88%EF%BC%9F/"/>
    <url>/2024/11/06/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/marimo%20%E5%88%9D%E4%BD%93%E9%AA%8C%20%E8%83%BD%E6%9B%BF%E4%BB%A3jupyter%20streamlit%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><strong>Marimo</strong> 是最近观察到的一款响应式 Python 笔记本，被誉为“面向未来的笔记本”，旨在替代传统的 Jupyter 和 Streamlit。初次试用时，我被其简洁的启动方式、美观的界面和易于分享的特点深深吸引。<strong>Marimo</strong> 实现了所见即所得的效果，极大地提升了用户体验。然而，作为一个相对较新的工具，它在使用过程中也暴露出了一些问题。本文将总结我的近期体验，并分享一些使用心得。未来，我将持续关注 <strong>Marimo</strong> 的发展，期待它在数据分析和可视化领域的更多创新。</p><h2 id="官方介绍"><a href="#官方介绍" class="headerlink" title="官方介绍"></a>官方介绍</h2><p><strong>Marimo</strong> 是一款响应式 Python 笔记本：运行单元格可与 UI 元素交互，marimo 会自动更新依赖于它的单元格，从而保持代码和输出的一致性。<strong>marimo</strong> 笔记本以纯 Python 格式存储，可作为脚本执行，也可作为应用程序部署。</p><h3 id="Marimo-优势"><a href="#Marimo-优势" class="headerlink" title="Marimo  优势"></a><strong>Marimo</strong>  优势</h3><ul><li>🚀 功能齐全: 替代 jupyter、streamlit、jupytext、ipywidgets、papermill 等更多工具</li><li>⚡️ 响应式: 运行一个单元格，marimo 会响应式地运行所有依赖单元格</li><li>🖐️ 交互性: 绑定滑块、表格、图表等 UI 元素 到 Python</li><li>🔬 可复现: 无隐藏状态，确定性执行</li><li>🏃‍♂️ 可执行: 作为 Python 脚本执行，通过命令行调整参数</li><li>🛜 可分享: 部署为交互式 Web 应用 或幻灯片，通过 WASM 在浏览器中运行</li><li>🛢️ 为数据设计: 使用 SQL 查询数据框和数据库，过滤和搜索数据框</li><li>🐍 支持 Git: 笔记本以 .py 文件格式存储</li><li>⌨️ 现代编辑器: GitHub Copilot、AI 助手、vim 快捷键、变量浏览器，和更多功能</li></ul><h2 id="操作记录"><a href="#操作记录" class="headerlink" title="操作记录"></a>操作记录</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> marimo <br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411061555214.png"></p><h3 id="新建或编辑文件"><a href="#新建或编辑文件" class="headerlink" title="新建或编辑文件"></a>新建或编辑文件</h3><p>使用以下命令创建或编辑笔记本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#指定解释器</span><br><span class="hljs-comment">#conda 解释器</span><br>conda activate base<br><br><span class="hljs-comment">#指定文件目录</span><br><span class="hljs-built_in">cd</span> /d D:\BaiduSyncdisk\pythonprograms\marimo<br>marimo edit [filename].py<br>marimo edit new_marimo.py<br><span class="hljs-comment">#运行示例文件</span><br>marimo tutorial intro<br><span class="hljs-comment">#更新</span><br>pip install --upgrade marimo<br></code></pre></td></tr></table></figure><h3 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h3><p>将笔记本作为网络应用程序运行，隐藏 Python 代码，且不可编辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">marimo run new_marimo.py<br>marimo run pic.py<br></code></pre></td></tr></table></figure><p><strong>作为脚本执行</strong> 在命令行中将笔记本作为脚本执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python your_notebook.py<br></code></pre></td></tr></table></figure><p><strong>自动转换已有的 Jupyter 笔记本</strong> 通过命令行将 Jupyter 笔记本自动转换为 marimo 格式的笔记本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">marimo convert your_notebook.ipynb &gt; your_notebook.py<br>marimo convert pic.ipynb &gt; pic.py<br></code></pre></td></tr></table></figure><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p>列出所有的可用教程:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">marimo tutorial --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411071501685.png"></p><p>使用对应的语句学习基本语法，比如ui</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">marimo tutorial ui</span><br></code></pre></td></tr></table></figure><p>在浏览器中很方便的看到各类 ui 的写法，比如数字输入，单选、多选、文件录入、时间输入等。相当于 streamlit 的控件，简洁的样式可以满足基本的需求。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411071503672.png" alt="image.png"></p><p>用同样的方法，可以快速上手数据结构，绘图等。</p><h3 id="数据透视图"><a href="#数据透视图" class="headerlink" title="数据透视图"></a>数据透视图</h3><p>使用 ui. data_explorer () 方法快速搭建数据透视图。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411071530728.png"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mo<span class="hljs-selector-class">.ui</span><span class="hljs-selector-class">.data_explorer</span>(df)<br></code></pre></td></tr></table></figure><h2 id="个人体验小结"><a href="#个人体验小结" class="headerlink" title="个人体验小结"></a>个人体验小结</h2><p><code>marimo</code> 是一个正处于快速发展阶段的库，尽管目前在成熟度上还不及 Jupyter Notebook 和 Streamlit，但在用户体验和功能创新方面展现出了巨大的潜力。</p><p><code>marimo</code> 在处理大数据量时可能会显得较为缓慢，甚至在某些情况下会卡顿。此外，<code>marimo</code> 在运行一个单元格时会自动运行所有依赖单元格，这意味着代码中的任何错误都会导致整个项目无法正常启动，这在命令行中尤为明显，同时也不便于在浏览器中进行即时修改。另一个需要注意的点是，<code>marimo</code> 对变量命名有严格的要求，不允许重复名称，这增加了代码编写的约束。</p><p>除了上面发现的问题，优点也比较多，美观，易上手，相当于结合了 streamlit 展示的 jupyter notebook，本次体验并不深入，marimo 还可解接入 openai ,googleai 等提示，而且可以使用 SQL 语句查询表格文件和 df 文件，可玩性还是很强，未来可期吧，后面会持续关注。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p><a href="https://docs.marimo.io/">marimo</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian 官方网页剪藏插件 obsidian web Clipper</title>
    <link href="/2024/10/31/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/obsidian%20web%20Clipper%20obsidian/"/>
    <url>/2024/10/31/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/obsidian%20web%20Clipper%20obsidian/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Obsidian web Clipper 一款 obsidian 官方网站剪藏软件，相当于印象笔记、语雀的工具的 Clipper 插件，效果非常好，而且笔记都放在本地，排版、元数据直接获取，强烈的推广欲让我想让所有使用 obsidian 的用户知道。</p><h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>目前上架了 chrome 应用商店，edge 直接搜索是没有的。在 chrome 应用商店搜索安装即可。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410311123256.png"></p><p>但是我的主流浏览器是 edge，也是可以解决的，将网址复制粘贴到 edge, 会在顶部出现提示框，直接安装即可，这适用于所有没上架 edge 应用商店的插件。</p><p><a href="https://chromewebstore.google.com/detail/obsidian-web-clipper/cnjifjpddelmedmihgijeibhnjfabmlf?hl=zh-CN&utm_source=ext_sidebar">Obsidian Web Clipper - Chrome 应用商店 (google.com)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410311125188.png"></p><h2 id="插件使用及笔记效果"><a href="#插件使用及笔记效果" class="headerlink" title="插件使用及笔记效果"></a>插件使用及笔记效果</h2><p>插件使用非常无脑，无需设置，在 obsidian 开启的情况下，点击 obsidian web Clipper 按钮，默认收集到到 Clippings，而且自带文章元数据。包括文件名、来源，创建时间，标签等，排版都给你排好了，真香。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410311127764.png"></p><h3 id="笔记效果"><a href="#笔记效果" class="headerlink" title="笔记效果"></a>笔记效果</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410311130281.png"></p><p>如果你在用 obsidian，那就快快用起来吧~</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian插件</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用滞后相关性计算水质站点之间的污染传递关系</title>
    <link href="/2024/10/30/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%BB%9E%E5%90%8E%E7%9B%B8%E5%85%B3%E6%80%A7%E8%AE%A1%E7%AE%97%E6%B0%B4%E8%B4%A8%E7%AB%99%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B1%A1%E6%9F%93%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB/"/>
    <url>/2024/10/30/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%BB%9E%E5%90%8E%E7%9B%B8%E5%85%B3%E6%80%A7%E8%AE%A1%E7%AE%97%E6%B0%B4%E8%B4%A8%E7%AB%99%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B1%A1%E6%9F%93%E4%BC%A0%E9%80%92%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在研究水质变化时，了解污染物从一个地点向另一个地点的传递过程至关重要。这不仅有助于我们追踪污染物的源头，还能为污染控制措施提供指导。</p><p>以下是在同一条河流、不同点位的氨氮变化趋势图，可以明显看出污染物的传递关系，那么如何简单快捷的计算出传递时间呢？今天，我们将探讨如何利用滞后相关性来计算水质站点之间的污染传递时间。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410301557875.png" alt="微信图片_20241030094721(1).png"></p><h2 id="滞后相关性的概念"><a href="#滞后相关性的概念" class="headerlink" title="滞后相关性的概念"></a>滞后相关性的概念</h2><p><strong>滞后相关性（Lagged Correlation）</strong> 是一种统计方法，用于评估两个时间序列数据集之间的时间延迟关系。这种方法能够帮助我们理解污染物是如何随时间和空间变化的，进而推断出污染物的来源、路径和速度。</p><h2 id="滞后相关性的数学意义"><a href="#滞后相关性的数学意义" class="headerlink" title="滞后相关性的数学意义"></a>滞后相关性的数学意义</h2><p>数学上，滞后相关性可以通过计算两个时间序列数据集 $X (t)$ 和 $Y (t)$ 在不同时间滞后 $k$ 下的相关系数 $r (k)$ 来量化它们之间的关系。公式如下：</p><p>$$<br>r(k) &#x3D; \frac{\sum_{t&#x3D;k+1}^{T}(X(t) - \bar{X})(Y(t-k) - \bar{Y})}{\sqrt{\sum_{t&#x3D;1}^{T}(X(t) - \bar{X})^2} \sqrt{\sum_{t&#x3D;1}^{T}(Y(t) - \bar{Y})^2}}<br>$$</p><p>其中：</p><ul><li>$X (t)$ 和 $Y (t)$ 分别表示两个时间序列；</li><li>$\bar{X}$ 和 $\bar{Y}$ 分别是这两个序列的平均值；</li><li>$k$ 是时间滞后的步数，即 $Y (t-k)$ 相对于 $X (t)$ 的时间差；</li><li>$T$ 是时间序列的长度。</li></ul><h2 id="Python-算法"><a href="#Python-算法" class="headerlink" title="Python 算法"></a>Python 算法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_lagged_correlations</span>(<span class="hljs-params">ts1, ts2, lags</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">计算两个时间序列在指定滞后范围内的相关性。</span><br><span class="hljs-string">参数:</span><br><span class="hljs-string">    ts1 (pd.Series): 第一个时间序列</span><br><span class="hljs-string">    ts2 (pd.Series): 第二个时间序列</span><br><span class="hljs-string">    lags (list): 滞后值列表</span><br><span class="hljs-string"></span><br><span class="hljs-string">返回:</span><br><span class="hljs-string">    dict: 滞后值及其对应的相关系数</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>correlations = &#123;&#125;<br><span class="hljs-keyword">for</span> lag <span class="hljs-keyword">in</span> lags:<br>    <span class="hljs-keyword">if</span> lag &gt; <span class="hljs-number">0</span>:<br>        corr = ts1.corr(ts2.shift(lag))<br>    <span class="hljs-keyword">elif</span> lag &lt; <span class="hljs-number">0</span>:<br>        corr = ts1.shift(-lag).corr(ts2)<br>    <span class="hljs-keyword">else</span>:<br>        corr = ts1.corr(ts2)<br>    correlations[lag] = corr<br><span class="hljs-keyword">return</span> correlations<br></code></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>根据 correlations 简单绘图得到下图：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410301611224.png" alt="image.png"></p><p>可以得出两数据最大滞后相关性为 0.753，相关性较高，滞后阶数为：28，意味着两者的污染物运移时间为 28 个步长。该数据的步长是 4 小时，也就是上游流向下游为 4.67 天。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过计算最大滞后相关性，我们可以有效分析两个监测点之间是否存在显著的滞后关联，并且精确地确定最大相关性的滞后阶数。这一方法在河道流量监测不准确的情况下尤为重要，能够帮助我们更好地掌握河道的流速和污染物的运移时间，为水质管理和环境保护提供科学依据。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生态环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以在线设备拓扑关系为基础的污染溯源算法</title>
    <link href="/2024/10/29/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E4%BB%A5%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C%E5%85%B3%E7%B3%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B0%B4%E8%B4%A8%E5%9C%A8%E7%BA%BF%E8%AE%BE%E5%A4%87%E6%BA%AF%E6%BA%90%E7%AE%97%E6%B3%95/"/>
    <url>/2024/10/29/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E4%BB%A5%E8%AE%BE%E5%A4%87%E7%BD%91%E7%BB%9C%E5%85%B3%E7%B3%BB%E4%B8%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B0%B4%E8%B4%A8%E5%9C%A8%E7%BA%BF%E8%AE%BE%E5%A4%87%E6%BA%AF%E6%BA%90%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在水质分析过程中，污染溯源是无法绕开的部分，当一个在线设备表现出污染特征时，我们往往希望快速知道是什么原因造成的。日常数据分析往往利用在设备、水文网络基础上，往上溯源，逐一找到相关的站点或者排污口，从而判断出污染来源，这种方式适用于点源或者上游有在线监测的断面，这种方法虽然有效，但效率低下，那么如何将其自动化呢？</p><p>为了实现高效的水质污染溯源，首要任务是建立一个详细的河流与在线监测设备的数字模型。这一模型由两部分组成：首先是河流关系表，它记录了河流的上下游关系、干支流等级等信息，为理解水流路径提供了基础；其次是在线设备关系表，该表详细列出了不同类型的监测设备（如水质监测站、排污口监测点）与河流的具体关联，有助于识别潜在的污染来源。</p><p>本文档介绍了如何使用 Python 实现水质溯源算法。通过构建河流和在线设备拓扑关系表，利用算法，我们能够根据任意站点的信息，追踪其上游相关的设备。在通过滞后相关分析可初步实现追踪溯源。<br>这是污染溯源的第一步，今天先介绍是如何实现的，如果你有更好的方法，也请留言指正。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410301503585.png" alt="河流网络与在线设备关系概化图"></p><h2 id="河流和在线设备拓扑构建关系"><a href="#河流和在线设备拓扑构建关系" class="headerlink" title="河流和在线设备拓扑构建关系"></a>河流和在线设备拓扑构建关系</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410301510193.png" alt="关系框架"></p><p>需要构建 2 张表，包含 2 种设备类型，一张河流关系表，表示河流的上下游关系，岸线关系，干支流关系；一张设备表，表示河道在线监测设备、排污口在线监测设备这两种设备与河流的关联关系。</p><h3 id="河流关系表"><a href="#河流关系表" class="headerlink" title="河流关系表"></a>河流关系表</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>序号</td><td>记录编号</td></tr><tr><td>Mn</td><td>河流唯一编码</td></tr><tr><td>Name</td><td>河流名称</td></tr><tr><td>河流级别</td><td>明确干支流关系，干流为 0，一级支流为 1，以此类推</td></tr><tr><td>上级河流</td><td>进一步明确干支流关系，便于理解较深的层次关系</td></tr><tr><td>同级顺序</td><td>明确同一河流级别下的上下游关系，从 1 往后排序</td></tr><tr><td>流域名称</td><td>同一流域才能进行分析</td></tr><tr><td>类型</td><td>河流为 <code>river</code></td></tr><tr><td>岸线</td><td>明确左右岸位置</td></tr><tr><td>河流关系</td><td>与站点类型对应，河流为 <code>base</code>、排污口为 <code>to</code>、河流站点为 <code>on</code></td></tr></tbody></table><h3 id="在线设备关系表"><a href="#在线设备关系表" class="headerlink" title="在线设备关系表"></a>在线设备关系表</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>序号</td><td>记录编号</td></tr><tr><td>Mn</td><td>唯一编码</td></tr><tr><td>站点名称</td><td>设备名称</td></tr><tr><td>所在河流</td><td>设备所在的河流名称</td></tr><tr><td>河流关系</td><td>设备与河流的关系</td></tr><tr><td>同级顺序</td><td>在同一条河流上，用同级顺序表示上下游关系</td></tr><tr><td>上方支流</td><td>在线设备上有最近的支流名称，结合同级顺序可以定义在线设备在水文关系中的位置</td></tr><tr><td>流域名称</td><td>同一流域才能进行分析</td></tr><tr><td>岸线关系</td><td>明确左右岸位置</td></tr><tr><td>站点类型</td><td>设备类型</td></tr><tr><td>所在河流ID</td><td>设备所在的河流唯一编码</td></tr></tbody></table><h2 id="溯源逻辑"><a href="#溯源逻辑" class="headerlink" title="溯源逻辑"></a>溯源逻辑</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><strong>获取目标站点信息</strong>：    <ul><li>根据站点名称查找目标站点的所有信息。</li><li>获取站点所在的河流ID和上方支流。</li></ul></li><li><strong>获取上方支流的河流信息</strong>：    <ul><li>获取上方支流的河流级别和同级顺序。</li></ul></li><li><strong>获取所有同级且同级顺序小于等于上方支流的河流</strong>：    <ul><li>查找所有与上方支流同级别且同级顺序小于等于上方支流的河流。</li></ul></li><li><strong>递归获取下一级支流</strong>：    <ul><li>对于每条找到的河流，递归地查找其下级河流，直到找到所有相关河流。</li></ul></li><li><strong>获取所有相关支流上的站点</strong>：    <ul><li>根据找到的所有相关河流ID，获取这些河流上的站点信息，形成列表A。</li></ul></li><li><strong>获取同一条河流上同级顺序小于目标站点的站点</strong>：    <ul><li>查找同一条河流上同级顺序小于目标站点的站点，形成列表B。</li></ul></li><li><strong>合并列表A和列表B</strong>：    <ul><li>去除重复项，得到最终的相关站点列表C。</li></ul></li><li><strong>匹配列表C与在线设备关系表</strong>：    <ul><li>获取最终相关在线设备表，输出所有参数。</li></ul></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># @Time    : 2024/10/29 下午4:57</span><br><span class="hljs-string"># @Author  : 陈文茂</span><br><span class="hljs-string"># @File    : traceability.py</span><br><span class="hljs-string"># @Software: PyCharm</span><br><span class="hljs-string"># @tags    : 水质溯源 水文分析</span><br><span class="hljs-string"># @Desc    : 水质溯源算法</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 确保站点ID和河流ID为文本格式</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_data</span>(<span class="hljs-params">rivers_df, stations_df</span>):<br>    rivers_df[<span class="hljs-string">&#x27;mn&#x27;</span>] = rivers_df[<span class="hljs-string">&#x27;mn&#x27;</span>].astype(<span class="hljs-built_in">str</span>)<br>    rivers_df[<span class="hljs-string">&#x27;上级河流&#x27;</span>] = rivers_df[<span class="hljs-string">&#x27;上级河流&#x27;</span>].astype(<span class="hljs-built_in">str</span>)<br>    stations_df[<span class="hljs-string">&#x27;mn&#x27;</span>] = stations_df[<span class="hljs-string">&#x27;mn&#x27;</span>].astype(<span class="hljs-built_in">str</span>)<br>    stations_df[<span class="hljs-string">&#x27;所在河流ID&#x27;</span>] = stations_df[<span class="hljs-string">&#x27;所在河流ID&#x27;</span>].astype(<span class="hljs-built_in">str</span>)<br>    <span class="hljs-keyword">return</span> rivers_df, stations_df<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_upstream_stations</span>(<span class="hljs-params">station_name, rivers_df, stations_df</span>):<br>    <span class="hljs-comment"># 获取目标站点信息</span><br>    target_station = stations_df[stations_df[<span class="hljs-string">&#x27;站点名称&#x27;</span>] == station_name]<br>    <span class="hljs-keyword">if</span> target_station.empty:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;No station found with the provided name.&quot;</span><br><br>    target_station = target_station.iloc[<span class="hljs-number">0</span>]<br>    target_river_id = target_station[<span class="hljs-string">&#x27;所在河流ID&#x27;</span>]<br>    up_tributary = target_station[<span class="hljs-string">&#x27;上方支流&#x27;</span>]<br>    <span class="hljs-comment"># 获取上方支流的河流信息</span><br>    up_tributary_info = rivers_df[rivers_df[<span class="hljs-string">&#x27;name&#x27;</span>] == up_tributary].iloc[<span class="hljs-number">0</span>]<br>    up_tributary_level = up_tributary_info[<span class="hljs-string">&#x27;河流级别&#x27;</span>]<br>    up_tributary_order = up_tributary_info[<span class="hljs-string">&#x27;同级顺序&#x27;</span>]<br><br>    <span class="hljs-comment"># 获取所有同级且同级顺序小于等于上方支流的河流</span><br>    upstream_rivers = rivers_df[<br>        (rivers_df[<span class="hljs-string">&#x27;河流级别&#x27;</span>] == up_tributary_level) &amp;<br>        (rivers_df[<span class="hljs-string">&#x27;同级顺序&#x27;</span>] &lt;= up_tributary_order)<br>        ]<br><br>    <span class="hljs-comment"># 获取所有相关支流的集合</span><br>    related_rivers = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> upstream_rivers.iterrows():<br>        related_rivers.add(row[<span class="hljs-string">&#x27;mn&#x27;</span>])<br>        <span class="hljs-comment"># 递归获取下一级支流</span><br>        related_rivers.update(get_downstream_rivers(row[<span class="hljs-string">&#x27;mn&#x27;</span>], rivers_df))<br><br>    <span class="hljs-comment"># 获取所有相关支流上的站点</span><br>    related_stations_a = stations_df[stations_df[<span class="hljs-string">&#x27;所在河流ID&#x27;</span>].isin(related_rivers)]<br><br>    <span class="hljs-comment"># 获取同一条河流上同级顺序小于目标站点的站点</span><br>    same_river_stations = stations_df[<br>        (stations_df[<span class="hljs-string">&#x27;所在河流ID&#x27;</span>] == target_river_id) &amp;<br>        (stations_df[<span class="hljs-string">&#x27;同级顺序&#x27;</span>] &lt; target_station[<span class="hljs-string">&#x27;同级顺序&#x27;</span>])<br>        ]<br><br>    <span class="hljs-comment"># 合并列表A和列表B</span><br>    related_stations_c = pd.concat([related_stations_a, same_river_stations]).drop_duplicates()<br><br>    <span class="hljs-comment"># 返回结果</span><br>    <span class="hljs-keyword">return</span> related_stations_c<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_downstream_rivers</span>(<span class="hljs-params">river_id, rivers_df</span>):<br>    downstream_rivers = rivers_df[rivers_df[<span class="hljs-string">&#x27;上级河流&#x27;</span>] == river_id]<br>    downstream_ids = <span class="hljs-built_in">set</span>(downstream_rivers[<span class="hljs-string">&#x27;mn&#x27;</span>])<br><br>    <span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> downstream_rivers.iterrows():<br>        downstream_ids.update(get_downstream_rivers(row[<span class="hljs-string">&#x27;mn&#x27;</span>], rivers_df))<br><br>    <span class="hljs-keyword">return</span> downstream_ids<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    rivers_df = pd.read_excel(<span class="hljs-string">&#x27;河流设备拓补关系.xlsx&#x27;</span>, sheet_name=<span class="hljs-string">&#x27;河流关系表&#x27;</span>)<br>    stations_df = pd.read_excel(<span class="hljs-string">&#x27;河流设备拓补关系.xlsx&#x27;</span>, sheet_name=<span class="hljs-string">&#x27;在线设备关系表&#x27;</span>)<br>    rivers_df, stations_df = preprocess_data(rivers_df, stations_df)<br><br>    <span class="hljs-comment"># 示例：查找影响“凤凰湖工业园区污水处理厂排口下游”的设备</span><br>    result1 = get_upstream_stations(<span class="hljs-string">&quot;设备a&quot;</span>, rivers_df, stations_df)<br>    <span class="hljs-built_in">print</span>(result1)<br></code></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410301521800.png" alt="结果预览"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上述方法，我们已经能够有效地识别出与目标站点水质变化相关的上游设备。一旦建立了详尽的设备清单，就可以迅速锁定潜在的污染源。为进一步提高溯源精度，后续还将通过相关性分析筛选出与水质异常关联度最高的设备。此外，利用GIS技术进行的空间分析也是一种有效的补充手段，它可以直观地展示各站点间的地理位置关系，帮助我们更准确地评估站点间的影响程度。<br>需要注意的是，本文所介绍的方法侧重于基于网络结构的溯源分析，可能未能充分反映站点间的实际距离因素。因此，在某些情况下，如果污染源与受影响站点相距甚远，本方法可能难以直接揭示二者之间的关联。然而，这并不意味着该方法不具备价值；相反，它为污染溯源提供了一种新的视角和解决方案。<br>除了溯源分析之外，污染扩散路径的追踪同样重要。借助已构建的设备拓扑关系表，我们可以通过算法模拟污染物在水系中的传播过程，预测其可能的影响范围。这不仅有助于事前预防，也能为事后处理提供科学依据。未来的工作中，我们将继续深入研究并完善这些算法，以期为水质管理和环境保护提供更为强大的技术支持。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
      <tag>水文分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCJ02、WGS84、BD-09 、CGCS-2000坐标系互转</title>
    <link href="/2024/10/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/CJ02%E3%80%81WGS84%E3%80%81BD-09%20%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BA%92%E8%BD%AC/"/>
    <url>/2024/10/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/CJ02%E3%80%81WGS84%E3%80%81BD-09%20%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BA%92%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>随着互联网技术的发展，地理信息系统（GIS）的应用越来越广泛，尤其是在地图服务领域。不同的应用和服务可能使用不同的地理坐标系，这导致了数据互操作性的问题。因此，了解并掌握不同坐标系之间的转换方法对于GIS开发者来说至关重要。本文将介绍几种常见的地理坐标系，并通过QGIS软件中的GeoHey Toolbox插件来演示如何进行坐标系之间的转换。</p><h2 id="常用地理坐标系介绍"><a href="#常用地理坐标系介绍" class="headerlink" title="常用地理坐标系介绍"></a>常用地理坐标系介绍</h2><p><strong>1. WGS 84 (World Geodetic System 1984)</strong></p><p>WGS 84是全球定位系统（GPS）所使用的标准坐标系，也是目前最常用的地理坐标系之一。它是一个基于地球椭球模型的坐标系，用于描述地球上的位置。广泛应用于全球导航卫星系统（GNSS）、互联网地图服务等。</p><p><strong>2. CGCS 2000 (China Geodetic Coordinate System 2000)</strong></p><p> CGCS 2000是中国最新的大地坐标系，它基于一个更精确的地球模型——GRS80椭球体。该坐标系旨在提高中国领土上地理信息的精度。主要在中国国内的地图制作、国土测绘等领域使用。</p><p><strong>3. 火星坐标系 (GCJ-02)</strong></p><p>火星坐标系并非真正意义上的“火星”坐标系，而是中国政府为了保护国家地理信息安全而设计的一种加密坐标系。它基于WGS 84坐标系，但对坐标值进行了偏移处理。 主要应用于国内的地图服务商如<strong>高德地图</strong>等提供的在线地图服务中。</p><p><strong>4. BD-09</strong></p><p> BD-09是百度地图使用的坐标系，它同样是对WGS 84进行了加密处理后的坐标系，但其加密算法与火星坐标系略有不同，专为百度地图设计，确保用户数据的安全性和准确性。</p><h2 id="使用QGIS进行坐标系转换"><a href="#使用QGIS进行坐标系转换" class="headerlink" title="使用QGIS进行坐标系转换"></a>使用QGIS进行坐标系转换</h2><h3 id="GeoHey-Toolbox-转换"><a href="#GeoHey-Toolbox-转换" class="headerlink" title="GeoHey Toolbox 转换"></a>GeoHey Toolbox 转换</h3><p>GeoHey Toolbox 是一款由国人开发的QGIS开源插件，专门用于解决中国特有的坐标系转换问题。它支持多种常见的坐标系转换，具体包括：</p><ul><li>BD-09 to GCJ-02</li><li>BD-09 to WGS-84</li><li>GCJ-02 to BD-09</li><li>GCJ-02 to WGS-84</li><li>WGS-84 to BD-09</li><li>WGS-84 to GCJ-02</li></ul><p><strong>安装与使用</strong></p><p><strong>安装</strong>: 在QGIS中打开插件管理器，搜索“GeoHey Toolbox”，找到后点击安装。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410290923918.png" alt="安装插件"></p><p><strong>使用</strong>: 安装完成后，在QGIS主界面找到GeoHey Toolbox工具栏或菜单项，选择你需要执行的坐标转换任务。以从WGS-84转到GCJ-02为例，选择相应的转换选项，然后指定输入图层。为了便于后续使用，建议点击输出选项中的三个小点，选择将结果保存为JSON格式文件或其他适合前端使用的格式。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410290925405.png" alt="插件使用"></p><h3 id="WGS-84与CGCS-2000的转换"><a href="#WGS-84与CGCS-2000的转换" class="headerlink" title="WGS-84与CGCS-2000的转换"></a>WGS-84与CGCS-2000的转换</h3><p>对于WGS-84与CGCS-2000之间的转换，由于这两个坐标系都是基于地球椭球模型的地理坐标系，因此可以通过简单的重投影来完成转换。在QGIS中，你可以直接使用“矢量”菜单下的“数据管理工具”-&gt;“重投影图层”来进行操作。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410290929471.png" alt="重投影图层"></p><p>Python</p><p>使用 Python coordTransform 转换</p><p>pip install coordTransform</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> coordTransform <span class="hljs-keyword">as</span> ct<br><br>lng = <span class="hljs-number">128.543</span><br>lat = <span class="hljs-number">37.065</span><br><br><span class="hljs-comment">#火星坐标系-&gt;百度坐标系</span><br>result1 = ct.gcj02_to_bd09(lng, lat)<br><span class="hljs-comment">#百度坐标系-&gt;火星坐标系</span><br>result2 = ct.bd09_to_gcj02(lng, lat)<br><span class="hljs-comment">#WGS84坐标系-&gt;火星坐标系</span><br>result3 = ct.wgs84_to_gcj02(lng, lat)<br><span class="hljs-comment">#火星坐标系-&gt;WGS84坐标系</span><br>result4 = ct.gcj02_to_wgs84(lng, lat)<br><span class="hljs-comment">#百度坐标系-&gt;WGS84坐标系</span><br>result5 = ct.bd09_to_wgs84(lng, lat)<br><span class="hljs-comment">#WGS84坐标系-&gt;百度坐标系</span><br>result6 = ct.wgs84_to_bd09(lng, lat)<br><br><span class="hljs-built_in">print</span> (result1, result2, result3, result4, result5, result6)<br></code></pre></td></tr></table></figure><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>理解和掌握不同地理坐标系的特点及转换方法，对于从事GIS相关工作的人员来说是非常重要的。通过使用专业的工具如QGIS及其插件，我们可以高效地完成复杂的坐标系转换工作，从而促进不同来源地理数据的整合与应用。希望本文能够帮助读者更好地理解地理坐标系的概念，并掌握实用的坐标转换技巧。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>qgis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QGIS 矢量分析 计算行政区划内河流长度</title>
    <link href="/2024/10/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/QGIS%20%E7%9F%A2%E9%87%8F%E5%88%86%E6%9E%90%20%E8%AE%A1%E7%AE%97%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E5%86%85%E6%B2%B3%E6%B5%81%E9%95%BF%E5%BA%A6/"/>
    <url>/2024/10/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/QGIS%20%E7%9F%A2%E9%87%8F%E5%88%86%E6%9E%90%20%E8%AE%A1%E7%AE%97%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%88%92%E5%86%85%E6%B2%B3%E6%B5%81%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>要计算各行政区划中的河流长度，需要用到 GIS 矢量分析，对于这类计算，QGIS 丰富的工具库可以轻松实现。</p><h2 id="数据准备及工具"><a href="#数据准备及工具" class="headerlink" title="数据准备及工具"></a>数据准备及工具</h2><p>图层：</p><ul><li><strong>水系图层</strong>：包含河流的线图层，属性表包括流域、河流等级等。</li><li><strong>行政区划图层</strong>：包含行政边界的多边形图层。属性表包括镇街名称，编码等。<br>注意图层坐标系应用投影坐标系，如果是地理坐标系，利用 QGIS 的 <strong>重投影图层</strong> 工具进行转换。</li></ul><p>工具：<br>QGIS 3.34</p><h2 id="矢量分析"><a href="#矢量分析" class="headerlink" title="矢量分析"></a>矢量分析</h2><p>在矢量分析之前可以通过筛选，选择想要的河流级别、流域，以及分析的镇街等。<br>筛选示例：右键-过滤输入表达式：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp"><span class="hljs-string">&quot;show_level&quot;</span> IN (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) AND <span class="hljs-string">&quot;ly&quot;</span> IN (&#x27;A&#x27;, &#x27;B&#x27;)<br></code></pre></td></tr></table></figure><p>工具箱搜索“计算线总长”，进行矢量分析，或者点击矢量-分析工具-计算线总长。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410221136724.png" alt="image.png"></p><p>选择行政区划、水系等图层点击运行即可。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410221137333.png" alt="image.png"></p><p>打开结果图层属性表可以看到增加了长度和数量两个图层。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410221140360.png" alt="image.png"></p><p>为了更好地展示各镇街的河流长度占比，可以对结果图层进行简单的符号化处理。例如，可以使用分级颜色或渐变颜色来表示不同的长度区间。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410221149146.png" alt="image.png"></p><p>相较于商业软件如 ArcGIS，QGIS 作为开源工具具有操作简单、启动快捷、易上手等优点，非常适合进行 GIS 简单分析。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
      <tag>水文分析</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pycharm 中 python 解释器如何选择</title>
    <link href="/2024/10/16/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/pycharm%20%E4%B8%AD%20python%20%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/"/>
    <url>/2024/10/16/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/pycharm%20%E4%B8%AD%20python%20%E8%A7%A3%E9%87%8A%E5%99%A8%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在使用 PyCharm 或其他 Python 开发环境时，选择合适的 Python 解释器对于项目的开发非常重要。关系到包的管理，项目文件的大小。本文分析几种常见 Python 环境管理工具（<code>venv</code>、<code>conda</code>、<code>pipenv</code>、<code>poetry env</code>）的优缺点。</p><p>经过对比尝试后，个人比较推荐用 <code>conda</code> 环境作为学习研究，他自带数据分析相关的包，但过于臃肿，建议用 <code>venv</code> 作为实际项目环境搭建，更加简洁直观，易于管理与发布。</p><h2 id="如何设置-python-解释器"><a href="#如何设置-python-解释器" class="headerlink" title="如何设置 python 解释器"></a>如何设置 python 解释器</h2><p>设置-python 解释器-选择核实的解释器。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410161609834.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410161610117.png" alt="image.png"></p><p>然后在项目结构中添加内容根，这样 pycharm 会将其视为 library 根目录，git 也不会同步这部分。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202411142109449.png" alt="image.png"></p><h2 id="各环境优缺点分析"><a href="#各环境优缺点分析" class="headerlink" title="各环境优缺点分析"></a>各环境优缺点分析</h2><h3 id="1-venv-Virtual-Environment"><a href="#1-venv-Virtual-Environment" class="headerlink" title="1. venv (Virtual Environment)"></a>1. venv (Virtual Environment)</h3><p><strong>优点</strong>:</p><ul><li><strong>轻量级</strong>：<code>venv</code> 是 Python 自带的一个模块，不需要额外安装。</li><li><strong>简单易用</strong>：创建和管理虚拟环境非常直观。</li><li><strong>广泛支持</strong>：几乎所有现代的 Python 版本都支持 <code>venv</code>。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>功能有限</strong>：相比其他工具，<code>venv</code> 的功能较为基础，缺少一些高级特性。</li><li><strong>依赖管理</strong>：依赖项管理主要通过 <code>requirements.txt</code> 文件，不如 <code>pipenv</code> 和  poetry&#96; 那样灵活和强大。</li></ul><h3 id="2-conda"><a href="#2-conda" class="headerlink" title="2. conda"></a>2. conda</h3><p><strong>优点</strong>:</p><ul><li><strong>跨平台</strong>：支持 Windows、macOS 和 Linux。</li><li><strong>包管理</strong>：不仅管理 Python 包，还管理其他语言的包。</li><li><strong>环境隔离</strong>：强大的环境管理功能，可以轻松创建和切换多个环境。</li><li><strong>科学计算</strong>：特别适合科学计算和数据科学项目，因为许多科学计算库都有预编译的包。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>体积较大</strong>：安装 <code>conda</code> 本身需要较大的磁盘空间。</li><li><strong>速度较慢</strong>：相比于 <code>pip</code>，<code>conda</code> 的安装速度可能较慢。</li><li><strong>社区生态</strong>：虽然 <code>conda</code> 的生态系统在不断壮大，但某些最新的 Python 包可能没有及时更新到 <code>conda-forge</code> 仓库中。</li></ul><h3 id="3-pipenv"><a href="#3-pipenv" class="headerlink" title="3. pipenv"></a>3. pipenv</h3><p><strong>优点</strong>:</p><ul><li><strong>依赖锁定</strong>：通过 <code>Pipfile</code> 和 <code>Pipfile.lock</code> 文件管理依赖项，确保不同环境中依赖项的一致性。</li><li><strong>自动管理</strong>：自动管理虚拟环境，简化了环境的创建和激活过程。</li><li><strong>集成测试</strong>：支持集成测试环境的管理。</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>性能问题</strong>：在某些情况下，<code>pipenv</code> 的依赖解析速度可能较慢。</li><li><strong>兼容性</strong>：某些复杂的依赖关系可能导致解析失败。</li></ul><h3 id="4-poetry-env-Poetry"><a href="#4-poetry-env-Poetry" class="headerlink" title="4. poetry env (Poetry)"></a>4. poetry env (Poetry)</h3><p><strong>优点</strong>:</p><ul><li><strong>依赖管理</strong>：强大的依赖管理功能，支持依赖锁定和版本管理。</li><li><strong>构建工具</strong>：不仅仅是环境管理工具，还可以作为构建工具，支持打包和发布 Python 包。</li><li><strong>自动化</strong>：支持自动化脚本，可以方便地集成到 CI&#x2F;CD 流程中。</li><li><strong>灵活性</strong>：配置文件 <code>pyproject.toml</code> 非常灵活，可以管理项目的各个方面。<br><strong>缺点</strong>:</li><li><strong>学习曲线</strong>：相对于 <code>venv</code> 和 <code>pipenv</code>，<code>poetry</code> 的学习曲线可能稍陡。</li><li><strong>社区支持</strong>：尽管 <code>poetry</code> 的社区正在快速增长，但在某些方面可能还不如 <code>conda</code> 和 <code>pip</code> 成熟。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>venv</strong>：适合简单的项目和快速原型开发，因为它轻量且易于使用。</li><li><strong>conda</strong>：适合科学计算和数据科学项目，特别是那些需要跨语言包管理的项目。</li><li><strong>pipenv</strong>：适合需要严格依赖管理和多环境支持的项目。</li><li><strong>poetry</strong>：适合大型项目和需要高级依赖管理和构建工具的项目。</li></ul><p>Venv 环境非常好用，原因是他将项目所需要的包就放在编辑文件下，且没有其他无关的包，这样就非常好控制。项目也不会特别庞大。</p><h2 id="如何在-cmd-中激活-venv"><a href="#如何在-cmd-中激活-venv" class="headerlink" title="如何在 cmd 中激活. venv"></a>如何在 cmd 中激活. venv</h2><ol><li>指向 到所在目录</li></ol><p><strong>切换到同一驱动器上的另一个目录</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">cd</span> D:\BaiduSyncdisk\pythonprograms\data_analytics<br></code></pre></td></tr></table></figure><p><strong>切换到不同驱动器上的目录</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">D:</span><br><span class="hljs-function"><span class="hljs-title">cd</span> \<span class="hljs-title">BaiduSyncdisk</span>\<span class="hljs-title">pythonprograms</span>\<span class="hljs-title">data_analytics</span></span><br></code></pre></td></tr></table></figure><p>激活 venv 环境</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">.\.venv\Scripts\Activate<br>.\.myvenv\Scripts\Activate<br></code></pre></td></tr></table></figure><p>项目搭建好后，不用启动 pycharm 等 ide，激活 venv 环境，就可以在命令提示符中运行了。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410161601290.png" alt="image.png"></p><p>执行策略报警<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410292109976.png" alt="image.png"></p><p><strong>以管理员身份打开PowerShell</strong>：右键点击PowerShell图标，选择“以管理员身份运行”。</p><p><strong>设置新的执行策略</strong>：<br>如果你需要允许运行所有脚本（包括从互联网下载的），可以使用<code>Unrestricted</code>策略，但这通常不推荐，因为它可能引入安全风险：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Set</span>-ExecutionPolicy <span class="hljs-comment">Unrestricted</span><br></code></pre></td></tr></table></figure><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 plottable 美化表格 构建水质监测数据看板</title>
    <link href="/2024/10/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%88%A9%E7%94%A8%20plottable%20%E7%BE%8E%E5%8C%96%E8%A1%A8%E6%A0%BC%20%E6%9E%84%E5%BB%BA%E6%B0%B4%E8%B4%A8%E7%9B%91%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9C%8B%E6%9D%BF/"/>
    <url>/2024/10/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%88%A9%E7%94%A8%20plottable%20%E7%BE%8E%E5%8C%96%E8%A1%A8%E6%A0%BC%20%E6%9E%84%E5%BB%BA%E6%B0%B4%E8%B4%A8%E7%9B%91%E6%B5%8B%E6%95%B0%E6%8D%AE%E7%9C%8B%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>在数据分析中，表格是最常用的展现形式之一，但普通的表格往往缺乏视觉吸引力，导致数据的可读性和理解性较差。<code>plottable</code> 是一个专门为 Matplotlib 设计的表格美化库，操作简便，能够轻松实现丰富的颜色渐变、行距调整等。最近，我尝试使用 <code>plottable</code> 制作水质站点的实时数据看板，记录整个操作过程如下。</p><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>普通表格展现<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410111512007.png" alt="image.png"><br>Plottable 美化后<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410111514246.png" alt="image.png"></p><p>我只是做了简单的颜色渐变，行距等设置，这样能够更加直观的看到超标站点及因子的情况。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先准备实时数据表格，我这里是df_pivot。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib  <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt  <br><span class="hljs-keyword">from</span> matplotlib.colors <span class="hljs-keyword">import</span> LinearSegmentedColormap  <br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st  <br><span class="hljs-keyword">from</span> plottable <span class="hljs-keyword">import</span> ColumnDefinition, ColDef, Table  <br><span class="hljs-keyword">from</span> plottable.cmap <span class="hljs-keyword">import</span> normed_cmap<br><br>fig, ax = plt.subplots(figsize=(<span class="hljs-number">18</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">300</span>)  <br>  <br>cmap = LinearSegmentedColormap.from_list(  <br>    name=<span class="hljs-string">&quot;高锰酸盐指数&quot;</span>, colors=[<span class="hljs-string">&quot;#ffffff&quot;</span>, <span class="hljs-string">&quot;#f2fbd2&quot;</span>, <span class="hljs-string">&quot;#c9ecb4&quot;</span>, <span class="hljs-string">&quot;#93d3ab&quot;</span>, <span class="hljs-string">&quot;#35b0ab&quot;</span>], N=<span class="hljs-number">256</span>  <br>)    <br>  <br>col_defs = [ColumnDefinition(name=<span class="hljs-string">&quot;index&quot;</span>, textprops=&#123;<span class="hljs-string">&quot;ha&quot;</span>: <span class="hljs-string">&quot;left&quot;</span>&#125;),  <br>            ColumnDefinition(name=<span class="hljs-string">&quot;高锰酸盐指数&quot;</span>, cmap=normed_cmap(df_pivot[<span class="hljs-string">&quot;高锰酸盐指数&quot;</span>], cmap=matplotlib.cm.RdYlGn_r, num_stds=<span class="hljs-number">2.5</span>)),  <br>            ColumnDefinition(name=<span class="hljs-string">&quot;氨氮&quot;</span>, cmap=cmap),  <br>            ColumnDefinition(name=<span class="hljs-string">&quot;总磷&quot;</span>, cmap=matplotlib.cm.Reds)]  <br>  <br>tab = Table(df_pivot,  <br>            column_definitions=col_defs)<br><br><span class="hljs-comment">#fig.show()</span><br>st.pyplot(fig)<br></code></pre></td></tr></table></figure><p>代码非常简单，plottable 生成的图片和 matplotlib 是一样的，所以可以直接用fig.show() 展示，也可以在 streamlit 中用st.pyplot(fig) 展示。<br>需要注意的是，渐变色如果直接调用类似matplotlib.cm.Reds，数据集需要时 0-1 之间，超过 1 需要用到LinearSegmentedColormap 进行自定义了。</p><p>plottable 不仅是用到色块渐变色，还有文本渐变色，文本符号等等，可以在官方 docs 中去进一步学习。</p><h3 id="补充知识-Matplotlib-默认颜色映射"><a href="#补充知识-Matplotlib-默认颜色映射" class="headerlink" title="补充知识-Matplotlib 默认颜色映射"></a>补充知识-Matplotlib 默认颜色映射</h3><p>Matplotlib 提供了大量的颜色映射（colormaps），可以用于绘制图表中的颜色渐变。这些颜色映射分为几个类别，包括但不限于顺序（Sequential）、发散（Diverging）、定性（Qualitative）和循环（Cyclic）等。下面是一些常用的颜色映射：</p><h3 id="顺序颜色映射（Sequential-Colormaps）"><a href="#顺序颜色映射（Sequential-Colormaps）" class="headerlink" title="顺序颜色映射（Sequential Colormaps）"></a>顺序颜色映射（Sequential Colormaps）</h3><ul><li><code>Blues</code>: 蓝色系列</li><li><code>Reds</code>: 红色系列（你提到的）</li><li><code>Greens</code>: 绿色系列</li><li><code>Oranges</code>: 橙色系列</li><li><code>Purples</code>: 紫色系列</li><li><code>Greys</code>: 灰色系列</li><li><code>YlGn</code>: 黄绿系列</li><li><code>YlOrBr</code>: 黄橙棕系列</li><li><code>YlOrRd</code>: 黄橙红系列</li><li><code>OrRd</code>: 橙红系列</li><li><code>PuRd</code>: 紫红系列</li><li><code>BuGn</code>: 蓝绿系列</li><li><code>PuBu</code>: 紫蓝系列</li><li><code>GnBu</code>: 绿蓝系列</li><li><code>PuBuGn</code>: 紫蓝绿系列</li><li><code>BuPu</code>: 蓝紫系列</li><li><code>RdPu</code>: 红紫系列</li><li><code>RdYlGn</code>: 红黄绿系列</li></ul><h3 id="发散颜色映射（Diverging-Colormaps）"><a href="#发散颜色映射（Diverging-Colormaps）" class="headerlink" title="发散颜色映射（Diverging Colormaps）"></a>发散颜色映射（Diverging Colormaps）</h3><ul><li><code>RdBu</code>: 红蓝对比</li><li><code>PRGn</code>: 粉红绿对比</li><li><code>BrBG</code>: 棕绿对比</li><li><code>PiYG</code>: 桃红绿对比</li><li><code>RdGy</code>: 红灰对比</li><li><code>RdYlBu</code>: 红黄蓝对比</li><li><code>Spectral</code>: 彩虹色系</li><li><code>coolwarm</code>: 冷暖对比</li></ul><h3 id="定性颜色映射（Qualitative-Colormaps）"><a href="#定性颜色映射（Qualitative-Colormaps）" class="headerlink" title="定性颜色映射（Qualitative Colormaps）"></a>定性颜色映射（Qualitative Colormaps）</h3><ul><li><code>Set1</code>, <code>Set2</code>, <code>Set3</code>: 不同的色彩集合，适合于分类数据</li><li><code>Paired</code>: 配对的颜色序列</li><li><code>Pastel1</code>, <code>Pastel2</code>: 柔和色调的色彩集合</li><li><code>Dark2</code>: 深色调的色彩集合</li></ul><h3 id="循环颜色映射（Cyclic-Colormaps）"><a href="#循环颜色映射（Cyclic-Colormaps）" class="headerlink" title="循环颜色映射（Cyclic Colormaps）"></a>循环颜色映射（Cyclic Colormaps）</h3><ul><li><code>twilight</code>: 昼夜交替的效果</li><li><code>twilight_shifted</code>: 移位的昼夜交替效果</li><li><code>hsv</code>: 基于HSV颜色模型的循环颜色映射</li></ul><p>如果你想使用反向颜色映射，可以简单地在颜色映射名称后面加上 <code>_r</code>，例如 <code>RdYlGn_r</code> 会得到从绿色到黄色再到红色的渐变。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>plottable 官方 docs</p><p><a href="https://plottable.readthedocs.io/en/latest/index.html">https://plottable.readthedocs.io/en/latest/index.html</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>经验分享</tag>
      
      <tag>工作总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无需虚拟机，让你在PC上使用安卓应用</title>
    <link href="/2024/10/07/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%97%A0%E9%9C%80%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%9C%A8PC%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8/"/>
    <url>/2024/10/07/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%97%A0%E9%9C%80%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E8%AE%A9%E4%BD%A0%E5%9C%A8PC%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>微软的Windows 11曾推出过内置安卓子系统，但“微软大刀”岂是浪得虚名，今年上半年宣布后续将放弃更新。可能是缺乏盈利模式，毕竟在 Windows 系统中运行虚拟机就能够实现相同的效果。<br>最近发现一个超级厉害的类虚拟机应用，就是电脑端 QQ 浏览器的手机模式。</p><p>QQ 浏览器更新至 13.1，就会有手机模式。点击浏览器侧边栏图标就可以进入。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410070954271.png" alt="image.png"></p><p>首次进入会加载应用宝及虚拟机环境，在 win 11 中与 hyper-v 虚拟平台不兼容，需要二选一。<br>使用下来感觉几乎和 Windows 11 的安卓子系统难分伯仲，而且配置操作更简单，不限制系统，适应性更强。</p><p>QQ 浏览器的手机模式不仅可以使用适配了的应用，也可以使用任意手机 apk，我测试了夸克浏览器，没有任何问题。可以算一个没有广告，启动非常方便的虚拟机。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410070958497.png" alt="image.png"></p><p>安装第三方应用只需要在任意 app 的右上角，点击三横标志，导入 apk 即可。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410071003229.png" alt="image.png"></p><p>也可以在应用宝界面直接搜索，甚至可以直接使用小程序。App 需要是 QQ 浏览器验证过的，算是半封闭的吧。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410071004999.png" alt="image.png"></p><p>打通电脑和手机端，有很多种解决方案，QQ 浏览器电脑端应该是比较方便的。</p><p>最后需要注意的是，这种方式会杀掉 hyper-v，会影响 Windows 11 内置安卓子系统使用。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>掌控习惯读书笔记</title>
    <link href="/2024/10/01/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8E%8C%E6%8E%A7%E4%B9%A0%E6%83%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/01/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8E%8C%E6%8E%A7%E4%B9%A0%E6%83%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 掌控习惯：如何养成好习惯并戒除坏习惯（《原子习惯》中文版）（新版）</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/25/yuewen_26934843/t7_yuewen_269348431702464198.jpg" alt=" 掌控习惯：如何养成好习惯并戒除坏习惯（《原子习惯》中文版）（新版）|200"></li><li>书名： 掌控习惯：如何养成好习惯并戒除坏习惯（《原子习惯》中文版）（新版）</li><li>作者： 詹姆斯·克利尔</li><li>简介： 《掌控习惯》是一部系统且深入教授人们如何养成好习惯、戒除坏习惯的行动指南书。<br>为什么“习惯改变命运”？因为个人 40%～50%的行为取决于无意识的习惯。而形成习惯需要 4 步：提示→渴求→反应→奖励。提示触发渴求，渴求激发反应，而反应则提供满足渴求的奖励，并蕞终与提示相关联。美国著名习惯研究专家詹姆斯·克利尔根据这 4 个步骤，总结了相对应的培养习惯的 4 大定律：让它显而易见；让它有吸引力；让它简便易行；让它令人愉悦。本书通过这 4 大定律、56 个具体案例，帮助你快速养成良好的习惯，同时利用这 4 大定律的对立面帮助你戒除不良的习惯。</li><li>出版时间 2023-11-01 00:00:00</li><li>ISBN： 9787559640765</li><li>分类： 个人成长-认知思维</li><li>出版社： 北京联合出版公司</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/bcb32150719afe3bbcbad52">https://weread.qq.com/web/reader/bcb32150719afe3bbcbad52</a></li></ul></blockquote><p>这本书是今年读到的最好的书之一了，至少可以排进前三，仔细做了总结，以防遗忘。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li>微习惯影响深远意义重大</li><li>习惯塑造身份，身份推动习惯坚持</li><li>培养习惯的四步法</li></ul><h3 id="微习惯的意义"><a href="#微习惯的意义" class="headerlink" title="微习惯的意义"></a>微习惯的意义</h3><p>习惯与投资、意志力、锻炼、情绪、人际关系、知识积累、消极思想一样都符合复利原则，每天坚持越强大，用进废退，不断递进。持续小习惯会带来大的改变，一个习惯如果坚持足够长时间，会节约精力投入，就像开车一样。好习惯会创造极大的价值，坏习惯影响一生，难以改变。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410060854424.png" alt="复利效应"></p><p>习惯的积累有量变到质变的过程，点滴变化或许不起眼，坚持才能到达新的境界。<br>潜能蓄积期是指，习惯坚持一段时间，但无明显改变的平台期。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410060904116.png" alt="image.png"></p><p>外界只在关注重大改变时刻，会认为他人在一夜之间取得成功，而无视之前漫长的累积过程。<br>在积累的过程中会被缓慢的改变和漫长的时间吓倒，因为没有看到显著改变而陷入失望之谷，从而放弃好习惯。</p><blockquote><p>戒除坏习惯犹如连根拔起我们内心枝繁叶茂的橡树，而培养好习惯则像每天不忘浇水，悉心培育一株娇嫩的鲜花。</p></blockquote><h4 id="建立微习惯体系，忘记目标，专注于体系"><a href="#建立微习惯体系，忘记目标，专注于体系" class="headerlink" title="建立微习惯体系，忘记目标，专注于体系"></a>建立微习惯体系，忘记目标，专注于体系</h4><p>面对复杂且重要的问题，达成目标需要建立一个复杂的解决方案，这个方案就对应微习惯的体系。<br>忘记目标，不要盯着目标不放，专注于每一个分解步骤，分步做好，结果成自然。这也引导出后文习惯塑造人的几个方面的内容。</p><p>如果专注于目标有以下三个问题：</p><ol><li>影响赢家和输家的心态，导致成王败寇的心理。</li><li>完成目标后，习惯随之结束，治标不治本，例如偶尔的大扫除与随手整理习惯之间区别，前者可能短期完成房间的清洁，但并不会改变你邋遢与囤积癖的毛病。</li><li>目标束缚了幸福感，专注于目标会轻视过程，导致对结果的过分看重，而忽视了更长时间累积过程的体验，减少了幸福感。</li></ol><p>专注于体系，让我们爱上过程，不必等待结果到来所带来的快乐，只要养着自己建立的体系前进，就会在整个过程感受到快乐。</p><h2 id="行为改变的层次"><a href="#行为改变的层次" class="headerlink" title="行为改变的层次"></a>行为改变的层次</h2><p>文中提到行为改变包括三个层次，读完后我觉得可以是四个：结果、过程、身份、精神。这四个层次逐渐递进，你的行为会产生结果、延续过程、塑造身份、形成精神。<br>而结果、过程、身份、精神会反过来影响你的习惯，推动改变和坚持习惯。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410091711556.png" alt="image.png"></p><h2 id="培养习惯的四步法"><a href="#培养习惯的四步法" class="headerlink" title="培养习惯的四步法"></a>培养习惯的四步法</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410091724608.png" alt="image.png"></p><p>习惯的形成经历的四个阶段：提示、渴求、反应、奖励<br>行为改变方法：塑造行为与戒除习惯的具体方法。</p><table><thead><tr><th>习惯形成阶段</th><th>培养好习惯</th><th>戒除习惯</th></tr></thead><tbody><tr><td>提示</td><td>让它显而易见</td><td>让它无从显现</td></tr><tr><td>渴求</td><td>让它有吸引力</td><td>让它缺乏吸引力</td></tr><tr><td>反应</td><td>让它简便易行</td><td>让它难以实行</td></tr><tr><td>奖励</td><td>让它令人愉悦</td><td>让它令人厌烦</td></tr><tr><td>记录自己的行为习惯，作者推荐了习惯积分卡，可以通过自己的方式记录，先了解自己的习惯。</td><td></td><td></td></tr></tbody></table><h3 id="提示阶段养成习惯的方法"><a href="#提示阶段养成习惯的方法" class="headerlink" title="提示阶段养成习惯的方法"></a>提示阶段养成习惯的方法</h3><ol><li>记录感受习惯，记录并留意习惯。</li><li>提示足够清晰：在什么时间什么地点做什么。</li><li>习惯叠加，在已有的习惯上叠加新的行为。</li><li>重视环境影响，营造适宜、强提醒的环境。不同场景做不同的事。<br>戒除习惯则反之。</li></ol><h3 id="在习惯养成不同阶段的多巴胺浓度变化"><a href="#在习惯养成不同阶段的多巴胺浓度变化" class="headerlink" title="在习惯养成不同阶段的多巴胺浓度变化"></a>在习惯养成不同阶段的多巴胺浓度变化</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410091609492.png" alt="image.png"></p><p>A): 学习一个习惯之前，多巴胺在得到奖励时被激发出来。<br>B): 下一次遇到，会在采取行动前被激发。<br>C): 当提示并采取行动后，没有得到奖励，多巴胺因为失望而降低。<br>D): 奖励姗姗来迟时，多巴胺会先降低后飙升。</p><p>激发我们采取行动的原动力来自奖励的期待之时，即欲望，而非期待得到满足的那一刻。</p><h3 id="渴求阶段养成习惯的方法"><a href="#渴求阶段养成习惯的方法" class="headerlink" title="渴求阶段养成习惯的方法"></a>渴求阶段养成习惯的方法</h3><ol><li>利用诱惑绑定，永期望的行为强化你需要的动作</li><li>利用亲友、偶像等榜样力量，提高驱动力。</li><li>在困难任务前，给自己一个独特而轻松的启动仪式，鼓励自己。</li><li>放松、劳逸结合，给自己补充足够的意志力能量槽。</li></ol><h3 id="善待每天的决定性时刻"><a href="#善待每天的决定性时刻" class="headerlink" title="善待每天的决定性时刻"></a>善待每天的决定性时刻</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410091629030.png" alt="image.png"><br>每天都会做无数个决定，这些看似不起眼的决定，日积月累会导致截然不同的结果。<br>而每个长期行动前都有一个做决定的启动时刻。请善待每一个决定时刻。</p><h3 id="反应阶段养成习惯的方法"><a href="#反应阶段养成习惯的方法" class="headerlink" title="反应阶段养成习惯的方法"></a>反应阶段养成习惯的方法</h3><ol><li>慢步向前，但绝不后退。</li><li>减少阻力，减少培养习惯的步骤。</li><li>创造一个有利于行动的环境。</li><li>把握好决定时刻，优化可以产生重大影响的小选择。</li><li>利用两分钟原则，缩短习惯占用的时间，将习惯动作演变为提示动作。</li><li>自动化你的习惯，让科技辅助习惯形成。</li></ol><h3 id="奖励阶段养成习惯的方法"><a href="#奖励阶段养成习惯的方法" class="headerlink" title="奖励阶段养成习惯的方法"></a>奖励阶段养成习惯的方法</h3><p>背景：人类是趋利避害的动物，即时奖励是最大的驱动力，而随着社会的进步，即时奖励与延迟奖励之间的存在脱节，延时奖励对人类的意义逐渐增大，但人的情绪并未完全适应。我们需要了解并适应这一特点。</p><ol><li>在延时奖励习惯中，主动增加即时奖励，完成分解动作后，立即奖励自己。</li><li>不要中断习惯，不要连续错过两次，如果忘了做，一定要补救。</li><li>记录习惯和结果，让进步可视化，推动坚持习惯。</li><li>给自己确定一个问责伙伴：知道别人在看着你，让无所事事成为即时成本</li></ol><h2 id="习惯培养进阶"><a href="#习惯培养进阶" class="headerlink" title="习惯培养进阶"></a>习惯培养进阶</h2><p>了解自己的性格，选择进步的方向，培养适合自己的习惯。</p><h3 id="金发女孩准则"><a href="#金发女孩准则" class="headerlink" title="金发女孩准则"></a>金发女孩准则</h3><p>金发女孩准则指出，凡事都必须有度，而不能超越极限，按照这一准则行事产生的效应被称为“金发女孩效应”。<br>人们在面对一个勉强能应付的挑战时，动力最充足，最容易出现心流状态。<br>找到自己的金发女孩区，不断精进，循序渐进。<br>每个人受到激励时都能努力工作。但当工作不那么令人兴奋时，仍能继续奋进的则是佼佼者。<br>成功的最大威胁不是失败，而是厌倦。<br>专业人士依照既定计划行事，毫不动摇；业余人士则随波逐流，任性而为。</p><h3 id="习惯的反思"><a href="#习惯的反思" class="headerlink" title="习惯的反思"></a>习惯的反思</h3><p>习惯的好处是我们可以不假思索地行事，坏处是我们不再关注小错误。<br>习惯动作+刻意练习&#x3D;精通<br>反思和回顾是一个过程，使你能够时刻关注自己的表现。<br>我们越是执着于一个身份，就越难超越它。<br>摆脱身份的束缚，需要提升至精神层面。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>降雨事件驱动的城市水体污染特征分析</title>
    <link href="/2024/09/24/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E9%99%8D%E9%9B%A8%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E6%B0%B4%E4%BD%93%E6%B1%A1%E6%9F%93%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/"/>
    <url>/2024/09/24/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E9%99%8D%E9%9B%A8%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%9F%8E%E5%B8%82%E6%B0%B4%E4%BD%93%E6%B1%A1%E6%9F%93%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着城市化进程的加快，城市水体污染问题日益突出。在众多污染源中，降雨带来的径流被认为是城市水体污染的一个重要因素。本文以 2023 年 1 月至 2024 年 9 月期间某站点的降雨数据及其关联的污染物数据为基础，探讨降雨情形下污染物的变化规律。以高锰酸盐指数、氨氮和总磷作为主要污染物指标，通过对这些指标在不同降雨事件中的表现进行分析，以期为城市水污染治理提供参考。</p><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><p>为了更好地理解降雨对污染物浓度的影响，首先定义了“降雨事件”这一概念。在本研究中，连续小时值均大于 0 的数值是为一个降雨事件，且连续无降雨超过 24 小时后视为不同的降雨事件，此外，只有当累计降雨量超过 10 毫米时，才会被计入我们的分析范围之内。<br>这样做是为了保证所选降雨事件具有一定的强度，能够对环境产生明显的影响。<br>分别计算每次降雨的开始时间、结束事件、累计雨量、最大小时雨量、降雨持续时间等特征。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python">data = pd.read_excel(<span class="hljs-string">&#x27;pages/datas/降雨量.xlsx&#x27;</span>)<br>  <br><span class="hljs-comment"># 转换为DataFrame  </span><br>columns = [<span class="hljs-string">&#x27;监测时间&#x27;</span>, <span class="hljs-string">&#x27;气温&#x27;</span>, <span class="hljs-string">&#x27;风力&#x27;</span>, <span class="hljs-string">&#x27;降雨量&#x27;</span>, <span class="hljs-string">&#x27;相对湿度&#x27;</span>] <br>df = pd.DataFrame(data, columns=columns)  <br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])   <br>df[<span class="hljs-string">&#x27;降雨量&#x27;</span>] = df[<span class="hljs-string">&#x27;降雨量&#x27;</span>].fillna(<span class="hljs-number">0</span>)  <br>df[<span class="hljs-string">&#x27;降雨量&#x27;</span>] = df[<span class="hljs-string">&#x27;降雨量&#x27;</span>].astype(<span class="hljs-built_in">float</span>)  <br><span class="hljs-comment"># 删除包含NaT的行  </span><br><span class="hljs-comment"># 将降雨量列中的空值和负数填充为0  </span><br>df[<span class="hljs-string">&#x27;降雨量&#x27;</span>] = df[<span class="hljs-string">&#x27;降雨量&#x27;</span>].replace(&#123;np.nan: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&lt;0&#x27;</span>: <span class="hljs-number">0</span>&#125;).astype(<span class="hljs-built_in">float</span>)  <br><span class="hljs-comment"># 确保所有降雨量都为非负数  </span><br>df[<span class="hljs-string">&#x27;降雨量&#x27;</span>] = df[<span class="hljs-string">&#x27;降雨量&#x27;</span>].clip(lower=<span class="hljs-number">0</span>) <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_rainfall</span>(<span class="hljs-params">df</span>):  <br>    <span class="hljs-comment"># 添加一列来标记降雨  </span><br>    df[<span class="hljs-string">&#x27;RainEvent&#x27;</span>] = (df[<span class="hljs-string">&#x27;降雨量&#x27;</span>] &gt; <span class="hljs-number">0</span>).astype(<span class="hljs-built_in">int</span>) <br>    <span class="hljs-comment"># 计算时间差  </span><br>    df[<span class="hljs-string">&#x27;TimeDiff&#x27;</span>] = df[<span class="hljs-string">&#x27;监测时间&#x27;</span>].diff().dt.total_seconds() / <span class="hljs-number">3600</span>  <br>    <span class="hljs-comment"># 初始化一个新事件的标志  </span><br>    df[<span class="hljs-string">&#x27;NewEvent&#x27;</span>] = <span class="hljs-literal">False</span>  <br>    <span class="hljs-comment"># 当时间差大于24小时时，设置为新事件  </span><br>    df.loc[df[<span class="hljs-string">&#x27;TimeDiff&#x27;</span>] &gt;= <span class="hljs-number">24</span>, <span class="hljs-string">&#x27;NewEvent&#x27;</span>] = <span class="hljs-literal">True</span>   <br>    <span class="hljs-comment"># 当前降雨与上一次降雨之间的状态变化时，标记为新事件  </span><br>    df.loc[(df[<span class="hljs-string">&#x27;RainEvent&#x27;</span>].shift() != df[<span class="hljs-string">&#x27;RainEvent&#x27;</span>]) &amp; (df[<span class="hljs-string">&#x27;TimeDiff&#x27;</span>] &lt; <span class="hljs-number">24</span>), <span class="hljs-string">&#x27;NewEvent&#x27;</span>] = <span class="hljs-literal">True</span>  <br>  <br>    <span class="hljs-comment"># 将第一行标记为新事件开始  </span><br>    df.loc[df.index[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;NewEvent&#x27;</span>] = <span class="hljs-literal">True</span>  <br>    <span class="hljs-comment"># 使用累加求和来给每个事件分配一个唯一的ID  </span><br>    df[<span class="hljs-string">&#x27;RainEventID&#x27;</span>] = df[<span class="hljs-string">&#x27;NewEvent&#x27;</span>].cumsum()  <br>    <span class="hljs-comment"># 对每场雨进行分组，计算开始时间、结束时间、累计降雨量和最大降雨量  </span><br>    rain_events_summary = df.groupby([<span class="hljs-string">&#x27;RainEventID&#x27;</span>]).agg(&#123;  <br>        <span class="hljs-string">&#x27;监测时间&#x27;</span>: [<span class="hljs-string">&#x27;min&#x27;</span>, <span class="hljs-string">&#x27;max&#x27;</span>],  <br>        <span class="hljs-string">&#x27;降雨量&#x27;</span>: [<span class="hljs-string">&#x27;sum&#x27;</span>, <span class="hljs-string">&#x27;max&#x27;</span>]  <br>    &#125;).reset_index()  <br>    <span class="hljs-comment"># 重命名列名  </span><br>    rain_events_summary.columns = [<span class="hljs-string">&#x27;RainEventID&#x27;</span>, <span class="hljs-string">&#x27;Start&#x27;</span>, <span class="hljs-string">&#x27;End&#x27;</span>, <span class="hljs-string">&#x27;TotalRainfall&#x27;</span>, <span class="hljs-string">&#x27;MaxRainfall&#x27;</span>]   <br>    <span class="hljs-comment"># 计算降雨持续时间  </span><br>    rain_events_summary[<span class="hljs-string">&#x27;DurationHours&#x27;</span>] = (rain_events_summary[<span class="hljs-string">&#x27;End&#x27;</span>] - rain_events_summary[  <br>        <span class="hljs-string">&#x27;Start&#x27;</span>]).dt.total_seconds() / <span class="hljs-number">3600</span>  <br>    rain_events_summary[<span class="hljs-string">&#x27;DurationHours&#x27;</span>] = rain_events_summary[<span class="hljs-string">&#x27;DurationHours&#x27;</span>] + <span class="hljs-number">1</span>  <br>    <span class="hljs-comment"># 过滤掉没有实际降雨的事件  </span><br>    rain_events_summary = rain_events_summary[rain_events_summary[<span class="hljs-string">&#x27;TotalRainfall&#x27;</span>] &gt; <span class="hljs-number">0</span>]   <br>    <span class="hljs-comment"># 检查并合并事件  </span><br>    merged_events = []  <br>    current_event = <span class="hljs-literal">None</span>  <br>    <span class="hljs-keyword">for</span> i, row <span class="hljs-keyword">in</span> rain_events_summary.iterrows():  <br>        <span class="hljs-keyword">if</span> current_event <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>            current_event = row  <br>        <span class="hljs-keyword">else</span>:  <br>            time_diff = row[<span class="hljs-string">&#x27;Start&#x27;</span>] - current_event[<span class="hljs-string">&#x27;End&#x27;</span>]  <br>            time_diff_hours = time_diff.total_seconds() / <span class="hljs-number">3600</span>  <br>            <span class="hljs-keyword">if</span> time_diff_hours &lt;= <span class="hljs-number">24</span>:  <br>                <span class="hljs-comment"># 合并事件  </span><br>                current_event[<span class="hljs-string">&#x27;End&#x27;</span>] = <span class="hljs-built_in">max</span>(current_event[<span class="hljs-string">&#x27;End&#x27;</span>], row[<span class="hljs-string">&#x27;End&#x27;</span>])  <br>                current_event[<span class="hljs-string">&#x27;TotalRainfall&#x27;</span>] += row[<span class="hljs-string">&#x27;TotalRainfall&#x27;</span>]  <br>                current_event[<span class="hljs-string">&#x27;MaxRainfall&#x27;</span>] = <span class="hljs-built_in">max</span>(current_event[<span class="hljs-string">&#x27;MaxRainfall&#x27;</span>], row[<span class="hljs-string">&#x27;MaxRainfall&#x27;</span>])  <br>                current_event[<span class="hljs-string">&#x27;DurationHours&#x27;</span>] = (current_event[<span class="hljs-string">&#x27;End&#x27;</span>] - current_event[<span class="hljs-string">&#x27;Start&#x27;</span>]).total_seconds() / <span class="hljs-number">3600</span>  <br>  <br>            <span class="hljs-keyword">else</span>:  <br>                <span class="hljs-comment"># 结束当前事件，开始新的事件  </span><br>                merged_events.append(current_event)  <br>                current_event = row  <br>    <span class="hljs-comment"># 添加最后一个事件  </span><br>    <span class="hljs-keyword">if</span> current_event <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <br>        merged_events.append(current_event)  <br>  <br>    <span class="hljs-comment"># 将合并后的事件转换为DataFrame  </span><br>    merged_df = pd.DataFrame(merged_events)  <br>    merged_df[<span class="hljs-string">&#x27;RainEventID&#x27;</span>] = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(merged_df) + <span class="hljs-number">1</span>)  <br>    <span class="hljs-keyword">return</span> merged_df  <br>  <br>  <br><span class="hljs-comment"># 应用函数并查看结果  </span><br>result = analyze_rainfall(df)  <br>min_total_rainfall = <span class="hljs-number">10</span>  <span class="hljs-comment"># 你可以根据需要调整这个值  </span><br><span class="hljs-comment"># 过滤掉累计雨量小于指定阈值的降雨场次  </span><br>rain_events_summary = result[result[<span class="hljs-string">&#x27;TotalRainfall&#x27;</span>] &gt;= min_total_rainfall]  <br><span class="hljs-comment"># 重新排序 RainEventID  </span><br>rain_events_summary.reset_index(drop=<span class="hljs-literal">True</span>, inplace=<span class="hljs-literal">True</span>)  <br><span class="hljs-comment"># 重新分配 </span><br>RainEventIDrain_events_summary[<span class="hljs-string">&#x27;RainEventID&#x27;</span>] = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(rain_events_summary) + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>经过统计，2023 年 1 月至 2024 年 9 月出有 35 次降雨事件，累计降雨量为 1476.40 毫米，其中属于降雨事件的降雨量达到了 1302.50 毫米，占比达 88.22%。因此用降雨事件分析对应的污染物浓度变化具有代表性。<br>降雨事件分布如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409241729163.png" alt="image.png"></p><p>接下来，对应每次降雨事件事件范围，计算出站点各污染物的最大浓度、平均浓度以及变差系数。<br>其中变差系数为一列数的标准差除以期望，反映数据的变化情况，一般大于 0.2，表面数据波动较大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载数据  </span><br>df_w = pd.read_excel(<span class="hljs-string">&#x27;pages/datas/datas.xlsx&#x27;</span>)  <span class="hljs-comment"># 假设这是污染物数据集    </span><br><span class="hljs-comment"># 将监测时间列转换为 datetime 类型  </span><br>df_w[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df_w[<span class="hljs-string">&#x27;监测时间&#x27;</span>])  <br>  <br><span class="hljs-comment"># 获取污染物因子的列名  </span><br>pollutant_columns = df_w.columns.drop([<span class="hljs-string">&#x27;监测时间&#x27;</span>])  <br>  <br><span class="hljs-comment"># 创建一个新的 DataFrame 来保存分析结果  </span><br>pollutant_stats = pd.DataFrame(columns=[<span class="hljs-string">&#x27;RainEventID&#x27;</span>] +  <br>                                       [<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col&#125;</span>_Ma&#x27;</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> pollutant_columns] +  <br>                                       [<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col&#125;</span>_Me&#x27;</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> pollutant_columns] +  <br>                                       [<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col&#125;</span>_Va&#x27;</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> pollutant_columns])  <br>  <br><span class="hljs-comment"># 遍历每个降雨事件  </span><br><span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> rain_events_summary.iterrows():  <br>    event_id = row[<span class="hljs-string">&#x27;RainEventID&#x27;</span>]  <br>    start_time = row[<span class="hljs-string">&#x27;Start&#x27;</span>]  <br>    end_time = row[<span class="hljs-string">&#x27;End&#x27;</span>]  <br>  <br>    <span class="hljs-comment"># 提取该事件时间段内的污染物数据  </span><br>    event_pollutants = df_w[(df_w[<span class="hljs-string">&#x27;监测时间&#x27;</span>] &gt;= start_time) &amp; (df_w[<span class="hljs-string">&#x27;监测时间&#x27;</span>] &lt;= end_time)]   <br>    <span class="hljs-comment"># 初始化统计数据  </span><br>    max_concentration = &#123;&#125;  <br>    mean_concentration = &#123;&#125;  <br>    variation_coefficient = &#123;&#125;  <br>  <br>    <span class="hljs-keyword">if</span> event_pollutants.empty:  <br>        <span class="hljs-comment"># 如果没有数据，记录为 NaN        </span><br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> pollutant_columns:  <br>            max_concentration[col] = np.nan  <br>            mean_concentration[col] = np.nan  <br>            variation_coefficient[col] = np.nan  <br>    <span class="hljs-keyword">else</span>:  <br>        <span class="hljs-comment"># 计算每个因子的最大浓度、平均浓度和变差系数  </span><br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> pollutant_columns:  <br>            <span class="hljs-keyword">if</span> col <span class="hljs-keyword">in</span> event_pollutants.columns <span class="hljs-keyword">and</span> pd.notna(event_pollutants[col]).<span class="hljs-built_in">any</span>():  <br>                max_concentration[col] = event_pollutants[col].<span class="hljs-built_in">max</span>()  <br>                mean_concentration[col] = event_pollutants[col].mean()  <br>                variation_coefficient[col] = event_pollutants[col].std(ddof=<span class="hljs-number">0</span>) / event_pollutants[col].mean()  <br>            <span class="hljs-keyword">else</span>:  <br>                max_concentration[col] = np.nan  <br>                mean_concentration[col] = np.nan  <br>                variation_coefficient[col] = np.nan  <br>  <br>    <span class="hljs-comment"># 构建统计数据行  </span><br>    stats_row = &#123;  <br>        <span class="hljs-string">&#x27;RainEventID&#x27;</span>: event_id  <br>    &#125;  <br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> pollutant_columns:  <br>        stats_row[<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col&#125;</span>_Ma&#x27;</span>] = max_concentration[col]  <br>        stats_row[<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col&#125;</span>_Me&#x27;</span>] = mean_concentration[col]  <br>        stats_row[<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;col&#125;</span>_Va&#x27;</span>] = variation_coefficient[col]  <br>  <br>    <span class="hljs-comment"># 将统计数据行添加到 DataFrame 中  </span><br>    pollutant_stats = pd.concat([pollutant_stats, pd.DataFrame(stats_row, index=[<span class="hljs-number">0</span>])], ignore_index=<span class="hljs-literal">True</span>)   <br><span class="hljs-comment"># 合并统计数据到 rainfall_summary 中  </span><br>rain_events_summary = pd.merge(rain_events_summary, pollutant_stats, on=<span class="hljs-string">&#x27;RainEventID&#x27;</span>, how=<span class="hljs-string">&#x27;left&#x27;</span>)<br></code></pre></td></tr></table></figure><p>得到统计结果如下：其中因子最大浓度、平均浓度超标处标记为红色，变差系数大于 0.2 的也标为红色。从结果得出，超过 10 mm 的降雨量会引起对应站点水质超标，氨氮最敏感、总磷次之。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409241731533.png" alt="image.png"></p><p>最后将各数据汇总，计算这些统计值之间的相关系数，并绘制相关性热图，得出单次降雨量、小时最大雨量与各指标的平均浓度、最大浓度并无强相关性；氨氮最大浓度与总磷最大浓度之间为强相关，符合污染物汇入特征。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409241732782.png" alt="image.png"></p><h2 id="小结与讨论"><a href="#小结与讨论" class="headerlink" title="小结与讨论"></a>小结与讨论</h2><ol><li><strong>污染物浓度超标现象</strong>：在各个降雨时间内，高锰酸盐指数、氨氮和总磷这三种主要污染物的最大浓度和平均浓度均存在超标现象。特别是氨氮的变差系数经常高于 0.2，表明其对降雨的响应较为敏感。</li><li><strong>降雨量与污染物浓度的关系</strong>：单次降雨量、小时最大雨量与各指标的平均浓度、最大浓度并无强相关性；总磷与小时最大降雨量之间相关性为 0.5，为中相关，降雨引起的污染物变化较为复杂，污染物浓度变化与降雨量强度之间并非简单的线性关系，可能涉及更多因素，如降雨稀释、降雨间隔、清洁程度、污染事件等。</li><li><strong>污染物间的相互作用</strong>：降雨引起的污染源汇入也导致各污染物之间的相关性增强。</li><li><strong>局限及展望</strong>：本文仍存在一定局限性。首先，数据的时间跨度有限，未来可以通过长时间序列数据分析，进一步确认这些规律的稳定性和普遍性。其次，研究对象集中在少数几种污染物，未来可以扩展到更多的污染物种类，以全面评估降雨对城市水体质量的影响。此外，本文仅分析了一个雨量站与水质站的数据，样本量较小。未来研究可以考虑扩大样本范围，收集更多站点的数据，进一步验证降雨事件对污染物浓度变化的影响，并探索其他潜在的影响因素。此外，可以通过模型模拟的方法，定量分析不同降雨模式下的污染物迁移和转化机制，为制定更有效的污染控制策略提供科学依据。</li><li><strong>管理建议</strong>：对于任何一次累计降雨量超过10毫米的情况，都需要引起管理者的重视。尤其是在高敏感区域，应加强监测频率，并采取有效措施减少污染物排放。</li></ol><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python in Excel 数据合并案例</title>
    <link href="/2024/09/20/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20in%20Excel%20%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%E6%A1%88%E4%BE%8B/"/>
    <url>/2024/09/20/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20in%20Excel%20%E6%95%B0%E6%8D%AE%E5%90%88%E5%B9%B6%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Python in Excel 出来很久了，但是平常用得比较少，最近遇到一个需求：根据第一列相同的序号将第二列（内容）对应的内容拼接在一起，用逗号连接，返回新的数据集。这种需求单独用 Excel 自带的合并功能是难以实现的。于是我想到了 python。记录一下处理过程，以此提醒还有这样一个强大的工具。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>根据第一列相同的序号将第二列（内容）对应的内容拼接在一起，用逗号连接，返回新的数据集。<br>以下是数据示例。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409201634852.png" alt="image.png"></p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>Excel 365，公式，插入 python，输入代码，完成，相当方便~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取表格</span><br>df = xl(<span class="hljs-string">&quot;A1:B11&quot;</span>, headers=<span class="hljs-literal">True</span>)<br>df[<span class="hljs-string">&#x27;内容&#x27;</span>] = df[<span class="hljs-string">&#x27;内容&#x27;</span>].astype(<span class="hljs-built_in">str</span>)<br>df[<span class="hljs-string">&#x27;合并内容&#x27;</span>] = df.groupby(<span class="hljs-string">&#x27;列名&#x27;</span>)[<span class="hljs-string">&#x27;内容&#x27;</span>].transform(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">&#x27;,&#x27;</span>.join(x))<br><span class="hljs-comment"># 然后可以选择只保留 &#x27;序号&#x27; 和 &#x27;合并内容&#x27; 列</span><br><span class="hljs-comment">#result</span><br>result = df[[<span class="hljs-string">&#x27;列名&#x27;</span>, <span class="hljs-string">&#x27;合并内容&#x27;</span>]].drop_duplicates()<br>result = result.reset_index()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409201652680.png" alt="image.png"></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>持续高温对重庆小流域水质的影响</title>
    <link href="/2024/09/14/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%8C%81%E7%BB%AD%E9%AB%98%E6%B8%A9%E5%AF%B9%E9%87%8D%E5%BA%86%E5%B0%8F%E6%B5%81%E5%9F%9F%E6%B0%B4%E8%B4%A8%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2024/09/14/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%8C%81%E7%BB%AD%E9%AB%98%E6%B8%A9%E5%AF%B9%E9%87%8D%E5%BA%86%E5%B0%8F%E6%B5%81%E5%9F%9F%E6%B0%B4%E8%B4%A8%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近年来，异常天气逐渐增多。据人民日报消息， 2024 年，三伏天从 7 月 15 日开始到 8 月 23 日结束，共 40 天。三伏天结束后，重庆仍未降温，以重庆渝西地区某公共气象站为例，入伏以来至 9 月 13日，超过最高气温35℃的天气共 59 天，占96.7%，超过 37℃共 30 天，占 49.2%。持续的高温天气对各行各业影响都比较大，对地表水质影响如何呢？<br>本文以渝西地区某流域考核断面为例，分析持续高温天气对其水质的影响。</p><h2 id="河流概况"><a href="#河流概况" class="headerlink" title="河流概况"></a>河流概况</h2><p> L 河属于长江左岸一级汇流，境内流域面积588.14km2，河流全长84.53km，比降2.28‰，多年平均流量为6.35m3&#x2F;s。C 断面为出境断面，也是考核控制断面，控制标准为Ⅲ类。C 断面河宽 50 m 左右，下游 4000m 有发电站闸坝。</p><h2 id="水质分析"><a href="#水质分析" class="headerlink" title="水质分析"></a>水质分析</h2><p> 7 月 10<del>9 月 13 日主要污染因子高锰酸盐指数与水温变化对比分析，前期（ 7 月 10</del>8月 17 日）水温与高锰酸盐指数并无明显关系，以上游污染物汇入为主要影响。后期 （8 月 17 日~9 月 13 日）水温与高锰酸盐指数相关性加强。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141028641.png" alt="image.png"></p><p>具体以 9 月 1 日~9 月 13 日数据对比为例，存在明显的相关关系。高锰酸盐指数波动超标，波峰出现在 16 时左右，波谷出现在 8 时左右。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141041150.png" alt="image.png"><br>除水温外，溶解氧、pH、浊度等均与高指呈现中强相关关系。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141047321.png" alt="溶解氧与高锰酸盐指数"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141049985.png" alt="pH和高锰酸盐指数"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141103396.png" alt="各指标相关性"></p><p>以 9 月 8 日至 9 月 14 日站点数据为例，高锰酸盐指数与溶解氧、水温、pH 的皮尔逊相关系数都大于 0.6，为中强关系。且波动期间均有类似现象。</p><p>根据调查，原因为水体富营养化导致，水体流动性差，颜色深绿，水面连片藻类分布。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141117707.png" alt="茨坝藻类.png"></p><p>自入伏高温以来，经过一段时间的发展，至 8 月下旬，该断面逐渐出现藻类爆发，藻类光合作用影响水体复氧过程，同时引起高锰酸盐指数周期波动。<br>每年的 3 月<del>5 月、8 月</del>9 月均可能出现藻类爆发现象，但由于今年高温持续时间长，降雨偏少，河道流动性差，藻类影响时间相应较长。</p><h2 id="历史年份对比分析"><a href="#历史年份对比分析" class="headerlink" title="历史年份对比分析"></a>历史年份对比分析</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141621058.png" alt="image.png"><br>对比近 4 年水温数据，2024 年小时水温虽不是最高，但高温天气持续时间长，波动小，也算是极端天气了。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141616648.png" alt="image.png"></p><p>对比近 4 年高锰酸盐指数数据，2022、2023 均有类似高日较差的周期波动，且 2023 年 2024 年持续时间更长。藻类活跃影响时间更长，判断依据主要是依据每日波动幅度。</p><h2 id="治理措施"><a href="#治理措施" class="headerlink" title="治理措施"></a>治理措施</h2><p>藻类爆发在重庆并非孤例，当温度、气温、流速适宜时，非常容易出现类似的情况。治理措施包括开启上下游闸坝提高流速、吸藻船打捞等方式，藻类爆发现象会随着气温降低而得到抑制，一般情况下并不会对年达标考核造成影响，但已出现年均值达标向月均值达标的从严考核倾向。由藻类爆发引起的水质超标也会逐渐受到重视。</p><h2 id="藻类影响特征识别"><a href="#藻类影响特征识别" class="headerlink" title="藻类影响特征识别"></a>藻类影响特征识别</h2><p>随着水质站点的普及，多因子的相关关系与水质污染特征有密切联系，以上述情况为例，将高指与水温、pH、溶解氧的相关关系建立联系，通过算法自动识别污染特征。当水质变化符合藻类影响特征时则发出报警信息，为水环境分析提供一定支持。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409141415110.png" alt="i藻类爆发特征分析"></p><p>当然不同水体断面情况也不尽相同，例如湖泊水体与河流不同，超标因子可能是总磷而非高锰酸盐指数，具体都可以根据历史水质因子变化结合现场调查分析，搭建对应的污染特征识别算法。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>气候变化之下，万物皆受影响。极端高温天气不仅导致电力系统承压，引起供电紧张，学校延迟开学，也会引起水体水质发生些微变化，当仔细对待的时候，让人搜肠刮肚，绞尽脑汁，finally，wish for world peace。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>streamlit 登录页面搭建及登录管理</title>
    <link href="/2024/09/10/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/streamlit%20%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%8F%8A%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <url>/2024/09/10/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/streamlit%20%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%8F%8A%E7%99%BB%E5%BD%95%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用 streamlit 搭建 web 页面比较容易，但要分享发布到互联网上，需要用到登录页面以进行验证，避免数据泄露和攻击。本文介绍如何简单快速的搭建登录页面。</p><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><p>通过构建 check_password 函数，快速搭建登录表格和判断依据，利用. streamlit&#x2F;secrets. toml 简单存储账号及密码。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409101430325.png" alt="image.png"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>主要参考了 streamlit docs，做了一点优化。参考文件见后文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python">  <br><span class="hljs-keyword">import</span> hmac  <br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_password</span>(): <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login_form</span>(): <br>        <span class="hljs-keyword">with</span> st.form(<span class="hljs-string">&quot;Credentials&quot;</span>):  <br>            col0,col1, col2 = st.columns([<span class="hljs-number">0.6</span>,<span class="hljs-number">0.4</span>, <span class="hljs-number">2</span>],vertical_alignment=<span class="hljs-string">&quot;top&quot;</span>)  <br>            <span class="hljs-keyword">with</span> col0:  <br>                st.write(<span class="hljs-string">&quot;  &quot;</span>)  <br>            <span class="hljs-keyword">with</span> col1:  <br>                st.image(<span class="hljs-string">&quot;./utils/logo.png&quot;</span>,  width=<span class="hljs-number">75</span>)  <br>            <span class="hljs-keyword">with</span> col2:  <br>                st.markdown(<span class="hljs-string">&quot;## 水环境分析百宝箱&quot;</span>)  <br>            st.text_input(<span class="hljs-string">&quot;账号名称&quot;</span>, key=<span class="hljs-string">&quot;username&quot;</span>)  <br>            st.text_input(<span class="hljs-string">&quot;账号密码&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;password&quot;</span>, key=<span class="hljs-string">&quot;password&quot;</span>)  <br>            <span class="hljs-comment"># 将按钮靠右放置  </span><br>            cols = st.columns([<span class="hljs-number">4</span>, <span class="hljs-number">1</span>])  <br>            cols[<span class="hljs-number">1</span>].form_submit_button(<span class="hljs-string">&quot;登录&quot;</span>, on_click=password_entered)  <br>            <span class="hljs-comment"># st.form_submit_button(&quot;登录&quot;, on_click=password_entered)   </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">password_entered</span>():  <br>        <span class="hljs-string">&quot;&quot;&quot;Checks whether a password entered by the user is correct.&quot;&quot;&quot;</span>  <br>        <span class="hljs-keyword">if</span> st.session_state[<span class="hljs-string">&quot;username&quot;</span>] <span class="hljs-keyword">in</span> st.secrets[  <br>            <span class="hljs-string">&quot;passwords&quot;</span>  <br>        ] <span class="hljs-keyword">and</span> hmac.compare_digest(  <br>            st.session_state[<span class="hljs-string">&quot;password&quot;</span>],  <br>            st.secrets.passwords[st.session_state[<span class="hljs-string">&quot;username&quot;</span>]],  <br>        ):  <br>            st.session_state[<span class="hljs-string">&quot;password_correct&quot;</span>] = <span class="hljs-literal">True</span>  <br>            <span class="hljs-keyword">del</span> st.session_state[<span class="hljs-string">&quot;password&quot;</span>]  <br>            <span class="hljs-keyword">del</span> st.session_state[<span class="hljs-string">&quot;username&quot;</span>]  <br>        <span class="hljs-keyword">else</span>:  <br>            st.session_state[<span class="hljs-string">&quot;password_correct&quot;</span>] = <span class="hljs-literal">False</span>  <br>    <span class="hljs-keyword">if</span> st.session_state.get(<span class="hljs-string">&quot;password_correct&quot;</span>, <span class="hljs-literal">False</span>):  <br>        <span class="hljs-comment"># st.success(&quot;登录成功！&quot;)  </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>  <br>    <span class="hljs-comment"># Show inputs for username + password.  </span><br>    login_form()  <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;password_correct&quot;</span> <span class="hljs-keyword">in</span> st.session_state:  <br>        st.error(<span class="hljs-string">&quot;😕 账号不存在或者密码不正确&quot;</span>)  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>   <br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> check_password():  <br>    st.stop()<br></code></pre></td></tr></table></figure><p>另外需在. Streamlit 文件夹下新建 secrets. Toml 配置文件，设置账号密码。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[passwords]</span><br><span class="hljs-attr">&quot;guest&quot;</span> = <span class="hljs-string">&quot;guest&quot;</span><br><span class="hljs-attr">&quot;user1&quot;</span> = <span class="hljs-string">&quot;user1&quot;</span><br></code></pre></td></tr></table></figure><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409101432235.png" alt="image.png"></p><p>虽然简陋但也完全够用了。</p><h2 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h2><p>为了让其他子页面也能够实现必须登录才能访问，需要在代码前引用上述函数。<br>多页面结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">your-repository/<br>├── .streamlit/<br>│   └── config<span class="hljs-selector-class">.toml</span><br>│   └── secrets<span class="hljs-selector-class">.toml</span><br>├── pages/<br>│   ├── login<span class="hljs-selector-class">.py</span><br>│   ├── page1<span class="hljs-selector-class">.py</span><br>│   ├── page2<span class="hljs-selector-class">.py</span><br>│   └── page3<span class="hljs-selector-class">.py</span><br>└── app.py<br></code></pre></td></tr></table></figure><p>前面的代码 login.py 中，page1.py 等子页面需在设置页面格式后（. set_page_config），添加下面代码实现调用登录验证。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-title">st</span>.set_page_config(page_title=<span class="hljs-string">&quot; &quot;</span>&#125;)<br><span class="hljs-title">from</span> login <span class="hljs-keyword">import</span> check_password<br><span class="hljs-title">if</span> not check_password():  <br>    st.stop()<br><span class="hljs-meta"># 继续子页面内容   </span><br></code></pre></td></tr></table></figure><p>至此结束。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Streamlit docs : <a href="https://docs.streamlit.io/knowledge-base/deploy/authentication-without-sso">https://docs.streamlit.io/knowledge-base/deploy/authentication-without-sso</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>streamlit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pdf 文件处理工具合集</title>
    <link href="/2024/09/06/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/pdf%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/"/>
    <url>/2024/09/06/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/pdf%20%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，知乎上有个话题很火，有 467 万次浏览，上了热榜很久。问的是 pdf 转 word 的问题。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061351753.png" alt="image.png"></p><p>确实，pdf 我们经常用，但常遇到各种问题。比如 pdf 转 word、pdf 转 Excel、pdf 转图片、pdf 解密、添加或去掉水印等等，就想着结合自己的经验梳理下有那些 pdf 工具免费且方便的解决这些问题。抛砖引玉，如有更好的方法，请评论留言。</p><h2 id="常用综合工具"><a href="#常用综合工具" class="headerlink" title="常用综合工具"></a>常用综合工具</h2><h3 id="Adobe-Acrobat-Xl"><a href="#Adobe-Acrobat-Xl" class="headerlink" title="Adobe Acrobat Xl"></a>Adobe Acrobat Xl</h3><p>很经典的版本，胜在稳定和功能强大，是装机必备软件之一。核心功能包括：页面增删、页面提取、文字修改、图片修改（结合画图和 ps）、水印增加或删除、文档加密、pdf 转 word、pdf 转 Excel、pdf 转图片、添加修改标签、合并 pdf 等等。这些功能处理日常的 pdf 问题已基本够用。<br>功能很全，大部分功能非常好用，但有几个不足，一是 pdf 转 word 等功能不适用于扫描文件，能够转换但格式上很差，无法直接用，很多制表符。二是没有解密功能。有些文件即使是公开的标准导则，也是不能编辑的，因为加密了，需要解密才能处理。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061408363.png" alt="软件预览"></p><h3 id="Micsoft-word"><a href="#Micsoft-word" class="headerlink" title="Micsoft word"></a>Micsoft word</h3><p>Word 同样可以将非扫描件版本的 pdf 为 Word，直接将文件用 word 打开就可以，缺点与 Adobe Acrobat Xl 一样，排版不尽人意，可作为临时应急。</p><h3 id="夸克浏览器"><a href="#夸克浏览器" class="headerlink" title="夸克浏览器"></a>夸克浏览器</h3><p>夸克浏览器是手机上的神器，pc 端也非常好用，针对 pdf 转换主要工具包括 pdf 转换，pdf 内容总结。其中 pdf 转换可以免费转化扫描版本 pdf，是目前所有 pdf 转 word 、Excel 最好的工具。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061426053.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061430048.png" alt="image.png"></p><h2 id="在线转换工具"><a href="#在线转换工具" class="headerlink" title="在线转换工具"></a>在线转换工具</h2><p>市面上有非常多免费的 pdf 在线处理工具，这里举几个我认为比较好用的。</p><h3 id="Cleverpdf"><a href="#Cleverpdf" class="headerlink" title="Cleverpdf"></a>Cleverpdf</h3><p>功能非常全面，包括 pdf 转换等，还包括 pdf 解密，亲测可用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061432505.png" alt="image.png"></p><h3 id="Pdf-Io"><a href="#Pdf-Io" class="headerlink" title="Pdf. Io"></a>Pdf. Io</h3><p>与 Cleverpdf 类似。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061436473.png" alt="image.png"></p><h3 id="Smallpdf"><a href="#Smallpdf" class="headerlink" title="Smallpdf"></a>Smallpdf</h3><p>Pdf 文件转换<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061446320.png" alt="image.png"></p><h2 id="Pdf-阅读工具"><a href="#Pdf-阅读工具" class="headerlink" title="Pdf 阅读工具"></a>Pdf 阅读工具</h2><p>Pdf 的核心就是方便阅读，因为 pdf 的格式固定，便于传播。而 pdf 阅读功能有很多功能可以做，浏览器标配，各大厂商下场做 pdf 阅读器如 wps、2345、福昕。如果只是看一下当然谁都可以胜任。但有的 pdf 需要勾勾画画甚至进行总结。因此我推荐的是 pdf 深度阅读的工具。</p><h3 id="Zotero"><a href="#Zotero" class="headerlink" title="Zotero"></a>Zotero</h3><p>Zotero 是一款开源论文管理工具，也可作为 pdf 文件管理工具，它功能非常强大，支持很多插件，扩展性强。文件翻译、文件总结、文件标记、笔记整理都能胜任。</p><h3 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a>微信读书</h3><p>你没有看错，微信读书是一款非常好的 pdf 阅读器，甚至能将扫描的 pdf 正确识别并排版。而且多端同步，配合本身的阅读功能，直接满分。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Pdf 工具问题其实很难一劳永逸的解决，很多软件或者在线网页可能会退出免费阵营，但这个功能并不是什么特别难的技术问题，总有其他软件可以实现。所以只要去检索，工具有很多。上文也只是目前用着比较顺手的，记录一下。</p><h2 id="相关网页"><a href="#相关网页" class="headerlink" title="相关网页"></a>相关网页</h2><p><a href="https://www.cleverpdf.com/cn">https://www.cleverpdf.com/cn</a><br><a href="https://pdf.io/">https://pdf.io/</a><br><a href="https://smallpdf.com/cn/pdf-converter">https://smallpdf.com/cn/pdf-converter</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python实现水质日历热力图</title>
    <link href="/2024/09/05/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%E5%AE%9E%E7%8E%B0%E6%B0%B4%E8%B4%A8%E6%97%A5%E5%8E%86%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
    <url>/2024/09/05/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%E5%AE%9E%E7%8E%B0%E6%B0%B4%E8%B4%A8%E6%97%A5%E5%8E%86%E7%83%AD%E5%8A%9B%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>使用 python 将站点水质等级以日历图形式可视化。实现快速掌握站点长期水质状况及时间变化趋势。</p><h2 id="成果预览"><a href="#成果预览" class="headerlink" title="成果预览"></a>成果预览</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061115783.png" alt="image.png"></p><h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><ol><li>查询站点、任意时间段水质等级。</li><li>可自定义参与评价的因子</li><li>日历图有有图例，支持鼠标交互显示时间和水质等级</li></ol><h2 id="实现路径"><a href="#实现路径" class="headerlink" title="实现路径"></a>实现路径</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061134407.png" alt="image.png"></p><h2 id="环境及依赖"><a href="#环境及依赖" class="headerlink" title="环境及依赖"></a>环境及依赖</h2><p>还是利用 python streamlit 框架，日历图需要依赖包为 pyecharts、streamlit_echarts。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">python = 3.12.0<br>streamlit==1.38.0  <br>streamlit-echarts==0.4.0  <br>pyecharts==2.0.6<br></code></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><p>根据自身情况，用数据库或者 Excel 都可以，只要有监测时间和监测因子就行。数据示例如下。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409061139327.png" alt="image.png"></p><h3 id="等级判断"><a href="#等级判断" class="headerlink" title="等级判断"></a>等级判断</h3><p>evaluate_df(df, limits, standard_map) 函数根据以水质监测数据的 DataFrame、包含各因子评价限值的字典、包含评价等级与数值对应关系的字典来获得每个因子的数据等级。程序中加入了异常判断。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_df</span>(<span class="hljs-params">df, limits, standard_map</span>):  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    评价DataFrame中的水质数据，并返回一个新的带有评价等级的DataFrame。  </span><br><span class="hljs-string">  </span><br><span class="hljs-string">    参数:  </span><br><span class="hljs-string">    df: DataFrame，包含水质监测数据的DataFrame，其中第一列为&#x27;监测时间&#x27;，其他列为不同因子的监测值。  </span><br><span class="hljs-string">    limits: dict，包含各因子评价限值的字典，用于确定各因子的评价等级。  </span><br><span class="hljs-string">    standard_map: dict，包含评价等级与数值对应关系的字典，用于将评价等级映射为数值。</span><br><span class="hljs-string">  </span><br><span class="hljs-string">    返回:  </span><br><span class="hljs-string">    DataFrame，包含原始数据和各因子评价等级、站点等级的新DataFrame。  </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 在原有 DataFrame 上添加新列  </span><br>    result_df = df.copy()  <span class="hljs-comment"># 复制原有 DataFrame 以保留原数据 </span><br>  <br>    <span class="hljs-comment"># 遍历df中的每一行  </span><br>    <span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> df.iterrows():  <br>        <span class="hljs-comment"># 初始化最大等级为未定义  </span><br>        max_level = standard_map[<span class="hljs-string">&quot;未定义&quot;</span>]   <br>        <span class="hljs-comment"># 遍历每一列，除了&#x27;监测时间&#x27;  </span><br>        <span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> df.columns[<span class="hljs-number">1</span>:]:  <br>            factor = column  <span class="hljs-comment"># 获取当前列的因子名称</span><br>  <br>            <span class="hljs-comment"># 检查是否为空值  </span><br>            <span class="hljs-keyword">if</span> pd.isna(row[column]):  <br>                result_df.at[index, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;factor&#125;</span>评价等级&#x27;</span>] = standard_map[<span class="hljs-string">&quot;空值&quot;</span>]  <span class="hljs-comment"># 标记为空值  </span><br>                <span class="hljs-keyword">continue</span>  <br>  <br>            <span class="hljs-keyword">if</span> column <span class="hljs-keyword">in</span> limits:  <span class="hljs-comment"># 如果列存在于limits中  </span><br>                level = water_quality_levels(column, row[column], limits[column])  <br>                numeric_level = standard_map[level]  <br>                result_df.at[index, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;factor&#125;</span>评价等级&#x27;</span>] = numeric_level  <span class="hljs-comment"># 添加新列存储等级  </span><br>                <span class="hljs-comment"># 更新最大等级  </span><br>                max_level = <span class="hljs-built_in">max</span>(max_level, numeric_level)  <br>            <span class="hljs-keyword">else</span>:  <br>                <span class="hljs-comment"># 如果列不在limits中，标记为未定义  </span><br>                result_df.at[index, <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;factor&#125;</span>评价等级&#x27;</span>] = standard_map[<span class="hljs-string">&quot;未定义&quot;</span>]  <br>  <br>        <span class="hljs-comment"># 计算站点等级并添加到新的DataFrame  </span><br>        result_df.at[index, <span class="hljs-string">&#x27;站点等级&#x27;</span>] = max_level <br>    <span class="hljs-keyword">return</span> result_df<br></code></pre></td></tr></table></figure><h3 id="评价限值limits"><a href="#评价限值limits" class="headerlink" title="评价限值limits"></a>评价限值limits</h3><p>这个之前有过介绍，是根据《地表水环境质量标准》（GB 3838-2002）要求建立的字典。如果需要自定义 limits 可以通过多选查询对应的限值来替换入参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">limits = &#123;  <br>    <span class="hljs-string">&quot;高锰酸盐指数&quot;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>],  <br>    <span class="hljs-string">&quot;氨氮&quot;</span>: [<span class="hljs-number">0.15</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>],  <br>    <span class="hljs-string">&quot;总磷&quot;</span>: [<span class="hljs-number">0.02</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>],  <br>    <span class="hljs-string">&quot;化学需氧量&quot;</span>: [<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>],  <br>    <span class="hljs-string">&quot;五日生化需氧量&quot;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>],  <br>    <span class="hljs-string">&quot;氟化物&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">1.5</span>],   <br>    <span class="hljs-string">&quot;pH&quot;</span>: [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>],  <span class="hljs-comment"># pH的特殊处理，下限为6，上限为9  </span><br>    <span class="hljs-string">&quot;溶解氧&quot;</span>: [<span class="hljs-number">7.5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 溶解氧的特殊处理，只有下限  </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="standard-map"><a href="#standard-map" class="headerlink" title="standard_map"></a>standard_map</h3><p>评价等级与数值对应关系的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">standard_map = &#123;<span class="hljs-string">&quot;Ⅰ&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Ⅱ&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Ⅲ&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;Ⅳ&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;Ⅴ&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;劣Ⅴ&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;未定义&quot;</span>: -<span class="hljs-number">1</span>, <span class="hljs-string">&quot;空值&quot;</span>: -<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="日历图"><a href="#日历图" class="headerlink" title="日历图"></a>日历图</h3><p>为了在 streamlit 实现日历图，尝试了很多依赖，streamlit 自身支持的较好的 plotly 没有日历图，matplotlib、camlp 都是静态的，不好看。最终选择了第三方包 pyecharts 绘制，streamlit_echarts 展示。注意最后一定要用 st_pyecharts () 来展示，才能在 web 中很好的显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> options <span class="hljs-keyword">as</span> opts  <br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Calendar  <br><span class="hljs-keyword">from</span> streamlit_echarts <span class="hljs-keyword">import</span> st_pyecharts <br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_calendar</span>(<span class="hljs-params">df</span>):  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    使用pyecharts 和streamlit_echarts生成水质日历热力图。  </span><br><span class="hljs-string">    参数:  </span><br><span class="hljs-string">    df (DataFrame): 包含水质数据的Pandas DataFrame，必须包括水质等级和日期（或索引作为日期）。    </span><br><span class="hljs-string">    返回:  </span><br><span class="hljs-string">    calendar_chart (Chart object): 生成的日历热力图对象。  </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-comment"># 检查是否有“监测时间”列，如果没有则使用索引作为日期    </span><br>    <span class="hljs-comment"># 获取年份用于标题  </span><br>    year = df[<span class="hljs-string">&#x27;监测时间&#x27;</span>].dt.year.unique()[<span class="hljs-number">0</span>]  <br>    df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = df[<span class="hljs-string">&#x27;监测时间&#x27;</span>].dt.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>)   <br>    <span class="hljs-comment"># 确保水质等级是数值类型  </span><br>    df[<span class="hljs-string">&#x27;站点等级&#x27;</span>] = pd.to_numeric(df[<span class="hljs-string">&#x27;站点等级&#x27;</span>]) <br>    <span class="hljs-comment"># 获取日期和水质等级数据  </span><br>    data = df[[<span class="hljs-string">&#x27;监测时间&#x27;</span>, <span class="hljs-string">&#x27;站点等级&#x27;</span>]].values.tolist()  <br>    <span class="hljs-comment"># 创建日历热力图  </span><br>    calendar_chart = (  <br>        Calendar().add(<span class="hljs-string">&quot;&quot;</span>, data, calendar_opts=opts.CalendarOpts(range_=<span class="hljs-built_in">str</span>(year)),  <br>                       daylabel_opts=opts.CalendarDayLabelOpts(name_map=<span class="hljs-string">&quot;cn&quot;</span>),  <br>                       monthlabel_opts=opts.CalendarMonthLabelOpts(name_map=<span class="hljs-string">&quot;cn&quot;</span>),  <br>                       tooltip_opts=opts.TooltipOpts(  <br>                           trigger=<span class="hljs-string">&quot;item&quot;</span>,  <br>                           <span class="hljs-comment"># 自定义提示框格式化器  </span><br>                           formatter=JsCode(<span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">                     function(params) &#123;                     return  params.name  + params.value;                     &#125;                 &quot;&quot;&quot;</span>),  <br>                       ))  <br>        .set_global_opts(  <br>            title_opts=opts.TitleOpts(title=<span class="hljs-string">f&quot; <span class="hljs-subst">&#123;year&#125;</span> 年日历热力图&quot;</span>, pos_left=<span class="hljs-string">&quot;center&quot;</span>)  <br>            ,  <br>            visualmap_opts=opts.VisualMapOpts(  <br>                max_=<span class="hljs-number">6</span>,  <br>                min_=<span class="hljs-number">1</span>,  <br>                orient=<span class="hljs-string">&quot;horizontal&quot;</span>,  <br>                pos_top=<span class="hljs-string">&quot;230px&quot;</span>,  <br>                pos_left=<span class="hljs-string">&quot;center&quot;</span>,  <br>                is_piecewise=<span class="hljs-literal">True</span>,  <br>                pieces=[  <br>                    &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Ⅰ类&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#0000FF&quot;</span>&#125;,<br>                    &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Ⅱ类&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#1E90FF&quot;</span>&#125;, <br>                    &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Ⅲ类&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#32CD32&quot;</span>&#125;,<br>                    &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Ⅳ类&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FFD700&quot;</span>&#125;, <br>                    &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;Ⅴ类&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FFA500&quot;</span>&#125;, <br>                    &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;劣Ⅴ类&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FF0000&quot;</span>&#125;,  <br>                ],  <br>            ),  <br>        )  <br>    ) <br>    <span class="hljs-keyword">return</span> calendar_chart<br>hour_pic = generate_calendar(df_day)<br>st_pyecharts(hour_pic)<br></code></pre></td></tr></table></figure><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><p><a href="https://echarts.streamlit.app/">Streamlit ECharts Demo · Streamlit</a><br><a href="https://gallery.pyecharts.org/#/Calendar/calendar_label_setting">Calendar - Calendar_label_setting - Document (pyecharts.org)</a><br><a href="https://github.com/pyecharts/pyecharts-gallery?tab=readme-ov-file">pyecharts&#x2F;pyecharts-gallery: Just use pyecharts to imitate Echarts official example. (github.com)</a><br><a href="https://github.com/andfanilo/streamlit-echarts?tab=readme-ov-file">andfanilo&#x2F;streamlit-echarts: A Streamlit component to render ECharts. (github.com)</a><br><a href="https://echarts.apache.org/examples/en/index.html#chart-type-calendar">Examples - Apache ECharts</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>经验分享</tag>
      
      <tag>streamlit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资料分享_污染源排放相关资料整理</title>
    <link href="/2024/09/05/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB_%E6%B1%A1%E6%9F%93%E6%BA%90%E6%8E%92%E6%94%BE%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
    <url>/2024/09/05/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB_%E6%B1%A1%E6%9F%93%E6%BA%90%E6%8E%92%E6%94%BE%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />分享污染源排放相关资料，全部无条件，无水印，有需要的下载查看。<ol><li>国家和重庆市、四川省排放标准，包括综合和地方排放标准。<ol><li>地方标准 22 篇</li><li>国标 122 篇</li><li>重大变动 30 篇</li><li>四川省排放标准、固体废物分类与代码目录等 5 项目</li></ol></li><li>排污单位自行监测技术指南 46 篇</li><li>污染防治可行技术指南 44 篇</li><li>排污许可申请与核发技术规范 79 篇</li><li>《固定污染源排污许可分类管理名录（2019 年版）》解读</li></ol><p>百度网盘链接： <a href="https://pan.baidu.com/s/1w2pNbpr4wgHeV-iU1ORZSg">https://pan.baidu.com/s/1w2pNbpr4wgHeV-iU1ORZSg</a><br>提取码：v2av </p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p><h2 id="截图"><a href="#截图" class="headerlink" title="截图"></a>截图</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409050936408.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409050937230.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409050937042.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
      <tag>资料分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 判断地表水质等级算法</title>
    <link href="/2024/09/03/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/python%20%E5%88%A4%E6%96%AD%E5%9C%B0%E8%A1%A8%E6%B0%B4%E8%B4%A8%E7%AD%89%E7%BA%A7%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/03/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/python%20%E5%88%A4%E6%96%AD%E5%9C%B0%E8%A1%A8%E6%B0%B4%E8%B4%A8%E7%AD%89%E7%BA%A7%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>用 python实现《地表水环境质量标准》（GB 3838-2002）水质等级判断。</p><h2 id="标准要求"><a href="#标准要求" class="headerlink" title="标准要求"></a>标准要求</h2><p>水质标准限制如下图，其中pH上限是9，下限是6，超过上下限都是超标。溶解氧要求的是下限，其他均为上限。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409031051013.png" alt="image.png"></p><h2 id="Python-代码片段"><a href="#Python-代码片段" class="headerlink" title="Python 代码片段"></a>Python 代码片段</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python">limits = &#123;<br>    <span class="hljs-string">&quot;高锰酸盐指数&quot;</span>: [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>],<br>    <span class="hljs-string">&quot;氨氮&quot;</span>: [<span class="hljs-number">0.15</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.0</span>],<br>    <span class="hljs-string">&quot;总磷&quot;</span>: [<span class="hljs-number">0.02</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>],<br>    <span class="hljs-string">&quot;化学需氧量&quot;</span>: [<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>],<br>    <span class="hljs-string">&quot;五日生化需氧量&quot;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>],<br>    <span class="hljs-string">&quot;氟化物&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">1.5</span>],<br>    <span class="hljs-string">&quot;pH&quot;</span>: [<span class="hljs-number">6</span>, <span class="hljs-number">9</span>],  <span class="hljs-comment"># pH的特殊处理，下限为6，上限为9</span><br>    <span class="hljs-string">&quot;溶解氧&quot;</span>: [<span class="hljs-number">7.5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 溶解氧的特殊处理，只有下限</span><br>    <br>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">water_quality_level</span>(<span class="hljs-params">monitoring_factor, value, limits</span>):<br>    <span class="hljs-keyword">if</span> monitoring_factor == <span class="hljs-string">&quot;pH&quot;</span>:<br>        <span class="hljs-keyword">if</span> value &lt; limits[monitoring_factor][<span class="hljs-number">0</span>] <span class="hljs-keyword">or</span> value &gt; limits[monitoring_factor][<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超标&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;正常&quot;</span><br>    <span class="hljs-keyword">elif</span> monitoring_factor == <span class="hljs-string">&quot;溶解氧&quot;</span>:<br>        <span class="hljs-keyword">if</span> value &gt;= limits[monitoring_factor][<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅰ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &gt;= limits[monitoring_factor][<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅱ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &gt;= limits[monitoring_factor][<span class="hljs-number">2</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅲ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &gt;= limits[monitoring_factor][<span class="hljs-number">3</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅳ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &gt;= limits[monitoring_factor][<span class="hljs-number">4</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅴ&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;劣Ⅴ&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> value &lt;= limits[monitoring_factor][<span class="hljs-number">0</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅰ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &lt;= limits[monitoring_factor][<span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅱ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &lt;= limits[monitoring_factor][<span class="hljs-number">2</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅲ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &lt;= limits[monitoring_factor][<span class="hljs-number">3</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅳ&quot;</span><br>        <span class="hljs-keyword">elif</span> value &lt;= limits[monitoring_factor][<span class="hljs-number">4</span>]:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Ⅴ&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;劣Ⅴ&quot;</span><br><br><span class="hljs-comment"># 示例调用</span><br><span class="hljs-built_in">print</span>(water_quality_level(<span class="hljs-string">&quot;pH&quot;</span>, <span class="hljs-number">5.5</span>, limits))  <span class="hljs-comment"># 应该输出 &quot;超标&quot;</span><br><span class="hljs-built_in">print</span>(water_quality_level(<span class="hljs-string">&quot;溶解氧&quot;</span>, <span class="hljs-number">6.5</span>, limits))  <span class="hljs-comment"># 应该输出 &quot;Ⅱ&quot;</span><br></code></pre></td></tr></table></figure><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生态环境</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian  excalidraw 绘制思维导图</title>
    <link href="/2024/09/02/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20excalidraw%20%E7%BB%98%E5%88%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2024/09/02/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20excalidraw%20%E7%BB%98%E5%88%B6%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />最近obsidian excalidraw 2.4 有了非常大的更新，可以说完善了成为思维导图软件的最后一块拼图，all in one 再次大胜。<h3 id="生成下级文本框"><a href="#生成下级文本框" class="headerlink" title="生成下级文本框"></a>生成下级文本框</h3><p>更新 obsidian excalidraw 2.4 后，插入矩形文本框，点击文本框，按住 ctrl + 上下左右键，就可以生成思维导图，方便，且完美。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409021039859.jpg" alt="1725244733527.jpg"></p><h3 id="丰富的外接对象"><a href="#丰富的外接对象" class="headerlink" title="丰富的外接对象"></a>丰富的外接对象</h3><p>选择用 Obsidian 做思维导图除了免费、本地存储外，当然还有他强大的双链，丰富的外界对象。<br>安装 pdf ++ 插件，使用框选插件，直接选中 pdf 内容复制进入 Obsidian，这样不是一个图片，而是一个链接。在 excalidraw 中点击对象可直接进入相关数据源。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202409021046313.png" alt="image.png"></p><p>在 Obsidian 中可以也可以直接将 pdf 当做图片插入，并进行批注。<br>Excalidraw 2.4 更新内容还有很多，有兴趣可以看下油管视频。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>obsidian</tag>
      
      <tag>excaildraw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水功能区与水环境功能区的联系与区别</title>
    <link href="/2024/08/28/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%B0%B4%E5%8A%9F%E8%83%BD%E5%8C%BA%E4%B8%8E%E6%B0%B4%E7%8E%AF%E5%A2%83%E5%8A%9F%E8%83%BD%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/08/28/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%B0%B4%E5%8A%9F%E8%83%BD%E5%8C%BA%E4%B8%8E%E6%B0%B4%E7%8E%AF%E5%A2%83%E5%8A%9F%E8%83%BD%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在水利系统使用水功能区较多，而在生态环保系统使用水环境功能区较多，随着水功能区划定调整工作移交给生态环境部门，两者的概念常常混用，由于名字比较接近，非常容易混淆，搞不清楚谁是谁，故而梳理一下。</p><h2 id="依据和定义不同"><a href="#依据和定义不同" class="headerlink" title="依据和定义不同"></a>依据和定义不同</h2><h3 id="水功能区依据及定义"><a href="#水功能区依据及定义" class="headerlink" title="水功能区依据及定义"></a>水功能区依据及定义</h3><p>水功能区依据为《中华人民共和国水法》《中华人民共和国水污染防治法》(2016 年 7 月修订)、《中华人民共和国长江保护法》（中华人民共和国主席令第六十五号）、《国务院关于实行最严格水资源管理制度的意见 (国发 (2012) 3 号)、《水功能区监督管理办法》、《水功能区划标准》、《地表水资源环境质量评价技术规程》。<br>水功能区的定义。根据《水功能区监督管理办法》（水资源【2017】101号）<br>水功能区是指为满足水资源合理开发、利用、节约和保护的需求，根据水资源的自然条件和开发利用现状，按照流域综合规划、水生态系统保护和经济社会发展要求，依其主导功能划定范围并执行相应保护和管理要求的水域。<br>水功能区最初划定为水利部门，后移交给生态环境部门。</p><h3 id="水功能区依据及定义-1"><a href="#水功能区依据及定义-1" class="headerlink" title="水功能区依据及定义"></a>水功能区依据及定义</h3><p>水环境功能区依据为《中华人民共和国环境保护法》和《地表水环境质量标准》。<br>根据《地表水环境功能区类别代码》（HJ 522—2009），水环境功能区定义为根据水域使用功能、水环境污染状况、水环境承受能力（环境容量）、社会经济发展需要以及污染物排放总量控制的要求，划定的具有特定功能的水环境。<br>水环境功能区划定为生态环境部门。</p><h2 id="划分类别不同"><a href="#划分类别不同" class="headerlink" title="划分类别不同"></a>划分类别不同</h2><p>水功能区划采用两级划分体系，一级功能区分四类，含保护区、保留区、开发利用区、缓冲区等；二级功能区对一级功能取其中的保护区和开发利用区进行再分类，将保护区再细分为饮用水源区、工业用水区、农业用水区、渔业用水区、景观娱乐用水区、过渡区和排污区等。<br>水功能区划更细，对支流、具体河段都做了详细的要求。<br>水环境功能区划分为自然保护区、饮用水水源保护区、渔业用水区、工业用水区、农业用水区、景观娱乐用水区等。<br>水环境功能区划相对更粗，往往仅对某一河流进行要求。</p><h2 id="划分级别不同"><a href="#划分级别不同" class="headerlink" title="划分级别不同"></a>划分级别不同</h2><p>水功能区分为国家级、省级、市级、区县级四级，对应考核设置有考核断面。<br>水环境功能区划没有级别。</p><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>唯一的相同点就是提出了水质等级要求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>水功能区与水环境功能区虽然名字看起来有点类似，但由于划分部门不同，分级方法不同实际差别很大，设置有可能出现同一水域水质等级要求不同的情况。所以在面对这类管理问题的时候一定要分清是哪种分类，就完全哪种要求。<br>随着水功能区调整工作划归水生态保护部门管理，对于同一水域的管理要求可能逐渐统一，但应该会有一个很长的过程，毕竟改变是逆熵的。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian anki 联动 自制记忆卡组</title>
    <link href="/2024/08/21/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20anki%20%E8%81%94%E5%8A%A8%20%E8%87%AA%E5%88%B6%E8%AE%B0%E5%BF%86%E5%8D%A1%E7%BB%84/"/>
    <url>/2024/08/21/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20anki%20%E8%81%94%E5%8A%A8%20%E8%87%AA%E5%88%B6%E8%AE%B0%E5%BF%86%E5%8D%A1%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>我有一个朋友</strong>最近需要记忆一些知识点，想找一个题库软件，最好是能自定义题库。可市面上的题库要么题不全，要么收费贵。有没有一个工具可以自定义题库，且按照记忆曲线提供定期记忆回顾功能呢。所幸还真有这么一款开源软件，<strong>anki</strong>。</p><p>本文记录 anki 简介，obsidian anki 联动管理卡组及异常情况处理过程。</p><h3 id="Anki-简介"><a href="#Anki-简介" class="headerlink" title="Anki 简介"></a>Anki 简介</h3><p>Anki 是一款免费且开源的闪卡（Flashcard）制作与学习软件，它支持多种平台，包括 Windows、Mac OS 、Linux 以及 Android 移动设备等。Anki 的主要功能是帮助用户通过创建数字闪卡来学习各种类型的知识点，并利用间隔重复（Spaced Repetition）的原理优化复习计划，从而提高记忆效率。</p><h4 id="相关地址"><a href="#相关地址" class="headerlink" title="相关地址"></a>相关地址</h4><p>官网： <a href="https://apps.ankiweb.net/">https://apps.ankiweb.net/</a><br>Ankichina： <a href="http://www.ankichina.net/welcome/">http://www.ankichina.net/welcome/</a><br>软件直接官网下载，ankichina 可以帮我们初步了解 anki，有网友分享的卡组。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408220958888.png" alt="公开卡组"></p><h2 id="Obsidian-anki-管理卡组"><a href="#Obsidian-anki-管理卡组" class="headerlink" title="Obsidian anki 管理卡组"></a>Obsidian anki 管理卡组</h2><p>Anki 卡组类型包括问答题（包括单向和双向）、填空题等多种形式，直接通过 anki 新建卡片比较麻烦， anki 也有通过 csc、apkg 等方式批量导入卡组的方式。</p><p>但为了更好的管理卡组，并与笔记结合，今天介绍 Obsidian anki 联动管理卡组的方式。</p><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ul><li>Obsidian、anki</li><li>Anki 插件：anki connector</li><li>Obsidian 插件：Export to Anki<br>Anki connector 插件安装方式<br>  打开 anki -工具-插件-输入代码 2055492159<br>Export to Anki 安装方式<br>  应用商店中安装 Export to Anki （安装后为 obsidian to anki）</li></ul><h3 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h3><p>在 Anki 插件界面双击 Anki connector 复制粘贴下面代码。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;apiKey&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;apiLogPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">null</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webBindAddress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webBindPort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8765</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webCorsOrigin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;webCorsOriginList&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;http://localhost&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;app://obsidian.md&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408211639821.png" alt="image.png"></p><p>重启 anki ,如果报端口请看异常处理记录，没有报错就在 anki 运行的情况下，重启 obsidian Export to Anki 插件，会多出来设置按钮，如果没有成功连接 anki 是没有设置按钮的。</p><h4 id="obsidian-to-anki-设置信息"><a href="#obsidian-to-anki-设置信息" class="headerlink" title="obsidian to anki 设置信息"></a>obsidian to anki 设置信息</h4><p> 先看设置信息截图如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408212202944.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221013857.png" alt="QQ_1724292826629.png"></p><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>忽略其他文件及文件夹，这样可以避免程序进行不必要的扫描，忽略文件夹格式为文件名后加&#x2F;**<br>注意原文有的去掉 excalidraw 要保留。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">**/<span class="hljs-emphasis">*.excalidraw.md</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">00_collection box/*</span>*</span><br><span class="hljs-strong">01<span class="hljs-emphasis">_工作/**</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">02_</span>学习/**</span><br>03<span class="hljs-emphasis">_生活/<span class="hljs-strong">**</span></span><br></code></pre></td></tr></table></figure><h4 id="Anki-添加笔记模板"><a href="#Anki-添加笔记模板" class="headerlink" title="Anki 添加笔记模板"></a>Anki 添加笔记模板</h4><p>Anki -浏览-笔记模版右键-管理笔记模版-添加-问答题。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221020295.png" alt="image.png"></p><h4 id="Obsidian-to-anki-笔记模板设置"><a href="#Obsidian-to-anki-笔记模板设置" class="headerlink" title="Obsidian to anki 笔记模板设置"></a>Obsidian to anki 笔记模板设置</h4><p>依次点击 Actions- Regenerate Note Type Table-Regenerate，获取笔记模板。<br>这样在 note type settings 下就有了 note type table<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221023664.png" alt="image.png"></p><h4 id="添加正则表达式"><a href="#添加正则表达式" class="headerlink" title="添加正则表达式"></a>添加正则表达式</h4><p>在官方 wiki 界面下找到问答式正则表达式代码复制到对应的 custom regexp。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">^<span class="hljs-symbol">Q:</span> ((<span class="hljs-string">?:</span>.+\n)*)\n*<span class="hljs-symbol">A:</span> (.+(<span class="hljs-string">?:\n</span>(<span class="hljs-string">?:</span>^.&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;<span class="hljs-variable">$|</span>^.&#123;<span class="hljs-number">4</span>&#125;(<span class="hljs-string">?&lt;</span>!&lt;!--).*))*)<br></code></pre></td></tr></table></figure><p>正则表达式解释：Q: 后面是问题，换行后 A: 为答案。<br>正则表达式可自定义，例如下面的表达式，可用于知识点的梳理。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">^#&#123;4&#125;\s(.+)<span class="hljs-symbol">\n</span>*((?:<span class="hljs-symbol">\n</span>(?:^[^<span class="hljs-symbol">\n</span>#].&#123;0,2&#125;$|^[^<span class="hljs-symbol">\n</span>#].&#123;3&#125;(?&lt;!&lt;!--).*))+)<br></code></pre></td></tr></table></figure><p>4 级标题为问题，4 级标题以下为答案，具体如何设置根据自己的需要来定。<br>以上就完成了初步配置。<br>只要在 obsidian 没有被忽略的笔记中添加对应格式笔记，点击左侧按钮就能同步到 anki Default 卡组中。笔记格式示例如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Q: How <span class="hljs-keyword">do</span> you use <span class="hljs-keyword">this</span> style?<br>A: Just like <span class="hljs-keyword">this</span>.<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221028348.png"></p><p>成功后，在 obsidian 对应的笔记后面会多一个标记<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221035113.png" alt="image.png"><br>在 anki 中会增加卡片。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221037904.png" alt="image.png"></p><h3 id="Obsidian-管理-anki-卡组"><a href="#Obsidian-管理-anki-卡组" class="headerlink" title="Obsidian 管理 anki 卡组"></a>Obsidian 管理 anki 卡组</h3><p>使用 Obsidian to anki 插件不仅可以批量添加卡片，还可以实现指定目标卡组，删除卡片，修改卡片内容。</p><h5 id="指定目标卡组"><a href="#指定目标卡组" class="headerlink" title="指定目标卡组"></a>指定目标卡组</h5><p>在 anki 牌组界面下，点击创建自己的卡组，在 obsidian 笔记前添加 TARGET DECK 字段设置目标卡组。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">TARGET DECK: obsidian<br>Q: How do you use this style?<br>A: Just like this.<br><span class="hljs-comment">&lt;!--ID: 1724248298307--&gt;</span><br></code></pre></td></tr></table></figure><h5 id="删除卡片"><a href="#删除卡片" class="headerlink" title="删除卡片"></a>删除卡片</h5><p>在特殊标记前添加 DELETE 命令。</p><h5 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h5><p>在笔记后添加 FILE TAGS 字段，可添加标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">Q: How is this possible?<br>A: The &#x27;magic&#x27; of regular expressions!<br><span class="hljs-comment">&lt;!--ID: 1724247826177--&gt;</span><br><br>FILE TAGS: 测试 错题<br></code></pre></td></tr></table></figure><p>以上 TARGET DECK 、DELETE、FILE TAGS 均是设置中默认的，可以在设置中对应修改。</p><h3 id="美化卡片"><a href="#美化卡片" class="headerlink" title="美化卡片"></a>美化卡片</h3><p>Anki 和 obsidian 一样支持 markdown 格式, 还支持 HTML，css 可以做出非常美观的卡片。<br>在浏览界面，点击右侧设置图标修改卡片样式 CSS 代码。将实现对笔记输出格式的美化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br> <span class="hljs-attribute">font-family</span>: arial;<br> <span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>;<br> <span class="hljs-attribute">text-align</span>: left;<br> <span class="hljs-attribute">color</span>: black;<br> <span class="hljs-attribute">background-color</span>: white;<br>&#125;<br><br><span class="hljs-selector-tag">em</span> &#123;<br> <span class="hljs-selector-id">#color</span>:white; <br> <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#69E147</span>;<br> <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br> <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">strong</span> &#123;<br> <span class="hljs-attribute">color</span>:red;<br> <span class="hljs-attribute">font-weight</span>: bolder;<br> <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#ffe600</span>;<br>&#125;<br><br><span class="hljs-selector-tag">code</span> &#123;<br> <span class="hljs-attribute">color</span>:black;<br> <span class="hljs-attribute">font-weight</span>: bolder;<br> <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> gray;<br>&#125;<br><br><span class="hljs-selector-tag">mark</span> &#123;<br> <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br> <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">5px</span>;<br>&#125;<br><br><span class="hljs-selector-tag">blockquote</span> &#123;<br> <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ECECEC</span>;<br> <span class="hljs-attribute">padding</span>: <span class="hljs-number">2px</span> <span class="hljs-number">5px</span>;<br> <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#7F7F7F</span>;<br> <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Obsidian 笔记</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Q: 卡片支持哪些美化功能?<br>A: 1. <span class="hljs-strong">**加粗**</span>：关键词<br><span class="hljs-bullet">2.</span> <span class="hljs-emphasis">_斜体_</span>：用于句首，可以理解为卡片的结构化写法<br><span class="hljs-bullet">3.</span> ==高亮==：简记的形式——记忆法的延伸<br><span class="hljs-bullet">4.</span> 内容断行：先回车，然后“<span class="hljs-strong">**空一格**</span>”，然后再回车，这样就可以在卡片中进行内容的分隔（这个没有什么特别的说法，单纯是因为插件代码就是这么写的）。<br> <br><span class="hljs-quote">&gt;  “人生就是一连串的刹那”</span><br><span class="hljs-quote">&gt; ——《被讨厌的勇气》</span><br></code></pre></td></tr></table></figure><p>结果预览：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408221117029.png"></p><h2 id="Anki-web-卡组同步"><a href="#Anki-web-卡组同步" class="headerlink" title="Anki web 卡组同步"></a>Anki web 卡组同步</h2><p>做好牌组后，可通过 Anki web 能帮我们实现多端同步。点击 anki 的同步按钮即可注册、登录账户，安卓端推荐 ankichina 下载 ankidroid，注意软件是免费的。</p><h2 id="端口占用处理记录"><a href="#端口占用处理记录" class="headerlink" title="端口占用处理记录"></a>端口占用处理记录</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408211650449.png" alt="image.png"></p><p>问题原因是有程序占用 8765 端口，两插件不支持修改默认端口，只能杀掉本地运行的端口程序。<br>Cmd 输入代码查询占用程序 netstat -ano | findstr : 8765。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">Users</span>\<span class="hljs-title">htwl</span>&gt;<span class="hljs-title">netstat</span> -<span class="hljs-title">ano</span> | <span class="hljs-title">findstr</span> :8765</span><br><span class="hljs-function">  <span class="hljs-title">TCP</span>    0.0.0.0:8765           0.0.0.0:0              <span class="hljs-title">LISTENING</span>       19060</span><br><span class="hljs-function">  <span class="hljs-title">TCP</span>    127.0.0.1:8765         127.0.0.1:63689        <span class="hljs-title">ESTABLISHED</span>     19060</span><br><span class="hljs-function">  <span class="hljs-title">TCP</span>    127.0.0.1:63689        127.0.0.1:8765         <span class="hljs-title">ESTABLISHED</span>     14868</span><br><span class="hljs-function">- 关闭对应程序。</span><br><span class="hljs-function"><span class="hljs-title">taskkill</span> /<span class="hljs-title">F</span> /<span class="hljs-title">PID</span> 19060</span><br><span class="hljs-function"><span class="hljs-title">taskkill</span> /<span class="hljs-title">F</span> /<span class="hljs-title">PID</span> 14868</span><br></code></pre></td></tr></table></figure><h2 id="参考文件"><a href="#参考文件" class="headerlink" title="参考文件"></a>参考文件</h2><p><a href="https://zhuanlan.zhihu.com/p/584391666">用obsidian进行anki作卡 - 知乎 (zhihu.com)</a><br>Bilibili@pkmer : 同步 Anki 学习卡，让你的学习更高效<br><a href="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki">Home · ObsidianToAnki&#x2F;Obsidian_to_Anki Wiki · GitHub</a><br><a href="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Regex">Regex · ObsidianToAnki&#x2F;Obsidian_to_Anki Wiki · GitHub</a>  </p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>anki</tag>
      
      <tag>学习记录</tag>
      
      <tag>软件学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>streamlit 多页面应用重命名与排序</title>
    <link href="/2024/08/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/streamlit%20%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    <url>/2024/08/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/streamlit%20%E5%A4%9A%E9%A1%B5%E9%9D%A2%E9%87%8D%E5%91%BD%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>Streamlit 作为简单易上手的数据分析可视化web框架，即使完全不会前段知识，也能快速开发 web应用。近期计划将水环境分析中的一些应用场景、业务需求梳理为工具箱，作为日常数据分析的帮手，由于工具比较多，难免会遇到多页面开发的情况，之前介绍过 [[python 项目框架管理]] 的开发，最近遇到新的问题，就是 streamlit 默认显示文件名作为导航页面，且按照字母顺序进行排名，这样显然是不自由的。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408151453769.png" alt="默认顺序"></p><p>我希望按照自己的顺序和中文名称显示，于是在 Streamlit 官方 docs 中找到了解决方法。记录如下：</p><h2 id="文件框架"><a href="#文件框架" class="headerlink" title="文件框架"></a>文件框架</h2><p>多页面设置之前介绍过文件框架，[[python 项目框架管理]] ，这里介绍最简单的。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">your-repository/ <br>├── .streamlit/ <br>│ └── config<span class="hljs-selector-class">.toml</span> <br>├── pages/ <br>│ ├── page1<span class="hljs-selector-class">.py</span> <br>│ ├── page2<span class="hljs-selector-class">.py</span> <br>│ └── page3<span class="hljs-selector-class">.py</span> <br>├── <span class="hljs-selector-tag">menu</span><span class="hljs-selector-class">.py</span> <br>└── app.py<br></code></pre></td></tr></table></figure><p>在.streamlit&#x2F;config.toml 文件内输入下面脚本，代表隐藏侧边栏的默认导航功能。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[client]</span>  <br><span class="hljs-attr">showSidebarNavigation</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h2><p>修改菜单脚本，目的是自定义脚本显示样式，核心方法为.page_link。具体语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st <br>   <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">menu</span>():  <br>    st.sidebar.page_link(<span class="hljs-string">&quot;app.py&quot;</span>, label=<span class="hljs-string">&quot;首页&quot;</span>)  <br>    st.sidebar.page_link(<span class="hljs-string">&quot;pages/weather_base.py&quot;</span>, label=<span class="hljs-string">&quot;降雨&quot;</span>)  <br>    st.sidebar.page_link(<span class="hljs-string">&quot;pages/weather_country.py&quot;</span>, label=<span class="hljs-string">&quot;天气&quot;</span>)  <br>    st.sidebar.page_link(<span class="hljs-string">&quot;pages/weather_country.py&quot;</span>, label=<span class="hljs-string">&quot;降雨表格&quot;</span>)  <br>    st.sidebar.page_link(<span class="hljs-string">&quot;pages/chat_AI.py&quot;</span>, label=<span class="hljs-string">&quot;AI聊天&quot;</span>)  <br>    st.sidebar.page_link(<span class="hljs-string">&quot;pages/streamlit_data.py&quot;</span>, label=<span class="hljs-string">&quot;数据分析&quot;</span>)<br></code></pre></td></tr></table></figure><p>以上是工作中具体例子，定义好后就在其他的页面引用这个程序就好了。比如在 app. py 中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st  <br><span class="hljs-keyword">from</span> menu <span class="hljs-keyword">import</span> menu  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():  <br>    st.sidebar.title(<span class="hljs-string">&#x27;首页&#x27;</span>)  <br>  <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:  <br>    menu()  <br>    main()<br></code></pre></td></tr></table></figure><p>以此类推，在其他页面引用即可，这样就完成了重命名和排序，如果觉得比较单调，可以加入 emoji。查找 emoji，可以使用输入法或者访问 emoji 网站搜索。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">st.sidebar.page_link(<span class="hljs-string">&quot;app.py&quot;</span>, <span class="hljs-attribute">label</span>=<span class="hljs-string">&quot;🏠首页&quot;</span>)<br></code></pre></td></tr></table></figure><p>最终效果如下，效果还是非常好的。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408151531969.png"></p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>如果不生效，用 pip install –upgrade streamlit 命令升级到最新版本的 Streamlit。<br>然后重新运行。</p><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><p>Streamlit官方文件：<br><a href="https://docs.streamlit.io/develop/tutorials/multipage/st.page_link-nav">Build a custom navigation menu with <code>st.page_link</code> - Streamlit Docs</a><br>Emoji： <a href="https://emojipedia.org/">https://emojipedia.org/</a><br>[[python 项目框架管理]]<br>[[Streamlit 多页面应用设计指南：构建模块化数据分析平台]]<br><a href="https://blog.csdn.net/weixin_42984235/article/details/140330029">Streamlit 多页面应用设计指南：构建模块化数据分析平台_streamlit 子页面-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42984235/article/details/140473600">python 项目框架管理_python项目结构管理-CSDN博客</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>数据分析</tag>
      
      <tag>streamlit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在峡江的转弯处：陈行甲人生笔记 读书笔记</title>
    <link href="/2024/07/30/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9C%A8%E5%B3%A1%E6%B1%9F%E7%9A%84%E8%BD%AC%E5%BC%AF%E5%A4%84%EF%BC%9A%E9%99%88%E8%A1%8C%E7%94%B2%E4%BA%BA%E7%94%9F%E7%AC%94%E8%AE%B0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/07/30/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%9C%A8%E5%B3%A1%E6%B1%9F%E7%9A%84%E8%BD%AC%E5%BC%AF%E5%A4%84%EF%BC%9A%E9%99%88%E8%A1%8C%E7%94%B2%E4%BA%BA%E7%94%9F%E7%AC%94%E8%AE%B0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>[!abstract] 在峡江的转弯处：陈行甲人生笔记</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/81/cpplatform_8al4mxpuzvvbhtnckcc7gc/t7_cpplatform_8al4mxpuzvvbhtnckcc7gc1720420733.jpg" alt=" 在峡江的转弯处：陈行甲人生笔记|200"></li><li>书名： 在峡江的转弯处：陈行甲人生笔记</li><li>作者： 陈行甲</li><li>简介： 《在峡江的转弯处：陈行甲人生笔记》是陈行甲的自传体随笔，从童年岁月写起，写母亲，写爱人；写了从大学毕业到基层工作九年多的生活经历；回顾了作者在巴东任县委书记期间的工作和生活；讲述了作者转场公益几年来的经历和感受。从本书中，作者用鲜活的故事和大量的细节讲述了一个普通人的爱与成长，以及如何在世事变幻中守住内心和实践的知行合一。</li><li>出版时间 2024-07-08 00:00:00 </li><li>分类： 文学-散文杂著</li></ul></blockquote><h3 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h3><p>我读这本书的时候非常沉浸，非常享受。它非常好读，好读就是好书。 </p><p>作者在文中多处曾泪流满面，我和很多读者也在很多地方泪流满面。比如其母亲的善良；霞放弃南方工作，回到作者身边；对孩子出生的描写；作者在清华、美国的学习经历；友谊、风景和诗意；抑郁时霞的陪伴；处理巴东的政务时的正义凛然；投身公益事业的敏锐、洞察、细心与大爱；曾冰最后充满才情、感情真挚的附录等等。</p><p>盛夏雨后，在九曲河公园一边散步，一听这本书，四下无人，蝉噪声声，流水潺潺，斑驳的金色撒在翠绿的植被和青石板上，路到一处亭子，突然一阵风吹过，整个人一颤，眼眶湿润，近而嚎啕，心中百感交集。 </p><p>王阳明说圣人必可学而至之，禅宗慧能说即心即佛。以前总以为圣人都在书中，离我们很远，看完这本书，觉得陈行甲真的算是当代“圣人”。他心中有信、纯粹而真挚、博学而包容。樊仁富对作者的评语”一身正气，一身杀气，一身朝气”，真的非常到位。  </p><p>最后和很多读者一样，除了泪目还有就是相见恨晚。非常感谢作者能写这样一本书，这本书不仅让我们看到学霸是如何养成的，还让我们看到一个纯粹、真挚、坚定而温暖的人是如何对待生活的种种。  </p><p>回望自己过去的 30 年时光，尤其是最近的十年，似乎没有了朝气和赤子之心，对自己的将来并不指望能有多大的成就，而在这一刻，我愿能找回初心，不负生命。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QGIS 缓冲区交集信息提取</title>
    <link href="/2024/07/30/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/QGIS%20%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BA%A4%E9%9B%86%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/"/>
    <url>/2024/07/30/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/QGIS%20%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BA%A4%E9%9B%86%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>计算出靠近河道的农田数量及位置，具体方法为使用QGIS 中计算出距离线图层（代表河道）100 米范围内的点（代表水田）图层中的点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407301022501.png" alt="数据概览"></p><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="步骤-1-创建缓冲区"><a href="#步骤-1-创建缓冲区" class="headerlink" title="步骤 1: 创建缓冲区"></a>步骤 1: 创建缓冲区</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407301024905.png" alt="image.png"><br>首先需要基于线图层创建一个缓冲区图层。</p><ol><li>打开 QGIS 并加载您的点图层和线图层。</li><li>搜索框找到 “缓冲区” 工具。</li><li>在弹出的对话框中，选择您的线图层作为输入图层，注意使用投影坐标系，可用重投影工具转换。</li><li>设置缓冲距离为 100 米。</li><li>选择输出图层的位置和文件名，然后点击“运行”。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407301026363.png" alt="image.png"></li></ol><h3 id="步骤-2-裁剪"><a href="#步骤-2-裁剪" class="headerlink" title="步骤 2: 裁剪"></a>步骤 2: 裁剪</h3><p>接下来，使用创建的缓冲区与点图层进行交集操作，以获取位于缓冲区内的点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407301031718.png" alt="image.png"></p><ol><li>使用搜索框找到 “裁剪” 工具。</li><li>在弹出的对话框中，选择点图层作为输入图层 A，刚刚创建的缓冲区图层作为输入图层 B。</li><li>指定输出图层的位置和文件名，然后点击“运行”。</li></ol><p>这样就得到一个新的点图层，其中包含了所有位于原始线图层（河道）两侧 100 米范围内的点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407301031119.png" alt="image.png"></p><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ul><li><strong>坐标系统</strong>：确保坐标系统是以米为单位的投影坐标系，例如 UTM 投影，则需要先将数据重投影到适当的投影坐标系。</li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>qgis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian 首页制作 辅助笔记总结回顾</title>
    <link href="/2024/07/24/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%20%E8%BE%85%E5%8A%A9%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE/"/>
    <url>/2024/07/24/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%E9%A6%96%E9%A1%B5%E5%88%B6%E4%BD%9C%20%E8%BE%85%E5%8A%A9%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>记笔记最重要的是回顾与总结，有这么一款插件可以让我们自己搭建一个美观的首页，它包括热力图、文稿统计、文稿回顾等等功能，你是否愿意尝试呢？</p><p>今天就介绍一款插件，能快速制作笔记首页，辅助总结、回顾。</p><h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p>先看最终效果。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242134300.png" alt="image.png"><br>上面就是利用免费的 components 插件创作首页中的一部分，它的功能远不止于此，下面进行简要的介绍。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>Contribution-graph</li><li>Components</li></ul><h2 id="插件简介"><a href="#插件简介" class="headerlink" title="插件简介"></a>插件简介</h2><p>Components 免费版支持 14 组件，包括数据视图、计数、正计时、倒计时、时间进度、时钟、摘录、按钮、打卡、dataview、图表、markdown、组合、自定义卡片。加上 Contribution-graph 的热力图其实算是 15 种。</p><p>每一个组件除了单独的设置外，都包括有三种展示样式：分栏、标签页、垂直标签页，适合不同的组件进行多样化的组合。而且样式颜色均可以自定义，UI 设计简洁大方，真的非常棒了。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242107681.png" alt="组件内容"></p><h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h3><p>安装好 Contribution-graph 插件后，右键新建热力图即可，可以选择自己喜欢的颜色。看着自己的创作热力图，每天也是动力满满，我也计划在个人博客添加一个类似的组件。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242116393.png" alt="类GitHub热力图"></p><h3 id="每日打卡"><a href="#每日打卡" class="headerlink" title="每日打卡"></a>每日打卡</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407241728217.png" alt="每日打卡预览"><br>可以多个任务，且打卡有渐变色可选择。</p><p>编辑过程：选择打卡组件-修改名称-添加任务-打卡记录方式改为标题属性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407241727680.png"></p><h3 id="正计时、倒计时、时钟"><a href="#正计时、倒计时、时钟" class="headerlink" title="正计时、倒计时、时钟"></a>正计时、倒计时、时钟</h3><p>三个组件设置简单，通过分栏的展示形式更加美观。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242112559.png" alt="时间组"></p><h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>图表是筛选文件夹、标签等方式形成自己想要的文件组成。推荐用垂直标签页展示，这样更宽一点。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242122744.png"></p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p>计数的逻辑和图表一样也是筛选结果展示，可以展示文稿总数、某个标签，或者某个时间段，某个文件夹下的数量。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242124541.png" alt="image.png"><br>可以用作笔记回顾。比如当我们点击想法时就会跳转到包含想法的文件。还包括搜索框，这个功能可以说相当的哇塞。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242126848.png" alt="image.png"></p><h3 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h3><p>摘录可以从筛选条件中随机提取文章，分为全文和块展示，可以做回顾，做每日格言，与weread插件组合可以做​书籍阅读的随机回顾。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407242144296.png" alt="image.png"></p><h3 id="自定义卡片"><a href="#自定义卡片" class="headerlink" title="自定义卡片"></a>自定义卡片</h3><p>用这个在 obsidian 居然可以做一个导航页。设置好动作和链接，就可以做导航页了。可惜和 itab 功能重合了，而且不能分享给大家使用，要不我高低得搭建一个自己的导航页。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407261035977.png"></p><h3 id="Dataview"><a href="#Dataview" class="headerlink" title="Dataview"></a>Dataview</h3><p>Dataview 让你找到在 obsidian 中使用 SQL 的感觉，这个组件甚至可以使用变量。有很多大佬用 dataview 做出很多好玩的东西，也是回顾、总结、联系笔记的好工具。而且会推动我们好好设置文章的属性信息。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407261100554.png"></p><h3 id="Dataviewjs-实现随机回顾"><a href="#Dataviewjs-实现随机回顾" class="headerlink" title="Dataviewjs 实现随机回顾"></a>Dataviewjs 实现随机回顾</h3><p>组件不仅可以使用 dataview 还可以是，使用 dataviewjs，利用 Dataviewjs 代码随机回顾笔记，帮助我们回顾知识点，本文用作每日格言。将凯文凯利的《宝贵的人生建议》中 500 条人生建议，添加标签，用 Dataviewjs 生成 3 条每日格言。<br>查询代码参考少数派@西西弗的神话的《Obsidian 随机生成读书笔记片段》，最终效果如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407261625281.png" alt="image.png"></p><p>Dataviewjs 代码如下</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">//使用时修改关键词即可</span><br>const term = <span class="hljs-string">&quot;#语录&quot;</span><br>const files = app.vault.getMarkdownFiles()<br>const arr = files.<span class="hljs-built_in">map</span>(async ( file) =&gt; &#123;<br>const content = await app.vault.cachedRead(file)<br>const lines = content.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;\n&quot;</span>).<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">line</span> =&gt;</span> line.<span class="hljs-built_in">contains</span>(term))<br><span class="hljs-keyword">return</span> lines<br>&#125;)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateArray</span> (<span class="hljs-params">start, end</span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(end + <span class="hljs-number">1</span>).keys()).<span class="hljs-built_in">slice</span>(start) &#125;<br><br>Promise.<span class="hljs-built_in">all</span>(arr).then(<span class="hljs-function"><span class="hljs-params">values</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//不包含本文件</span><br>    let noteArr = values.flat().<span class="hljs-built_in">filter</span>(<span class="hljs-function"><span class="hljs-params">note</span> =&gt;</span> !note.<span class="hljs-built_in">includes</span>(<span class="hljs-string">&quot;const term =&quot;</span>))<br>    <span class="hljs-comment">//生成一个连续数值的数组</span><br>    let arrNum = generateArray(<span class="hljs-number">0</span>,noteArr.<span class="hljs-built_in">length</span><span class="hljs-number">-1</span>)<br>    let result = [ ]<br>    let ranNum = <span class="hljs-number">3</span><br><br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; ranNum; i++) &#123;<br>        <span class="hljs-keyword">var</span> ran = Math.<span class="hljs-built_in">floor</span>(Math.<span class="hljs-built_in">random</span>() * (arrNum.<span class="hljs-built_in">length</span> - i))<br>        result.<span class="hljs-built_in">push</span>(arrNum[ran])<br>        arrNum[ran] = arrNum[arrNum.<span class="hljs-built_in">length</span> - i - <span class="hljs-number">1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(let i=<span class="hljs-number">0</span>; i&lt; result.<span class="hljs-built_in">length</span>;i++)&#123;<br>        let j = result[i]<br>        dv.paragraph(<span class="hljs-string">`<span class="hljs-subst">$&#123;noteArr[j]&#125;</span>`</span>)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用时记得启用 dataview 插件和 dataviewjs 功能。</p><h3 id="数据视图"><a href="#数据视图" class="headerlink" title="数据视图"></a>数据视图</h3><p>通过筛选文件夹、文件标签等信息，用表格、画册等方式展现笔记，和之间介绍的 projects 插件很像，这里不重复介绍。</p><h3 id="设置页面全宽"><a href="#设置页面全宽" class="headerlink" title="设置页面全宽"></a>设置页面全宽</h3><p>通过 CSS + 文档属性的方式设置页面全宽。</p><p>在 <code>.obsidian/snippets</code> 文件夹下新建 <code>editor-full.css</code> 文件。内容如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-class">.editor-full</span> &#123;<br>  <span class="hljs-attr">--file-line-width</span>: <span class="hljs-number">95vw</span>;<br>  <span class="hljs-attr">--line-width</span>: <span class="hljs-number">95vw</span>;<br>  <span class="hljs-attr">--container-img-width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attr">--table-wrapper-width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 obsidian 设置-外观，找到 CSS 代码片段配置项，点击刷新按钮，此时就会看到 editor-full 这个配置项，将其启用</p><p>在想要设置页面全宽的文章中设置属性，<code>cssclasses</code> ：<code>editor-full</code>。启用页面全宽。<br>可以根据个人习惯决定是否设置全宽。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这个插件有详细的说明文档，使用过程和记录过程都是参考的文档中的描述，大家可以对照文档去尝试，使用过程中，组件添加过多，电脑会很卡，建议少用几个组件，重心放在笔记的梳理、回顾、总结上。</p><h3 id="插件下载地址"><a href="#插件下载地址" class="headerlink" title="插件下载地址"></a>插件下载地址</h3><p><em>Components</em>  </p><p><a href="https://github.com/obsidian-components/obsidian-components-release">obsidian-components&#x2F;obsidian-components-release: Obsidian missing components (github.com)</a><br><em>Contribution-graph</em> </p><p><a href="https://github.com/vran-dev/obsidian-contribution-graph">vran-dev&#x2F;obsidian-contribution-graph: generate interactive gitxxx style contribution graph for obsidian, use it to track your goals, habits, or anything else you want to track. (github.com)</a></p><p>点击 releases 下载复制到 obsidian 插件目录下即可。</p><h3 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h3><p>飞书地址：<br><a href="https://wxycbt0cjk.feishu.cn/wiki/GczJwNXb1iNbookQkbscMXOhnO4"><a href="https://wxycbt0cjk.feishu.cn/wiki/GczJwNXb1iNbookQkbscMXOhnO4">Docs (feishu.cn)</a></a></p><h2 id="相关笔记"><a href="#相关笔记" class="headerlink" title="相关笔记"></a>相关笔记</h2><p><a href="https://blog.csdn.net/weixin_42984235/article/details/140610273">obsidian projects 插件 实现项目管理-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42984235/article/details/137581646">obsidian 微信读书 插件 weread _CSDN博客</a>  </p><p><a href="https://sspai.com/post/69005">Obsidian 随机生成读书笔记片段 _少数派</a>  </p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锻炼 精读笔记 02</title>
    <link href="/2024/07/23/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2002/"/>
    <url>/2024/07/23/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2002/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 锻炼</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/80/cpPlatform_3tKaC95Z1mL61tPJbbGW2F/t7_cpPlatform_3tKaC95Z1mL61tPJbbGW2F.jpg" alt=" 锻炼|200"></li><li>书名： 锻炼</li><li>作者： 丹尼尔·利伯曼</li><li>简介： 我们是为休息而生，还是为跑而生？<br>跑步会毁了你的膝盖吗?<br>哪种运动项目蕞适合我？<br>懒惰是不正常的行为吗？<br>每晚都需要睡够 8 个小时吗？<br>我们可以跑得又快又远吗？<br>体育等于锻炼吗？<br>在不算太遥远的过去，我们那些狩猎采集者、农耕者祖先，为了获得足够的食物，每天需要进行数小时的身体活动，偶尔也会为了娱乐或者社交而做游戏或者跳舞，但没人会为了健康而奔跑或者行走几千米。锻炼只是人类进化过程中近期才出现的现象。哈佛大学进化生物学家丹尼尔·利伯曼凭借自己多年在世界各地的研究与经验，向我们讲述为什么我们从未进化出锻炼的本能。<br>在这本打破神话的书中，利伯曼告诉我们，锻炼，并不是人类的本能。利伯曼从人类学和进化学的角度探讨了我们的身体，破解了关于锻炼的 12 个谬误，教我们可以正确地对待自己的身体并进行正确的身体活动，帮助那些对锻炼感到焦虑、困惑和纠结的人们把锻炼重新放到正确的位置上。</li><li>出版时间 2022-06-01 00:00:00</li><li>ISBN： 9787574202009</li><li>分类： 生活百科-体育</li><li>出版社： 天津科学技术出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/f2432ab0813ab6e75g012b2d">https://weread.qq.com/web/reader/f2432ab0813ab6e75g012b2d</a></li></ul></blockquote><p>书接上文。</p><p>这本书分了 3 个月陆陆续续看完，作者用进化生物学的视角看待身体锻炼。有很多观点作者反复强调，也是最重要的部分，接着之前的精读内容继续。</p><h2 id="解读人类的坐"><a href="#解读人类的坐" class="headerlink" title="解读人类的坐"></a>解读人类的坐</h2><h3 id="为什么喜欢坐着"><a href="#为什么喜欢坐着" class="headerlink" title="为什么喜欢坐着"></a>为什么喜欢坐着</h3><p>坐比站着更节约能量，有研究表明，站着比坐着多消耗 8%<del>10%能量，每小时约相差一片苹果的能量，而且站立时间越长，消耗得越多。在椅子出现之前，人类也用蹲踞来节约能量。椅子近代才有，<br>人体工程学人们坐的更加节约能量，更喜欢坐着。<br>美国人睡眠平均时间是 7 个小时，成年人每天坐着的时间 9</del>10 个小时，老年人坐着的时间是 12 个小时。</p><h3 id="运动强度划分"><a href="#运动强度划分" class="headerlink" title="运动强度划分"></a>运动强度划分</h3><p><strong>坐姿活动</strong>：心率范围为静息心率与最高心率的 40%之间<br><strong>轻量运动</strong>：做饭、慢走，心率范围为最高心率的 40%至 54%之间<br><strong>中等强度运动</strong>：快走、瑜伽、园艺劳动，心率范围为最高心率的 55%至 69%之间<br><strong>高强度运动</strong>：跑步、开合跳、爬山，心率为最高心率的 70%以上。  </p><p>数据表明，普通成年人每天的轻量活动时间大约为 5.5 小时，中等强度活动只有 20 分钟，剧烈活动时间不足 1 分钟。而狩猎采集者成年人每天花在轻量活动上的时间接近 4 小时，中等强度活动 2 小时，剧烈活动 20 分钟。</p><h3 id="久坐的危害"><a href="#久坐的危害" class="headerlink" title="久坐的危害"></a>久坐的危害</h3><p>久坐会导致血糖和血脂浓度升高，引发身体出现慢性轻度炎症。慢性轻度炎症的诱因包括吸烟、肥胖、促炎食物（红肉等 ）以及缺乏运动。</p><h3 id="久坐引起慢性炎症的过程"><a href="#久坐引起慢性炎症的过程" class="headerlink" title="久坐引起慢性炎症的过程"></a>久坐引起慢性炎症的过程</h3><p>身体中大部分脂肪无害，狩猎采集者健康男性体脂率为 10%<del>25%（我的体脂率为 25.6%），健康女性的体脂率为 10%</del>30%。这些脂肪 90%~95%为皮下脂肪，他们是重要的能力储藏室。还有一部分位于肚子周围以及各种脏器，他们的名字包括“内脏脂肪”、“腰部脂肪”、“肚子脂肪”和“异常脂肪”，显然越少越好。正常情况下内脏脂肪约占体重的 1%，在做长距离慢跑等有氧运动是会排上用场。</p><p>久坐引起慢性炎症的四种方式</p><ol><li>久坐减少了能量消耗，转为了内账脂肪，过多的脂肪，尤其是内脏脂肪会引发慢性轻度炎症。</li><li>久坐降低了身体吸收脂肪和糖的能力，进而引发慢性炎症。</li><li>久坐容易让人产生心理压力。</li><li>久坐造成肌肉僵化，从而诱发慢性炎症。</li></ol><p>对照久坐引起的慢性炎症的过程，思考如何养成良好的习惯</p><ol><li>饭后百步走，活到九十九。</li><li>有活力的坐着，周期站起来活动，做诸如开合跳等动作可减少慢性炎症。</li><li>周末徒步、登山等活动，亲近大自然，减少心理压力。</li><li>规律运动、锻炼，避免肌肉僵化。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在科技越来越发达的今天，让人类感到快乐、便捷的东西越来越多，如电梯、汽车、人体工学椅，人类的活动量越来越少，肥胖者越来越多，各种疾病越来越多，究其原因是十万年甚至百万年的身体机能与现代生活的失配。以进化生物学的视角来审视这失配，从而进行调整，非常有意思且有意义。在身体健康的方面，规律锻炼就是给身体必要的活动量。从细微出发，比如说做家务、走楼梯、饭后运动这些小的变化，也许微不足道，但当我们明白得越多，应对越从容，这就是第一层与第五层的区别。</p><p>再进一步说失配，除了身体与科技进步的失配外，心理呢，情绪，甚至文化伦理呢？趋利避害等天性与当前的社会发展同样存在失配。说到底人的各种情绪会受到身体激素的影响。我们是不是应该也用一种更高的视角去观察，去审视，比如学习哲学，学习心理学等等，主动拥抱变化，实现第一层到第三层甚至第五层的转变，让自己更加从容自信。<br>未完待续~</p><p>未完待续~</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://blog.csdn.net/weixin_42984235/article/details/139482669">锻炼 精读笔记 01-CSDN博客</a><br><a href="https://blog.csdn.net/weixin_42984235/article/details/140129827">锻炼 读书笔记 番外 身体激素及神经递质-CSDN博客</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>锻炼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian projects 插件 实现项目管理</title>
    <link href="/2024/07/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20projects%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2024/07/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20projects%20%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天推荐 obsidian 的项目管理插件 projects ，用免费工具实现本地化项目管理。该工具项目管理思路非常类似 trello，简单易上手，而且和个人笔记强关联，非常适合喜欢折腾和 all in one 的玩家。</p><p><strong>插件主要特点</strong></p><ol><li>包含 Table、Board、Calendar、Gallery 4 个视图。</li><li>Table 表格。清晰展示各个项目的属性，可以配置属性显示内容。</li><li>Board 看板。通过属性不同项目，比如状态、重要程度等。</li><li>Calendar 日历。界面用带有时间的元数据展示项目时间。</li><li>Gallery 画册。以图册的形式展示项目。</li><li>各种视图均连接项目文件，高度自定义，适合多场景。</li></ol><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>在应用商店直接下载 projects 插件。点击安装即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7ed4bab9e57ea9c550cab9279ab9d5f8.png" alt="下载插件"></p><h2 id="项目管理搭建"><a href="#项目管理搭建" class="headerlink" title="项目管理搭建"></a>项目管理搭建</h2><p>推荐通过 demo 案例查看 projects 插件项目管理逻辑。</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>点击新建项目图标<br>输入名称、文件夹路径等，建议预先设置好文件夹。<br><img src="https://img-blog.csdnimg.cn/img_convert/7c5282b06b1b7e4c150e2915b7516a7f.png" alt="新建项目设置"></p><h3 id="配置项目模板"><a href="#配置项目模板" class="headerlink" title="配置项目模板"></a>配置项目模板</h3><p>这是最重要的部分，我参考 demo 中的元数据结构，最终修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">Status:</span> <span class="hljs-string">doing</span><br><span class="hljs-attr">Due:</span> <span class="hljs-number">2024-07-22</span><br><span class="hljs-attr">Done:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">Weight:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">todo</span><br><span class="hljs-attr">Image:</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><p>Status：状态。Doing，done，backlog，daley， plan。<br>Due：截止日期。<br>Weight：重要性。1-5<br>Tags：标签。Todo（结合 checklist 工具，加上后自动变为 task）<br>Image：图，用图床地址，也可以本地地址，推荐图床地址，obsidian 搭建图床可以看我之前的文章。<br>Done：是否完成，完成后归档</p><p>这里可以根据自己的需要自定义，比如指定 people 等等。<br>需要注意，当我们把模板元数据设置好时，最好给一个初始值，这样能让 projects 识别到标签类型。</p><h3 id="新建项目-1"><a href="#新建项目-1" class="headerlink" title="新建项目"></a>新建项目</h3><p>设置好后会自动进入空白的表格视图，点击新建项目，一是会自动新建一个 md 文档，自动生成一列项目。点击 name 后就可以自动编辑内容了，修改元数据内容，对应的表格信息也会修改。<br><img src="https://img-blog.csdnimg.cn/img_convert/71cae22678c4eda2d695b577e9339992.png" alt="表格视图"><br>可以通过隐藏字段来展示自己想要的内容，比如只展示名称、状态、重要性、截止日期等。<br>可以在 table 页面管理多个子项的内容，非常方便</p><h3 id="新增其他视图"><a href="#新增其他视图" class="headerlink" title="新增其他视图"></a>新增其他视图</h3><p>点击表格旁边的加号，可以新增 Board、Calendar、Gallery。思路都是一样不同的元数据来展示不同的信息，例如状态对应 Board 视图、截止日期对应日历视图，图片对应图册视图等等。<br>在每个视图下，都能新建项目，点击就能管理具体的项目，真的非常好用。</p><h4 id="看板视图"><a href="#看板视图" class="headerlink" title="看板视图"></a>看板视图</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/bb4fd9ff15bd618ce1a25d04c2a0ea4d.png" alt="看板视图"></p><h4 id="画册视图"><a href="#画册视图" class="headerlink" title="画册视图"></a>画册视图</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/461be4e33386842d1a84221464fcc633.png" alt="画册视图"></p><h4 id="日历视图"><a href="#日历视图" class="headerlink" title="日历视图"></a>日历视图</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/3936b19e70b668191d9786dd17f6a8cc.png" alt="日历视图"></p><h2 id="相关思考"><a href="#相关思考" class="headerlink" title="相关思考"></a>相关思考</h2><p>通过这个插件可以实现整个团队的项目管理，也可以单个项目的管理，还可以是兴趣爱好的管理，比如图书、电影等。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://blog.csdn.net/weixin_42984235/article/details/136734612">精简版 Obsidian 图床配置 PicGo+ gitee-CSDN博客</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>项目管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian projects  实现项目管理</title>
    <link href="/2024/07/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20projects%20%20%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2024/07/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20projects%20%20%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" ><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天推荐 obsidian 的项目管理插件 projects ，用免费工具实现本地化项目管理。该工具项目管理思路非常类似 trello，简单易上手，而且和个人笔记强关联，非常适合喜欢折腾和 all in one 的玩家。</p><p><strong>插件主要特点</strong></p><ol><li>包含 Table、Board、Calendar、Gallery 4 个视图。</li><li>Table 表格。清晰展示各个项目的属性，可以配置属性显示内容。</li><li>Board 看板。通过属性不同项目，比如状态、重要程度等。</li><li>Calendar 日历。界面用带有时间的元数据展示项目时间。</li><li>Gallery 画册。以图册的形式展示项目。</li><li>各种视图均连接项目文件，高度自定义，适合多场景。</li></ol><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>在应用商店直接下载 projects 插件。点击安装即可。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7ed4bab9e57ea9c550cab9279ab9d5f8.png" alt="下载插件"></p><h2 id="项目管理搭建"><a href="#项目管理搭建" class="headerlink" title="项目管理搭建"></a>项目管理搭建</h2><p>推荐通过 demo 案例查看 projects 插件项目管理逻辑。</p><h3 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3><p>点击新建项目图标<br>输入名称、文件夹路径等，建议预先设置好文件夹。<br><img src="https://img-blog.csdnimg.cn/img_convert/7c5282b06b1b7e4c150e2915b7516a7f.png" alt="新建项目设置"></p><h3 id="配置项目模板"><a href="#配置项目模板" class="headerlink" title="配置项目模板"></a>配置项目模板</h3><p>这是最重要的部分，我参考 demo 中的元数据结构，最终修改如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">Status:</span> <span class="hljs-string">doing</span><br><span class="hljs-attr">Due:</span> <span class="hljs-number">2024-07-22</span><br><span class="hljs-attr">Done:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">Weight:</span> <span class="hljs-number">5</span><br><span class="hljs-attr">Tags:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Todo</span><br><span class="hljs-attr">Image:</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br></code></pre></td></tr></table></figure><p>Status：状态。Doing，done，backlog，daley， plan。<br>Due：截止日期。<br>Weight：重要性。1-5<br>Tags：标签。Todo（结合 checklist 工具，加上后自动变为 task）<br>Image：图，用图床地址，也可以本地地址，推荐图床地址，obsidian 搭建图床可以看我之前的文章。<br>Done：是否完成，完成后归档</p><p>这里可以根据自己的需要自定义，比如指定 people 等等。<br>需要注意，当我们把模板元数据设置好时，最好给一个初始值，这样能让 projects 识别到标签类型。</p><h3 id="新建项目-1"><a href="#新建项目-1" class="headerlink" title="新建项目"></a>新建项目</h3><p>设置好后会自动进入空白的表格视图，点击新建项目，一是会自动新建一个 md 文档，自动生成一列项目。点击 name 后就可以自动编辑内容了，修改元数据内容，对应的表格信息也会修改。<br><img src="https://img-blog.csdnimg.cn/img_convert/71cae22678c4eda2d695b577e9339992.png" alt="表格视图"><br>可以通过隐藏字段来展示自己想要的内容，比如只展示名称、状态、重要性、截止日期等。<br>可以在 table 页面管理多个子项的内容，非常方便</p><h3 id="新增其他视图"><a href="#新增其他视图" class="headerlink" title="新增其他视图"></a>新增其他视图</h3><p>点击表格旁边的加号，可以新增 Board、Calendar、Gallery。思路都是一样不同的元数据来展示不同的信息，例如状态对应 Board 视图、截止日期对应日历视图，图片对应图册视图等等。<br>在每个视图下，都能新建项目，点击就能管理具体的项目，真的非常好用。</p><h4 id="看板视图"><a href="#看板视图" class="headerlink" title="看板视图"></a>看板视图</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/bb4fd9ff15bd618ce1a25d04c2a0ea4d.png" alt="看板视图"></p><h4 id="画册视图"><a href="#画册视图" class="headerlink" title="画册视图"></a>画册视图</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/461be4e33386842d1a84221464fcc633.png" alt="画册视图"></p><h4 id="日历视图"><a href="#日历视图" class="headerlink" title="日历视图"></a>日历视图</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/3936b19e70b668191d9786dd17f6a8cc.png" alt="日历视图"></p><h2 id="相关思考"><a href="#相关思考" class="headerlink" title="相关思考"></a>相关思考</h2><p>通过这个插件可以实现整个团队的项目管理，也可以单个项目的管理，还可以是兴趣爱好的管理，比如图书、电影等。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://blog.csdn.net/weixin_42984235/article/details/136734612">精简版 Obsidian 图床配置 PicGo+ gitee-CSDN博客</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian插件</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 项目框架管理</title>
    <link href="/2024/07/16/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2024/07/16/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>如何管理组织一个 python 项目是很重要且比较难的事情，而且并没有标准化。我最近看了一些资料并结合自己的工作经验，把我的项目框架管理记录下来，希望对大家有用，后续也会不断优化我的项目管理。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407161144118.png" alt="image.png"></p><p>注意事项：</p><ol><li>项目名称遵循驼峰原则</li><li>解释器选择项目 venv </li><li>新版 pycharm 默认为. Venv 文件夹。更好一点。</li></ol><h3 id="安装及更新依赖"><a href="#安装及更新依赖" class="headerlink" title="安装及更新依赖"></a>安装及更新依赖</h3><p>为了保证项目简洁，建议在本地项目下新建requirements. Txt 文件夹。一开始你可能根本不知道自己引用的包是什么版本, 没关系，先安装然后再运行更新代码会自动添加版本号。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">streamlit<br>requests<br>pandas<br>numpy<br>matplotlib<br>seaborn<br>SQLAlchemy<br>PyMySQL<br>folium<br>geojson<br></code></pre></td></tr></table></figure><p>使用命令进行安装</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">pip install --<span class="hljs-keyword">index</span>-url https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt</span><br></code></pre></td></tr></table></figure><p>使用下面的命令更新 requirements. txt</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pip <span class="hljs-keyword">freeze</span> &gt; requirements.txt<br></code></pre></td></tr></table></figure><h2 id="引用包"><a href="#引用包" class="headerlink" title="引用包"></a>引用包</h2><p>引用第三方包，直接用 import pandas as pd 这种格式就好了。<br>引用本地包，需要先组织好自己的包。Py 文件所在的文件夹添加__init__. Py 文件则可以让 python 识别为一个包。用 from ** import ** 就好了。</p><h2 id="Python-项目结构"><a href="#Python-项目结构" class="headerlink" title="Python 项目结构"></a>Python 项目结构</h2><p>以 streamlit 可视化数据分析项目为例，总结我的项目框架。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs markdown">├── my<span class="hljs-emphasis">_streamlit_</span>app/<br>│   ├── app.py             # 主入口点，用于启动Streamlit应用<br>│   ├── pages/<br>│   │   ├── <span class="hljs-strong">__init__</span>.py<br>│   │   ├── page1.py       # Streamlit页面1<br>│   │   └── page2.py       # Streamlit页面2<br>│   ├── models/<br>│   │   ├── <span class="hljs-strong">__init__</span>.py<br>│   │   └── data<span class="hljs-emphasis">_model.py  # 数据模型、类</span><br><span class="hljs-emphasis">│   ├── services/</span><br><span class="hljs-emphasis">│   │   ├── <span class="hljs-strong">__init__</span>.py</span><br><span class="hljs-emphasis">│   │   └── data_</span>service.py  # 数据服务<br>│   ├── utils/<br>│   │   ├── <span class="hljs-strong">__init__</span>.py<br>│   │   └── helper<span class="hljs-emphasis">_functions.py  # 辅助函数、静态函数</span><br><span class="hljs-emphasis">│   ├── config/</span><br><span class="hljs-emphasis">│   │   ├── <span class="hljs-strong">__init__</span>.py</span><br><span class="hljs-emphasis">│   │   └── settings.py      # 配置文件</span><br><span class="hljs-emphasis">│   └── tests/</span><br><span class="hljs-emphasis">│       ├── <span class="hljs-strong">__init__</span>.py</span><br><span class="hljs-emphasis">│       ├── test_</span>pages.py<br>│       ├── test<span class="hljs-emphasis">_models.py</span><br><span class="hljs-emphasis">│       └── test_</span>services.py<br>│<br>├── .gitignore<br>├── README.md<br>├── requirements.txt       # 项目依赖列表<br>└── setup.py               # 构建脚本，用于打包和分发项目<br></code></pre></td></tr></table></figure><p>这个结构展示了<code>my_streamlit_app</code>作为项目根目录，其中包含了<code>app.py</code>作为Streamlit应用的入口点，<code>pages</code>目录用于存放各个页面的脚本，<code>models</code>、<code>services</code>、<code>utils</code>和<code>config</code>目录分别用于存放数据模型、业务逻辑服务、通用工具函数和配置文件。<code>tests</code>目录用于单元测试和集成测试代码。<br><code>setup.py</code> 位于项目根目录下，用于项目的构建、安装和分发，而 <code>requirements.txt</code> 文件列出了项目运行所需的Python包依赖。<br>注意：Streamlit 有一种简化的方式来管理多页面应用程序，称为“Multi-page Apps”。这种新特性允许你在 <code>pages</code> 目录下放置每个页面的 Python 文件，Streamlit 会自动检测并列出这些页面供用户选择。</p><p>当然，市面上也有很多中项目管理的方法，如领域驱动设计（Domain-Driven Design, DDD）和洋葱架构（The Onion Architecture），只要找到适合自己的项目结构就行了。</p><h2 id="其他：自定义-venv-方法"><a href="#其他：自定义-venv-方法" class="headerlink" title="其他：自定义 venv 方法"></a>其他：自定义 venv 方法</h2><p>有的 IDE，没有自动添加 venv ，需要手动增加，可以在命令行运行：<br>Unix&#x2F;Linux shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">i[!-d&quot;.venv&quot; ] ; then<br>python -m venv .venv<br>fi<br>echo<br>read -n1-s-r -p)&quot;Press any key to continue<br></code></pre></td></tr></table></figure><p>Windows PowerShell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs PowerShell"><span class="hljs-keyword">if</span> (<span class="hljs-operator">-not</span> (<span class="hljs-built_in">Test-Path</span> <span class="hljs-literal">-Path</span> <span class="hljs-string">&quot;.venv&quot;</span> <span class="hljs-literal">-PathType</span> Container)) &#123;<br>    python <span class="hljs-literal">-m</span> venv .venv<br>&#125;<br><br><span class="hljs-comment"># 输出换行符</span><br><span class="hljs-built_in">Write-Host</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-comment"># 等待用户按键</span><br><span class="hljs-built_in">Read-Host</span> <span class="hljs-literal">-Prompt</span> <span class="hljs-string">&quot;Press any key to continue&quot;</span><br></code></pre></td></tr></table></figure><h3 id="激活-venv"><a href="#激活-venv" class="headerlink" title="激活 venv"></a>激活 venv</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">.venv\scripts\activate.ps1<br></code></pre></td></tr></table></figure><h3 id="删除-venv"><a href="#删除-venv" class="headerlink" title="删除 venv"></a>删除 venv</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-comment">Remove-Item .\.venv -Recurse -Force</span><br></code></pre></td></tr></table></figure><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 类的使用</title>
    <link href="/2024/07/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/07/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="类的学习"><a href="#类的学习" class="headerlink" title="类的学习"></a>类的学习</h2><p>在Python中，类是面向对象编程（OOP）的核心概念之一，它提供了一种封装数据和相关方法的方式。类定义了一个对象的蓝图，描述了对象应该具有的属性（变量）和方法（函数）。</p><h3 id="定义一个类"><a href="#定义一个类" class="headerlink" title="定义一个类"></a>定义一个类</h3><p>在Python中，定义一个类使用<code>class</code>关键字。类定义通常包含类名、属性和方法。这里是一个简单的类定义示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-comment"># 类属性</span><br>    species = <span class="hljs-string">&quot;Canis familiaris&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># 实例属性</span><br>        self.name = name<br>        self.age = age<br>    <span class="hljs-comment"># 实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> says Woof!&quot;</span>)<br>    <span class="hljs-comment"># 另一个实例方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">description</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is <span class="hljs-subst">&#123;self.age&#125;</span> years old.&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的类定义中：</p><ul><li><code>Dog</code>是类名，遵循驼峰命名法（CamelCase）。</li><li><code>__init__</code>方法是一个特殊的方法，称为构造函数或初始化方法，当创建类的实例时会被自动调用。它接受<code>self</code>参数，代表实例本身，以及<code>name</code>和<code>age</code>参数。</li><li><code>species</code>是一个类属性，所有<code>Dog</code>类的实例共享同一个<code>species</code>属性。</li><li><code>bark</code>和<code>description</code>是实例方法，它们也接受<code>self</code>参数，用于访问实例的属性。</li></ul><h3 id="创建类的实例"><a href="#创建类的实例" class="headerlink" title="创建类的实例"></a>创建类的实例</h3><p>要创建类的实例，只需调用类，就像它是函数一样，并传入必要的参数。以下是创建<code>Dog</code>类的实例的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dog1 = Dog(<span class="hljs-string">&quot;Fido&quot;</span>, <span class="hljs-number">3</span>)<br>dog2 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(dog1.description())  <span class="hljs-comment"># 输出: Fido is 3 years old.</span><br><span class="hljs-built_in">print</span>(dog2.bark())         <span class="hljs-comment"># 输出: Buddy says Woof!</span><br></code></pre></td></tr></table></figure><h3 id="访问属性和方法"><a href="#访问属性和方法" class="headerlink" title="访问属性和方法"></a>访问属性和方法</h3><p>通过点符号<code>.</code>，你可以访问实例的属性和调用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(dog1.name)           <span class="hljs-comment"># 输出: Fido</span><br><span class="hljs-built_in">print</span>(dog1.age)            <span class="hljs-comment"># 输出: 3</span><br><span class="hljs-built_in">print</span>(dog1.species)        <span class="hljs-comment"># 输出: Canis familiaris</span><br></code></pre></td></tr></table></figure><h3 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h3><p>除了实例方法，你还可以定义类方法和静态方法。类方法通常用于操作类级别的属性，而静态方法则是不依赖于类或实例状态的普通函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    species = <span class="hljs-string">&quot;Canis familiaris&quot;</span><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_species</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">return</span> cls.species<br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_bark_sound</span>(<span class="hljs-params">sound</span>):<br>        <span class="hljs-keyword">return</span> sound == <span class="hljs-string">&quot;Woof!&quot;</span><br>dog1 = Dog(<span class="hljs-string">&quot;Fido&quot;</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(Dog.get_species())       <span class="hljs-comment"># 输出: Canis familiaris</span><br><span class="hljs-built_in">print</span>(Dog.is_bark_sound(<span class="hljs-string">&quot;Woof&quot;</span>)) <span class="hljs-comment"># 输出: True</span><br></code></pre></td></tr></table></figure><p>在上述代码中，<code>@classmethod</code> 装饰器表示 <code>get_species</code> 方法是类方法，可以通过类名直接调用；<code>@staticmethod</code> 装饰器表示 <code>is_bark_sound</code> 方法是静态方法，同样可以直接通过类名调用，但它既不接受 <code>self</code> 也不接受 <code>cls</code> 参数。</p><h2 id="私有化方法"><a href="#私有化方法" class="headerlink" title="私有化方法"></a>私有化方法</h2><p>在面向对象编程中，私有化方法（以及属性）是封装原则的一部分，它限制了对类内部实现细节的访问。在Python中，私有化是通过命名约定来实现的，而不是通过严格的访问控制机制，如其他语言中的<code>private</code>关键字。Python中，私有化成员的命名通常会在名称前加一个或两个下划线。</p><h3 id="私有化方法的作用："><a href="#私有化方法的作用：" class="headerlink" title="私有化方法的作用："></a>私有化方法的作用：</h3><ol><li><strong>封装：</strong> 封装是面向对象编程的四大支柱之一，它指的是将数据和操作数据的方法捆绑在一起，并对外部隐藏其内部实现细节。私有化方法可以隐藏实现逻辑，只暴露必要的公共接口，这有助于保护类的内部状态。    </li><li><strong>防止外部修改：</strong> 私有化方法可以防止外部代码直接调用或修改，从而避免破坏类的内部一致性或引发错误。这有助于保持代码的稳定性和安全性。    </li><li><strong>模块化：</strong> 私有化方法可以将复杂功能分解成更小的部分，这些部分在类内部实现，但对外部不可见。这有助于提高代码的可读性和可维护性。    </li><li><strong>便于重构：</strong> 如果一个方法被标记为私有，那么在将来重构代码时，你可以自由地更改或删除这个方法，而不用担心影响到依赖于它的外部代码。</li></ol><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ol><li><strong>辅助方法：</strong> 私有化方法通常用于实现类的公共方法，这些方法不是为了被外部调用，而是为了内部逻辑的完整性和清晰性。    </li><li><strong>实现细节：</strong> 如果一个方法仅用于内部数据的处理，且其逻辑可能会频繁变化，那么将这个方法私有化可以避免对外部造成影响。    </li><li><strong>防止滥用：</strong> 对于容易被误用或可能引发副作用的方法，可以考虑私有化，以防止不当调用。</li></ol><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><p>在Python中，私有化方法通常通过以下两种方式命名：</p><ul><li><strong>单下划线 <code>_</code>：</strong> 前面加单下划线的方法或属性被认为是“弱私有”，这表明它们是内部使用的，但并不会阻止外部访问，更多是一种约定。    </li><li><strong>双下划线 <code>__</code>：</strong> 前面加双下划线的方法或属性会触发名称重整（name mangling），这会改变属性或方法的名称，使其在类的外部不容易被误引用。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, balance=<span class="hljs-number">0</span></span>):<br>    <span class="hljs-variable language_">self</span>.__balance = balance<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, amount</span>):<br>    <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-variable language_">self</span>.__update_balance(amount)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, amount</span>):<br>    <span class="hljs-keyword">if</span> amount &lt;= <span class="hljs-variable language_">self</span>.<span class="hljs-symbol">__balance:</span><br>        <span class="hljs-variable language_">self</span>.__update_balance(-amount)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__update_balance</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, amount</span>):<br>    <span class="hljs-variable language_">self</span>.__balance += amount<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_balance</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__balance<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>BankAccount</code>类的<code>__update_balance</code>方法是私有的，它被用于更新账户余额。外部代码不能直接调用<code>__update_balance</code>，而必须通过<code>deposit</code>和<code>withdraw</code>方法间接访问，这保证了余额更新的正确性和安全性。<br>总的来说，私有化方法在Python中主要是通过命名约定来实现的，它帮助开发者维护良好的封装，保护类的内部状态，提高代码质量和可维护性。</p><h2 id="其他相关问题"><a href="#其他相关问题" class="headerlink" title="其他相关问题"></a>其他相关问题</h2><h3 id="class-中-staticmethod-有什么用"><a href="#class-中-staticmethod-有什么用" class="headerlink" title="class 中@staticmethod 有什么用"></a>class 中@staticmethod 有什么用</h3><p>在Python中，<code>@staticmethod</code>装饰器用于定义一个类的静态方法。静态方法不绑定到类的实例，也就是说，它们不接受<code>self</code>参数，也不需要类的实例就能调用。静态方法主要用于执行与类相关的但不依赖于类的状态（即类的属性或实例的属性）的操作。</p><h3 id="Class-的-Inheritance-是什么意思，有什么用？"><a href="#Class-的-Inheritance-是什么意思，有什么用？" class="headerlink" title="Class  的 Inheritance 是什么意思，有什么用？"></a>Class  的 Inheritance 是什么意思，有什么用？</h3><p>类的继承（Inheritance）是面向对象编程（Object-Oriented Programming，OOP）中的一个核心概念。继承允许程序员创建一个新类（称为子类或派生类），该类继承另一个已存在的类（称为父类或基类）的属性和方法。通过继承，子类自动获得父类的所有非私有属性和方法，从而可以重用和扩展父类的功能，而无需重复编写代码。</p><h3 id="继承的意义和用途："><a href="#继承的意义和用途：" class="headerlink" title="继承的意义和用途："></a>继承的意义和用途：</h3><ol><li><strong>代码重用：</strong> 继承允许子类重用父类的代码，这减少了代码的冗余，提高了代码的复用性，简化了开发过程。    </li><li><strong>扩展功能：</strong> 子类不仅可以继承父类的特性，还可以添加自己的属性和方法，或者重写（override）父类的方法以提供不同的实现。    </li><li><strong>分层设计：</strong> 继承支持层次化的类设计，允许将通用功能放在基类中，而具体的实现细节放在派生类中，这有助于创建清晰和灵活的类层次结构。    </li><li><strong>多态性：</strong> 继承是实现多态性的基础，多态性允许使用基类类型的指针或引用调用派生类的对象，这意味着可以编写更通用的代码，而不必关心具体使用的是哪个子类的实例。</li><li><strong>抽象与具体：</strong> 继承可以用来定义抽象基类，这类基类不能实例化，但可以包含抽象方法（必须在派生类中实现的方法）。这确保了所有派生类都实现了某些核心功能。</li></ol><h3 id="Python中的继承示例："><a href="#Python中的继承示例：" class="headerlink" title="Python中的继承示例："></a>Python中的继承示例：</h3><p>假设我们有以下基类 <code>Animal</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>    self.name = name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">&quot;Subclass must implement this abstract method&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> moves.&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们可以创建一个派生类 <code>Dog</code>，继承自 <code>Animal</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>    <span class="hljs-built_in">super</span>().__init__(name)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> says Woof!&quot;</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>Dog</code> 类继承了 <code>Animal</code> 类的 <code>__init__</code> 方法和 <code>move</code> 方法，并实现了抽象方法 <code>speak</code>。<code>super()</code> 函数用于调用父类的构造函数，确保 <code>Dog</code> 实例正确初始化。</p><h3 id="使用继承："><a href="#使用继承：" class="headerlink" title="使用继承："></a>使用继承：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dog = Dog(<span class="hljs-string">&quot;Rover&quot;</span>)<br><span class="hljs-built_in">print</span>(dog.speak())  <span class="hljs-comment"># 输出: Rover says Woof!</span><br>dog.move()       <br></code></pre></td></tr></table></figure><p>在实际应用中，继承可以极大地提高代码的可维护性和扩展性，使得程序设计更加模块化和灵活。</p><h2 id="By"><a href="#By" class="headerlink" title="By"></a>By</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> python 迭代器介绍</title>
    <link href="/2024/07/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/07/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>迭代器（Iterator）在Python中是一种可以记住遍历位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完为止。迭代器只能往前不会后退，也就是只能前进遍历，不能反向遍历或跳过元素。迭代器在Python中扮演着重要角色，因为它们是序列类型以及任何实现了迭代协议的对象的基础。</p><h3 id="迭代器的应用场景："><a href="#迭代器的应用场景：" class="headerlink" title="迭代器的应用场景："></a>迭代器的应用场景：</h3><ol><li><strong>节省内存：</strong> 当处理大数据集时，迭代器不需要一次性加载所有数据到内存中，而是按需生成数据，这在处理大型文件、流数据或无限序列时非常有用。    </li><li><strong>惰性求值：</strong> 迭代器允许代码在运行时延迟计算，只在真正需要时才产生值，这对于效率和性能至关重要，尤其是当处理可能永远不会完全使用的无限或非常大的数据流时。    </li><li><strong>链式操作：</strong> 迭代器可以很容易地链接在一起，形成复杂的流水线，每一步处理都是独立的，但又可以顺序执行。    </li><li><strong>生成器：</strong> 迭代器的一个常见实现是生成器，它是一种特殊的迭代器，通过定义带有<code>yield</code>语句的函数来创建。生成器可以暂停执行并保存状态，在下次迭代时恢复，这样就可以生成一系列值，而无需一次性生成全部。</li></ol><h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map() 函数"></a>map() 函数</h2><p>在Python中，<code>map()</code>函数是一种内置函数，用于将指定的函数应用到可迭代对象（如列表、元组等）的所有元素上，并返回一个迭代器，该迭代器生成应用函数后的结果。<code>map()</code>函数的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(function, iterable, ...)<br></code></pre></td></tr></table></figure><p>这里的参数说明如下：</p><ul><li><code>function</code>: 你想要应用到每一个元素上的函数。</li><li><code>iterable</code>: 一个或多个可迭代对象，其元素将被传递给<code>function</code>。</li></ul><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设我们有一个数字列表，我们想要对列表中的每个元素进行平方操作，可以使用<code>map()</code>和一个lambda表达式来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>squared = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, numbers)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(squared))  <span class="hljs-comment"># 输出: [1, 4, 9, 16]</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>lambda x: x**2</code>是一个匿名函数，它接受一个参数<code>x</code>并返回<code>x</code>的平方。<code>map()</code>函数接收这个匿名函数和<code>numbers</code>列表作为参数，然后返回一个迭代器。由于<code>map()</code>返回的是一个迭代器，通常我们需要将其转换为列表或其他集合类型以便于查看结果。</p><h3 id="多个可迭代对象"><a href="#多个可迭代对象" class="headerlink" title="多个可迭代对象"></a>多个可迭代对象</h3><p><code>map()</code>函数还可以接受多个可迭代对象作为参数，如果这样做，它会将这些可迭代对象中的对应元素一起传递给函数。例如，如果我们有两个列表，我们想要计算它们元素的和：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>list2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>sums = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x, y: x + y, list1, list2)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(sums))  <span class="hljs-comment"># 输出: [5, 7, 9]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>lambda x, y: x + y</code> 是一个接受两个参数的匿名函数，<code>map()</code> 将 <code>list1</code> 和 <code>list2</code> 中的对应元素分别传递给这个函数。</p><h3 id="其他迭代器："><a href="#其他迭代器：" class="headerlink" title="其他迭代器："></a>其他迭代器：</h3><p>除了 <code>map()</code> 生成的迭代器外，Python 还提供了许多其他的迭代器和迭代器构建器，包括但不限于：</p><ul><li><strong>filter ()：</strong> 用于过滤序列，构造由 <code>function</code> 返回值为 <code>True</code> 的元素组成的迭代器。</li><li><strong>zip ()：</strong> 将多个可迭代对象聚合成一个迭代器，聚合后的元素是各可迭代对象中对应的元素组成的元组。</li><li><strong>enumerate ()：</strong> 返回一个枚举对象，它将可迭代对象的每个元素与一个索引号配对。</li><li><strong>itertools 模块：</strong> 提供了一系列高性能的迭代器构建块，比如 <code>chain()</code>, <code>cycle()</code>, <code>repeat()</code>, <code>groupby()</code>, <code>permutations()</code>, <code>combinations()</code> 等等。<br>这些迭代器和迭代器构建器可以单独使用，也可以组合使用，以实现各种复杂的数据处理逻辑，同时保持代码的清晰和效率。<br>例如，结合 <code>map()</code> 和 <code>filter()</code>，你可以先过滤数据，然后对过滤后的数据应用某种转换：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Python">numbers = <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br>even_squares = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, numbers))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(even_squares))  <span class="hljs-comment"># 输出: [0, 4, 16, 36, 64]</span><br></code></pre></td></tr></table></figure></li></ul><p>这段代码首先使用 <code>filter()</code> 筛选出偶数，然后使用 <code>map()</code> 计算这些偶数的平方。最终结果是一个包含偶数平方的列表。</p><h2 id="By"><a href="#By" class="headerlink" title="By"></a>By</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>edge 学习工具包推荐</title>
    <link href="/2024/07/11/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%95%B0%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%85%AC%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/07/11/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%95%B0%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%85%AC%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>推荐微软推出的学习工具包两项工具：数学求解器和 pdf 阅读器。<br>打开 edge 学习工具包的方法 ：右上角三点-更多工具-学习工具包。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110942207.png" alt="image.png"></p><h3 id="math-solver"><a href="#math-solver" class="headerlink" title="math solver"></a>math solver</h3><p> 除了基础的计算求解外，还用图标展示公式，清晰直观。<br>地址：<a href="https://mathsolver.microsoft.com/zh/solver">求解 | Microsoft Math Solver</a><br>示例 1<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110928751.png" alt="image.png"><br>示例 2<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110929108.png" alt="image.png"></p><h3 id="pdf-阅读器"><a href="#pdf-阅读器" class="headerlink" title="pdf 阅读器"></a>pdf 阅读器</h3><p>除了数学求解，edge 推出的学习工具包中的 pdf 查看器也非常有用。这个作为轻量阅读管理已经非常够用了，相信很多人已经在用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110931115.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Streamlit 多页面应用设计指南：构建模块化数据分析平台</title>
    <link href="/2024/07/10/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/Streamlit%20%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"/>
    <url>/2024/07/10/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/Streamlit%20%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%EF%BC%9A%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9D%97%E5%8C%96%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发数据分析网页应用时，我们常常面临一个难题：如何在一个项目中优雅地管理多个子应用，同时保证代码的可读性与维护性。单一的长文件不仅难以管理，而且在IDE中操作时容易出现性能问题。<br>通过Streamlit库，能够实现快速搭建模块化的数据分析应用，以应对复杂的数据分析需求。</p><h2 id="困扰与需求"><a href="#困扰与需求" class="headerlink" title="困扰与需求"></a>困扰与需求</h2><p>在制作数据分析网页的过程中，我曾遇到以下困扰：</p><ul><li><strong>页面限制与逻辑关联</strong>：为了提高用户体验，我们需要将功能相关的部分组织在一起，形成逻辑清晰的多个页面。</li><li><strong>代码管理难题</strong>：将所有功能塞入一个文件会导致代码冗长，降低开发效率和代码质量。</li><li><strong>IDE性能问题</strong>：大型文件在VSCode等编辑器中加载和代码分析时，可能会遭遇卡顿问题。<br>基于以上困扰，我们的目标是：</li></ul><ol><li><strong>实现多应用展示</strong>：利用Streamlit构建具有多个界面的网页应用，每个界面专注于不同的数据分析任务。</li><li><strong>子应用独立开发</strong>：确保每个子应用的代码逻辑清晰，独立于其他应用，便于开发和后续维护。</li><li><strong>算法与框架分离</strong>：将算法实现和框架结构分开存储，以促进代码的复用和扩展性。</li></ol><h2 id="设计与实施策略"><a href="#设计与实施策略" class="headerlink" title="设计与实施策略"></a>设计与实施策略</h2><p>为了达成上述目标，我们可以采取以下设计策略：</p><h3 id="模块化编码"><a href="#模块化编码" class="headerlink" title="模块化编码"></a>模块化编码</h3><ul><li><strong>建立子应用模块</strong>：为每个子应用创建独立的<code>.py</code>文件，如<code>weather_city.py</code>和<code>weather_country.py</code>，每个文件专注于一个特定的分析任务。</li><li><strong>定义<code>app()</code>函数</strong>：在每个子应用模块中，定义一个<code>app()</code>函数，该函数封装了整个子应用的逻辑流程和Streamlit界面元素。</li></ul><h3 id="构建页面路由"><a href="#构建页面路由" class="headerlink" title="构建页面路由"></a>构建页面路由</h3><ul><li><strong>使用字典映射</strong>：创建一个字典<code>PAGES</code>，其键是页面名称，值是对应子应用模块的引用。</li><li><strong>实现页面选择</strong>：在主应用文件中，使用Streamlit的<code>sidebar</code>和<code>selectbox</code>组件，让用户选择要查看的页面。</li></ul><h3 id="分离算法与框架"><a href="#分离算法与框架" class="headerlink" title="分离算法与框架"></a>分离算法与框架</h3><ul><li><strong>算法与业务逻辑分离</strong>：将复杂的算法和数据处理逻辑封装在单独的模块或类中，与Streamlit的UI逻辑解耦。</li><li><strong>框架结构清晰</strong>：保持主应用文件简洁，仅负责页面路由和基本的布局设置，具体功能实现在子应用模块中。</li></ul><h3 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407101700103.png" alt="image.png"><br>框架包括一个主程序和很多子程序，子程序用__init__.py 作为一个包，让主程序能够很好的调用。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="mian-weathers"><a href="#mian-weathers" class="headerlink" title="mian_weathers"></a>mian_weathers</h3><p>主程序, 这里用的下拉框来选择，也可以用 radio 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">from</span> pages <span class="hljs-keyword">import</span> weather_city, weather_contry<br><span class="hljs-comment"># 创建一个字典来映射页面标题到页面函数</span><br>PAGES = &#123;<br>    <span class="hljs-string">&quot;公共雨量站&quot;</span>: weather_city,<br>    <span class="hljs-string">&quot;区内气象站&quot;</span>: weather_contry,<br>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st.sidebar.title(<span class="hljs-string">&#x27;导航&#x27;</span>) <br>    selected_page = st.sidebar.selectbox(<span class="hljs-string">&quot;选择页面&quot;</span>, <span class="hljs-built_in">list</span>(PAGES.keys()))<br>    <span class="hljs-comment"># 根据用户选择的页面调用相应的函数</span><br>    page = PAGES[selected_page]  <br>    page.app() <br></code></pre></td></tr></table></figure><h3 id="weather-contry"><a href="#weather-contry" class="headerlink" title="weather_contry"></a>weather_contry</h3><p>相当于 page 1，注意子程序所在的 pages 文件夹需要有__init__.py 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pages/weather_contry.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>():<br>    st.title(<span class="hljs-string">&#x27;区内气象站&#x27;</span>)<br>    <span class="hljs-comment"># 页面的具体内容</span><br>    st.header(<span class="hljs-string">&#x27;这是页面2的内容&#x27;</span>)<br>    st.text(<span class="hljs-string">&#x27;这是页面2的示例文本。&#x27;</span>)<br>    st.checkbox(<span class="hljs-string">&#x27;这是一个复选框&#x27;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app()<br></code></pre></td></tr></table></figure><h3 id="weather-city"><a href="#weather-city" class="headerlink" title="weather_city"></a>weather_city</h3><p>相当于 page 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pages/weather_city.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>():<br>    st.title(<span class="hljs-string">&#x27;公共雨量站&#x27;</span>)<br>    <span class="hljs-comment"># 页面的具体内容</span><br>    st.header(<span class="hljs-string">&#x27;这是页面1的内容&#x27;</span>)<br>    st.text(<span class="hljs-string">&#x27;这是一个示例文本，用于演示页面1的功能。&#x27;</span>)<br>    st.button(<span class="hljs-string">&#x27;点击我！&#x27;</span>)     <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app()<br></code></pre></td></tr></table></figure><p>注意子程序所在的 pages 文件夹需要有__init__. Py 文件，让所有的子程序被视为一个包，这样主程序才能 import。该文件可以为空，也可以增加一些属性。示例如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">This is the package documentation string.</span><br><span class="hljs-string">It describes what the package does and how to use it.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>__author__ = <span class="hljs-string">&quot;Your Name&quot;</span><br>__version__ = <span class="hljs-string">&quot;1.0&quot;</span><br></code></pre></td></tr></table></figure><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>运行结果如下。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407101711871.png" alt="image.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过采用模块化的设计思路，我们可以有效地管理和扩展Streamlit应用，使其既能满足复杂的数据分析需求，又能保持代码的整洁与高效。这种策略不仅提升了开发体验，还为未来的功能迭代奠定了坚实的基础。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">wallflowers (maoyu92.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生态环境</tag>
      
      <tag>数据分析</tag>
      
      <tag>streamlit</tag>
      
      <tag>数据可视化</tag>
      
      <tag>工作总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Streamlit 多页面应用设计指南：构建模块化数据分析平台</title>
    <link href="/2024/07/10/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/07/10/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发数据分析网页应用时，我们常常面临一个难题：如何在一个项目中优雅地管理多个子应用，同时保证代码的可读性与维护性。单一的长文件不仅难以管理，而且在IDE中操作时容易出现性能问题。<br>通过Streamlit库，能够实现快速搭建模块化的数据分析应用，以应对复杂的数据分析需求。</p><h2 id="困扰与需求"><a href="#困扰与需求" class="headerlink" title="困扰与需求"></a>困扰与需求</h2><p>在制作数据分析网页的过程中，我曾遇到以下困扰：</p><ul><li><strong>页面限制与逻辑关联</strong>：为了提高用户体验，我们需要将功能相关的部分组织在一起，形成逻辑清晰的多个页面。</li><li><strong>代码管理难题</strong>：将所有功能塞入一个文件会导致代码冗长，降低开发效率和代码质量。</li><li><strong>IDE性能问题</strong>：大型文件在VSCode等编辑器中加载和代码分析时，可能会遭遇卡顿问题。<br>基于以上困扰，我们的目标是：</li></ul><ol><li><strong>实现多应用展示</strong>：利用Streamlit构建具有多个界面的网页应用，每个界面专注于不同的数据分析任务。</li><li><strong>子应用独立开发</strong>：确保每个子应用的代码逻辑清晰，独立于其他应用，便于开发和后续维护。</li><li><strong>算法与框架分离</strong>：将算法实现和框架结构分开存储，以促进代码的复用和扩展性。</li></ol><h2 id="设计与实施策略"><a href="#设计与实施策略" class="headerlink" title="设计与实施策略"></a>设计与实施策略</h2><p>为了达成上述目标，我们可以采取以下设计策略：</p><h3 id="模块化编码"><a href="#模块化编码" class="headerlink" title="模块化编码"></a>模块化编码</h3><ul><li><strong>建立子应用模块</strong>：为每个子应用创建独立的<code>.py</code>文件，如<code>weather_city.py</code>和<code>weather_country.py</code>，每个文件专注于一个特定的分析任务。</li><li><strong>定义<code>app()</code>函数</strong>：在每个子应用模块中，定义一个<code>app()</code>函数，该函数封装了整个子应用的逻辑流程和Streamlit界面元素。</li></ul><h3 id="构建页面路由"><a href="#构建页面路由" class="headerlink" title="构建页面路由"></a>构建页面路由</h3><ul><li><strong>使用字典映射</strong>：创建一个字典<code>PAGES</code>，其键是页面名称，值是对应子应用模块的引用。</li><li><strong>实现页面选择</strong>：在主应用文件中，使用Streamlit的<code>sidebar</code>和<code>selectbox</code>组件，让用户选择要查看的页面。</li></ul><h3 id="分离算法与框架"><a href="#分离算法与框架" class="headerlink" title="分离算法与框架"></a>分离算法与框架</h3><ul><li><strong>算法与业务逻辑分离</strong>：将复杂的算法和数据处理逻辑封装在单独的模块或类中，与Streamlit的UI逻辑解耦。</li><li><strong>框架结构清晰</strong>：保持主应用文件简洁，仅负责页面路由和基本的布局设置，具体功能实现在子应用模块中。</li></ul><h3 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407101700103.png" alt="image.png"><br>框架包括一个主程序和很多子程序，子程序用__init__.py 作为一个包，让主程序能够很好的调用。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="mian-weathers"><a href="#mian-weathers" class="headerlink" title="mian_weathers"></a>mian_weathers</h3><p>主程序, 这里用的下拉框来选择，也可以用 radio 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">from</span> pages <span class="hljs-keyword">import</span> weather_city, weather_contry<br><span class="hljs-comment"># 创建一个字典来映射页面标题到页面函数</span><br>PAGES = &#123;<br>    <span class="hljs-string">&quot;公共雨量站&quot;</span>: weather_city,<br>    <span class="hljs-string">&quot;区内气象站&quot;</span>: weather_contry,<br>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st.sidebar.title(<span class="hljs-string">&#x27;导航&#x27;</span>) <br>    selected_page = st.sidebar.selectbox(<span class="hljs-string">&quot;选择页面&quot;</span>, <span class="hljs-built_in">list</span>(PAGES.keys()))<br>    <span class="hljs-comment"># 根据用户选择的页面调用相应的函数</span><br>    page = PAGES[selected_page]  <br>    page.app() <br></code></pre></td></tr></table></figure><h3 id="weather-contry"><a href="#weather-contry" class="headerlink" title="weather_contry"></a>weather_contry</h3><p>相当于 page 1，注意子程序所在的 pages 文件夹需要有__init__.py 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pages/weather_contry.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>():<br>    st.title(<span class="hljs-string">&#x27;区内气象站&#x27;</span>)<br>    <span class="hljs-comment"># 页面的具体内容</span><br>    st.header(<span class="hljs-string">&#x27;这是页面2的内容&#x27;</span>)<br>    st.text(<span class="hljs-string">&#x27;这是页面2的示例文本。&#x27;</span>)<br>    st.checkbox(<span class="hljs-string">&#x27;这是一个复选框&#x27;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app()<br></code></pre></td></tr></table></figure><h3 id="weather-city"><a href="#weather-city" class="headerlink" title="weather_city"></a>weather_city</h3><p>相当于 page 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pages/weather_city.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>():<br>    st.title(<span class="hljs-string">&#x27;公共雨量站&#x27;</span>)<br>    <span class="hljs-comment"># 页面的具体内容</span><br>    st.header(<span class="hljs-string">&#x27;这是页面1的内容&#x27;</span>)<br>    st.text(<span class="hljs-string">&#x27;这是一个示例文本，用于演示页面1的功能。&#x27;</span>)<br>    st.button(<span class="hljs-string">&#x27;点击我！&#x27;</span>)     <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app()<br></code></pre></td></tr></table></figure><p>注意子程序所在的 pages 文件夹需要有__init__. Py 文件，让所有的子程序被视为一个包，这样主程序才能 import。该文件可以为空，也可以增加一些属性。示例如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">This is the package documentation string.</span><br><span class="hljs-string">It describes what the package does and how to use it.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>__author__ = <span class="hljs-string">&quot;Your Name&quot;</span><br>__version__ = <span class="hljs-string">&quot;1.0&quot;</span><br></code></pre></td></tr></table></figure><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>运行结果如下。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407101711871.png" alt="image.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过采用模块化的设计思路，我们可以有效地管理和扩展Streamlit应用，使其既能满足复杂的数据分析需求，又能保持代码的整洁与高效。这种策略不仅提升了开发体验，还为未来的功能迭代奠定了坚实的基础。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">wallflowers (maoyu92.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生态环境</tag>
      
      <tag>数据分析</tag>
      
      <tag>streamlit</tag>
      
      <tag>数据可视化</tag>
      
      <tag>工作总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSTM水质预测模型实践</title>
    <link href="/2024/07/03/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/LSTM%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/07/03/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/LSTM%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p>随着水质自动站的普及，监测频次越来越高，自动监测越来越准确。<br>水质站点增多，连续的水质监测数据，给水质预测提供更多的训练基础。<br>长短时记忆网络(LSTM)适用于多变量、连续、自相关的数据预测。<br>人工神经网络模型特点为的非线性映射，是广泛应用的水质预测方法。  </p><h2 id="1-长短时记忆网络-LSTM-介绍"><a href="#1-长短时记忆网络-LSTM-介绍" class="headerlink" title="1.长短时记忆网络(LSTM)介绍"></a>1.长短时记忆网络(LSTM)介绍</h2><h3 id="1-1起源"><a href="#1-1起源" class="headerlink" title="1.1起源"></a>1.1起源</h3><p>1997年，Hochreiter等提出了长短时记忆网络(LSTM)，作为深度学习的一种，LSTM既考虑了多元变量间的非线性映射关系，又可以解决传统人工神经网络不能解决的时间序列长期依赖问题，应用场景包括：金融交易、交通预测、机器翻译、水质预测等。</p><h3 id="1-2原理"><a href="#1-2原理" class="headerlink" title="1.2原理"></a>1.2原理</h3><p>长短时记忆网络(LSTM)是在循环神经网络(ＲNN）的基础上改进而来。<br>循环神经网络(ＲNN)作为深度学习方法的一种，其主要用途是对序列数据处理。ＲNN具有自连接隐层，其t时刻隐层状态依靠t－1时刻隐层状态进行更新，因此能够解决时间序列长期依赖的问题。ＲNN理论上可以进行非线性时间序列的有效处理，但实际对较长时间序列进行建模应用中，存在梯度消失及梯度爆炸的问题。<br>LSTM是ＲNN的一种变体，与ＲNN一样，LSTM隐藏层具有随时间序列的重复节点。LSTM节点相较ＲNN更为复杂，它将ＲNN中隐含层中的神经元替换为记忆体，以此实现序列信息的保留与长期记忆。<br>一个标准的LSTM记忆体见图1。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663652672734-10851708-7675-40c3-80f4-0abab324b2c2.png#averageHue=%23efefef&clientId=ufe0eeb19-9d7f-4&from=paste&height=504&id=u21eaafa6&originHeight=504&originWidth=857&originalType=binary&ratio=1&rotation=0&showTitle=true&size=69788&status=done&style=none&taskId=u80d6d931-8107-43cd-9531-08bd4184918&title=%E5%9B%BE1%20LSTM%20%E8%AE%B0%E5%BF%86%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE&width=857" alt="图1 LSTM 记忆体示意图" title="图1 LSTM 记忆体示意图"><br>图 1 中，C 为 LSTM 记忆体的细胞状态，h 为节点的隐藏层状态。每个记忆体包含一到多个记忆细胞和 3 种“门”，LSTM 通过记忆细胞进行细胞状态信息存储，门结构负责细胞状态的更新与保持，3 种 “门”包括“遗忘门”“输入门”和“输出门”。“遗忘门”控制历史信息对当前细胞状态的影响。$f_t$ 决定了上一时刻细胞状态 $C_{t -1}$ 的通过程度。<br>$$f_t&#x3D;σ(w_f[h_{t-1},x_i]+bi)\tag{01}$$<br>$C_{t -1}$ 为t － 1 时刻细胞状态；ht － 1为t － 1 时刻隐藏层状态; σ 为sigmoid 激活函数; wf 为输入循环权重; Xt 为当前时刻节点的输入值；bf 为偏置项。“输入门”决定了进入记忆细胞的是哪些信息，“遗忘门”与“输入门”结合可以实现细胞状态Ct 的更新。    </p><p>  $$i_t&#x3D;σ(w_i[h_{t-1},x_i]+b_i)\tag{02}$$</p><p>$$C_t^‘&#x3D;Tanh(w_C[h_{t-1},x_i]+b_C)\tag{03}$$<br>$$C_t&#x3D;f_iC_{t-1}+i_tC_t^‘\tag{04}$$<br>式中it 为输入门向量值; C’t为新信息; Ct 为t 时刻，细胞状态; bi、bC 为偏置项; wC 为输入权重。<br>“输出门”控制细胞状态值的输出，用Tanh 激活函数处理细胞状态后，与记忆单元状态值相乘得到输出信息。<br>$$σ_t&#x3D;σ(w_o[h_{t-1},x_t]+b_o)\tag{05}$$<br>$$h_t&#x3D;o_t×Tanh(C_t)\tag{06}$$<br>式中 $h_t$ 为t 时刻隐藏层状态; $w_o$ 为输入权重; $o_t$ 为输出值; $b_o$ 为偏置项。<br>由上式可以看出，LSTM 节点通过门结构对细胞状态上的信息进行线性修改，从而保证在时间序列变长的情况下，依然能够保持时间相关性不会衰减。  </p><h2 id="2-算法流程及评价指标"><a href="#2-算法流程及评价指标" class="headerlink" title="2.算法流程及评价指标"></a>2.算法流程及评价指标</h2><h3 id="2-1-算法流程"><a href="#2-1-算法流程" class="headerlink" title="2.1 算法流程"></a>2.1 算法流程</h3><p>模型包括2个部分，分别为模型预处理与模型训练与评价。  </p><h4 id="2-1-1-数据预处理"><a href="#2-1-1-数据预处理" class="headerlink" title="2.1.1 数据预处理"></a>2.1.1 数据预处理</h4><p>数据预处理分为引入前处理及引入后处理。  </p><h5 id="引入前处理"><a href="#引入前处理" class="headerlink" title="引入前处理"></a>引入前处理</h5><p>引入前使用sql语句进行预处理，主要是去除0值、空值、异常值。这里异常值判断依据基于设备上下限、及经验。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span><br>            <span class="hljs-keyword">CASE</span> device_id<br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;87d39a3c&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点D&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;2ab9a08e&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点C&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;17b96c2b&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点B&#x27;</span><br>             <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;e83005a1&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点A&#x27;</span><br>                       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;device_name&#x27;</span> ,<br>                       data_time <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;data_time&#x27;</span>,<br>                       <span class="hljs-keyword">CASE</span> factor_code<br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01003-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;浊度&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w21003-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;氨氮&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01010-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;水温&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01014-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;电导率&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01019-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;高指&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01001-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;PH&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w21011-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;总磷&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01009-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;溶解氧&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w21001-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;总氮&#x27;</span><br>                     <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;fator_code&#x27;</span>,<br>                       <span class="hljs-keyword">value</span> <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;value&#x27;</span><br>                      <span class="hljs-keyword">FROM</span> iot_devices_detail<br>                      <span class="hljs-keyword">where</span> device_id <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;87d39a3c&#x27;</span>,<span class="hljs-string">&#x27;2ab9a08e&#x27;</span>,<span class="hljs-string">&#x27;17b96c2b&#x27;</span>,<span class="hljs-string">&#x27;e83005a1&#x27;</span>)<br>                      <span class="hljs-keyword">and</span> data_time <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2021-01-01 00:00:00&#x27;</span><br>                      <span class="hljs-keyword">and</span> factor_code <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;w21003-Avg&#x27;</span>,<span class="hljs-string">&#x27;w21011-Avg&#x27;</span>,<span class="hljs-string">&#x27;w01019-Avg&#x27;</span>)<br>                      <span class="hljs-keyword">and</span> frequency<span class="hljs-operator">=</span><span class="hljs-string">&#x27;h4&#x27;</span><br>                      <span class="hljs-keyword">and</span> <span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br>                       <span class="hljs-keyword">AND</span> <span class="hljs-keyword">value</span>  <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>                       <span class="hljs-keyword">and</span>  flag<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span><br>                       <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> data_time,factor_code,device_id<br>                       <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> device_id,factor_code) d<br>                       <span class="hljs-keyword">WHERE</span><br>                         d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;高指&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span><br>                        <span class="hljs-keyword">or</span>  d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;总磷&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1.5</span><br>                        <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;氨氮&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">150</span><br>                        <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;浊度&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4000</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;水温&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">60</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;电导率&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2000</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;PH&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">14</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;溶解氧&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;总氮&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>py引入可使用MySQL语句<br>其中sql为上面的代码，注意去掉换行符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn_sql</span>(<span class="hljs-params">sql</span>):<br><br>    conn = pymysql.connect(host=<span class="hljs-string">&quot;&quot;</span>,<br>                   port=<span class="hljs-number">3306</span>,<br>                   user=<span class="hljs-string">&quot;&quot;</span>,<br>                   password=<span class="hljs-string">&quot;&quot;</span>,<br>                   db=<span class="hljs-string">&quot;&quot;</span>,<br>                   charset=<span class="hljs-string">&quot;utf8&quot;</span>)<br>    sql = sql<br><br>    read_sql = pd.read_sql(sql, conn)<br><br>    <span class="hljs-keyword">return</span> read_sql<br><span class="hljs-comment"># read_sql=conn_sql()</span><br><span class="hljs-comment"># 定义链接数据库 </span><br>df = conn_sql(sql)<br></code></pre></td></tr></table></figure><h5 id="引入后处理"><a href="#引入后处理" class="headerlink" title="引入后处理"></a>引入后处理</h5><p>py数据处理内容为空值补全，补全方法为生成连续一小时时间序列index，数据拼接，数据线性插值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dataprocess_en</span>(<span class="hljs-params">df, s, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    df:DataFrame时间序列数据;</span><br><span class="hljs-string">    s:device_name</span><br><span class="hljs-string">    y:fator_code</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    aidunqiao = df.loc[df[<span class="hljs-string">&quot;device_name&quot;</span>] == s, :]<br>    ai_cod = aidunqiao.loc[df[<span class="hljs-string">&quot;fator_code&quot;</span>] == y, :]<br>    ai_cod_mn = ai_cod.loc[:, [<span class="hljs-string">&quot;data_time&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>]]<br>    baseline = ai_cod.loc[:, [<span class="hljs-string">&quot;data_time&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>]]<br><br>    ai_cod_mn.set_index(<span class="hljs-string">&quot;data_time&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    interp_cod_mn = ai_cod_mn[<span class="hljs-string">&quot;value&quot;</span>].interpolate()<br>    ai_cod_mn[<span class="hljs-string">&quot;value_2&quot;</span>] = interp_cod_mn<br>    starttime = baseline.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    rows = baseline.shape[<span class="hljs-number">0</span>]<br>    endtime = baseline.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br>    year_month_day = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<br>        <span class="hljs-string">&quot;%Y%m%d%h%m%s&quot;</span><br>    )<br>    a_ser = pd.DataFrame(&#123;<span class="hljs-string">&quot;data_time&quot;</span>: year_month_day&#125;)<br>    a_ser.set_index(<span class="hljs-string">&quot;data_time&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df = pd.concat([a_ser, ai_cod_mn], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&quot;outer&quot;</span>)<br>    df = df.reset_index(drop=<span class="hljs-literal">False</span>)<br>    df[<span class="hljs-string">&quot;data_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;data_time&quot;</span>])<br>    df1 = df.drop_duplicates(subset=<span class="hljs-string">&quot;data_time&quot;</span>, keep=<span class="hljs-string">&quot;last&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2 = df1.sort_values(by=<span class="hljs-string">&quot;data_time&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2[<span class="hljs-string">&quot;value_2&quot;</span>] = df2[<span class="hljs-string">&quot;value&quot;</span>].interpolate()<br>    df2.drop(columns=<span class="hljs-string">&quot;value&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.set_index(<span class="hljs-string">&quot;data_time&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.columns = [s]<br><br>    <span class="hljs-keyword">return</span> df2<br></code></pre></td></tr></table></figure><p>数据输出结果为，指定站点，制定因子的连续一小时监测结果。<br>引入数据后根据dataprocess_en，计算并拼接为最终预测基础数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">station = df[<span class="hljs-string">&quot;device_name&quot;</span>].unique()<br>factors = df[<span class="hljs-string">&quot;fator_code&quot;</span>].unique()<br>dfn= pd.DataFrame()<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(factors)):<br>    dfn= pd.DataFrame()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(station)):<br>        <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;df_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,j)] = data_process.dataprocess_en(df,station[i],factors[j])<br>        <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;dm&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(j)] = pd.concat([dfn, <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;df_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,j)]],axis=<span class="hljs-number">1</span>)<br>        dfn=<span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;dm&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(j)]<br></code></pre></td></tr></table></figure><p>以上代码将输出dm0，dm1，dm2，不同因子的预测数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将需要预测的数据放在首列</span><br>pred_col= [<span class="hljs-string">&#x27;站点A&#x27;</span>]<br>all_cols = dm0.columns.values.tolist()<br>new_cols = pred_col + all_cols<br>new_cols = pd.Series(pred_col + all_cols).drop_duplicates()<br></code></pre></td></tr></table></figure><p>当然也可以用比较直接的方式拼接数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">yx =<span class="hljs-string">&quot;站点B&quot;</span><br>fh =<span class="hljs-string">&quot;站点C&quot;</span><br>bl =<span class="hljs-string">&quot;站点D&quot;</span><br>cb = <span class="hljs-string">&quot;站点A&quot;</span><br>cod =<span class="hljs-string">&quot;高指&quot;</span><br>tp =<span class="hljs-string">&quot;总磷&quot;</span><br>nh3 =<span class="hljs-string">&quot;氨氮&quot;</span><br>df_cb_tp  =data_process.dataprocess_en(df,cb,tp)<br>df_yx_tp  =data_process.dataprocess_en(df,yx,tp)<br>df_fh_tp  =data_process.dataprocess_en(df,fh,tp)<br>df_bl_tp  =data_process.dataprocess_en(df,bl,tp)<br>df2 = pd.concat([df_cb_tp ,df_yx_tp,df_fh_tp,df_bl_tp],axis=<span class="hljs-number">1</span>)<br>df2=df2[-<span class="hljs-number">3000</span>:] <span class="hljs-comment"># 取近3000个数据，保证运算速度和数据的更新程度</span><br><span class="hljs-comment"># df2=df2[::4] 可以取逐4小时值</span><br></code></pre></td></tr></table></figure><p>以上数据准备结束，总磷预测数据集示例如下，第一列站点A为预测因变量。data_time为index</p><table><thead><tr><th>data_time（index）</th><th>站点A</th><th>站点B</th><th>站点C</th><th>站点D</th></tr></thead><tbody><tr><td>2022-05-17 05:00:00</td><td>0.1955</td><td>0.250125</td><td>0.24355</td><td>0.247800</td></tr><tr><td>2022-05-17 06:00:00</td><td>0.1950</td><td>0.247950</td><td>0.24340</td><td>0.243100</td></tr><tr><td>2022-05-17 07:00:00</td><td>0.1945</td><td>0.245775</td><td>0.24325</td><td>0.238400</td></tr><tr><td>2022-05-17 08:00:00</td><td>0.1940</td><td>0.243600</td><td>0.24310</td><td>0.233700</td></tr><tr><td>2022-05-17 09:00:00</td><td>0.1885</td><td>0.240850</td><td>0.24290</td><td>0.230225</td></tr></tbody></table><h4 id="2-1-2-模型搭建与训练"><a href="#2-1-2-模型搭建与训练" class="headerlink" title="2.1.2 模型搭建与训练"></a>2.1.2 模型搭建与训练</h4><p>模型框架为<br>训练阶段 预测站点窗口滑动，<br>从结构示例图看，若样本窗口数量为30，样本列数（含预测站点）为n，则框中红点数据为预测数据，其余数据为训练因变量，通过模型建立非线性关系。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663663432052-55b1e6db-d4ec-4bd9-8631-b2d7b2199bea.png#averageHue=%23f6f3f0&clientId=ufe0eeb19-9d7f-4&from=paste&height=551&id=uc3d05be0&originHeight=551&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40481&status=done&style=none&taskId=ucec855ed-b6bf-4bdb-a80a-acedeb93734&title=&width=497" alt="image.png"><br>为了实现预测效果，采用滑动时间滑动技术，生成训练基础数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663663771478-e1661a14-bcac-41f6-a348-90954f4a7142.png#averageHue=%23f7f2f0&clientId=ufe0eeb19-9d7f-4&from=paste&height=626&id=u0a432b18&originHeight=626&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54023&status=done&style=none&taskId=uf5c4e634-8b83-4f7e-ad9c-c32ddc162a7&title=&width=960" alt="image.png"></p><p>本次模型搭建采用tensorflower框架，面向对象编程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入相关包</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Dense, LSTM, Dropout<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br><span class="hljs-keyword">from</span> tensorflow.keras.wrappers.scikit_learn <span class="hljs-keyword">import</span> KerasRegressor<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score<br><br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>] = [<span class="hljs-string">&quot;Simhei&quot;</span>]  <span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>] = <span class="hljs-literal">False</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date, datetime, timedelta<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><br><span class="hljs-comment"># 训练模型，使用 girdsearchCV 进行参数调整以找到基础模型。</span><br></code></pre></td></tr></table></figure><p>定义本体，主要参数包括，预测数据集，预测时长，预测窗口数，预测步长<br>预测时间和预测窗口数最好一致，<br>预测数据集可为多参数，第一列为预测参数，<br>预测步长可以理解为逐小时，还是逐4小时，默认逐小时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSTMTimePredictor</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, df, shift_n=<span class="hljs-number">30</span>, test_ratio=<span class="hljs-number">0.2</span>, n_past=<span class="hljs-number">30</span>,p_step=<span class="hljs-number">1</span> ,optimizer=<span class="hljs-string">&quot;adam&quot;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        df:DataFrame时间序列数据;</span><br><span class="hljs-string">        test_ratio:测试比率</span><br><span class="hljs-string">        n_past:预测的窗口数;</span><br><span class="hljs-string">        optimizer:优化器;</span><br><span class="hljs-string">        n_features:特征数;</span><br><span class="hljs-string">        feature_names:特征名称;</span><br><span class="hljs-string">        shirt_n:预测时长</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.df = df<br>        self.test_ratio = test_ratio<br>        self.n_past = n_past<br>        self.shift_n = shift_n<br>        self.optimizer = optimizer<br>        self.n_features = self.df.shape[<span class="hljs-number">1</span>]<br>        self.feature_names = self.df.columns<br>        self.p_step = p_step <br></code></pre></td></tr></table></figure><p>时间滑动生成新的数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">shift_date_new</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    时间滑动</span><br><span class="hljs-string">    下一段滑动函数 n 为移动参数，即为预测长度</span><br><span class="hljs-string">    df4都有的数据集用于训练和测试</span><br><span class="hljs-string">    df9向后预测的数据需要的未知数据集;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df1 = self.df<br>    n = self.shift_n<br>    bl_fh = df1.iloc[:, <span class="hljs-number">1</span>: self.n_features]<br>    cb = df1.iloc[:, <span class="hljs-number">0</span>]<br>    cb.to_frame<br>    df2 = cb.shift(periods=-n, axis=<span class="hljs-number">0</span>)<br>    df3 = pd.concat([df2, bl_fh], join=<span class="hljs-string">&quot;outer&quot;</span>, axis=<span class="hljs-number">1</span>)<br>    df9 = df3[-n:]<br>    df4 = df3[:-n]<br>    <span class="hljs-keyword">return</span> df4, df9<br></code></pre></td></tr></table></figure><p>数据集划分，归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_train_test_split</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    训练测试划分;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df = self.shift_date_new()[<span class="hljs-number">0</span>]<br>    test_split = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">len</span>(self.df) * self.test_ratio)  <span class="hljs-comment"># 计算测试集中的样本数量</span><br>    df_training = df[:-test_split]<br>    df_testing = df[-test_split:]<br>    <span class="hljs-comment"># 进行最小最大归一化</span><br>    scaler = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    df_training_scaled = scaler.fit_transform(df_training)<br>    df_testing_scaled = scaler.transform(df_testing)<br><br>    <span class="hljs-comment"># 获取训练集和测试集的样本数量</span><br>    self.train_length = <span class="hljs-built_in">len</span>(df_training_scaled)<br>    self.test_length = <span class="hljs-built_in">len</span>(df_testing_scaled)<br><br>    <span class="hljs-comment"># 获取归一化后的训练样本和测试样本</span><br>    self.scaler = scaler<br>    <span class="hljs-keyword">return</span> df_training_scaled, df_testing_scaled<br><br></code></pre></td></tr></table></figure><p>区分自变量，因变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">createXY</span>(<span class="hljs-params">self, datasets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    生成用于LSTM输入的多元数据,例如时间窗口n_past=30,则一个样本的维度为(30,5)</span><br><span class="hljs-string">    30代表时间窗口,5代表特征数量</span><br><span class="hljs-string">    将数据分为x y</span><br><span class="hljs-string">    n_past 我们在预测下一个目标值时将在过去查看的步骤数 粒度</span><br><span class="hljs-string">    n_past使用30,意味着将使用过去的30个值</span><br><span class="hljs-string">    dataX 代表目标预测值dataY前所有因子,包括预测因子30个数据</span><br><span class="hljs-string">    若n_past越小,则预测的平滑度越低,越注重于短期预测,若n_past越大则越注重长期预测</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    dataX = []<br>    dataY = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_past, <span class="hljs-built_in">len</span>(datasets)):<br>        dataX.append(datasets[i - self.n_past : i, <span class="hljs-number">0</span> : datasets.shape[<span class="hljs-number">1</span>]])<br>        dataY.append(datasets[i, <span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> np.array(dataX), np.array(dataY)<br></code></pre></td></tr></table></figure><p>建立模型，并查找最优参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">grid_search</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">    </span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        根据数据训练模型，并查找最优的参数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        df_training_scaled = self._train_test_split()[<span class="hljs-number">0</span>]<br>        df_testing_scaled = self._train_test_split()[<span class="hljs-number">1</span>]<br>        X_train, y_train = self.createXY(df_training_scaled)<br>        X_test, y_test = self.createXY(df_testing_scaled)<br><br>        grid_model = KerasRegressor(<br>            build_fn=self._build_model, verbose=<span class="hljs-number">1</span>, validation_data=(X_test, y_test)<br>        )<br>        parameters = &#123;<br>            <span class="hljs-string">&quot;batch_size&quot;</span>: [<span class="hljs-number">16</span>, <span class="hljs-number">20</span>],<br>            <span class="hljs-string">&quot;epochs&quot;</span>: [<span class="hljs-number">8</span>, <span class="hljs-number">10</span>],<br>            <span class="hljs-comment"># , &quot;Adadelta&quot;            &quot;optimizer&quot;: [&quot;adam&quot;],</span><br>        &#125;<br>        <span class="hljs-comment"># 这里前文设置了optimizer为adam </span><br>        grid_search = GridSearchCV(estimator=grid_model, param_grid=parameters, cv=<span class="hljs-number">2</span>)<br>        grid_search = grid_search.fit(<br>            X_train, y_train, validation_data=(X_test, y_test)<br>        )<br>        self.model = grid_search.best_estimator_.model<br><br></code></pre></td></tr></table></figure><p>至此模型建立。</p><h4 id="2-1-3-模型评价与模型预测"><a href="#2-1-3-模型评价与模型预测" class="headerlink" title="2.1.3 模型评价与模型预测"></a>2.1.3 模型评价与模型预测</h4><p>本次采用4 种方法评价模型精度，分别是MSE、MAE、R2、准确率。<br>测试集模型预测精度评价及绘图代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">self, plot=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    制图及模型评价</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df_testing_scaled = self._train_test_split()[<span class="hljs-number">1</span>]<br>    X_test, y_test = self.createXY(df_testing_scaled)<br>    <span class="hljs-comment"># 预测值</span><br>    prediction = self.model.predict(X_test)<br>    prediction_copy_array = np.repeat(prediction, self.n_features, axis=-<span class="hljs-number">1</span>)<br>    pred = self.scaler.inverse_transform(<br>        np.reshape(prediction_copy_array, (<span class="hljs-built_in">len</span>(prediction), self.n_features))<br>    )[:, <span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 实际值</span><br>    original_copies_array = np.repeat(y_test, self.n_features, axis=-<span class="hljs-number">1</span>)<br>    original = self.scaler.inverse_transform(<br>        np.reshape(original_copies_array, (<span class="hljs-built_in">len</span>(y_test), self.n_features))<br>    )[:, <span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 序号还原</span><br>    df = self.shift_date_new()[<span class="hljs-number">0</span>]<br>    test_split = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">len</span>(self.df) * self.test_ratio)  <span class="hljs-comment"># 计算测试集中的样本数量</span><br>    df_training = df[:-test_split]<br>    df_testing = df[-test_split:]<br>    index1 = df_testing.index<br>    starttime = index1[<span class="hljs-number">30</span>]<br>    delta = timedelta(hours=<span class="hljs-number">30</span>)  <span class="hljs-comment"># 时间序号还原</span><br>    starttime = starttime + delta<br>    starttime = starttime.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br>    endtime = index1[-<span class="hljs-number">1</span>]<br>    endtime = endtime + delta<br>    endtime = endtime.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br>    time_nu = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<br>        <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span><br>    )<br>    time_nu = time_nu[::self.p_step]<br>    original_2 = pd.DataFrame(original)<br>    col_2 = [<span class="hljs-string">&quot;真实值&quot;</span>]<br>    original_2.columns = col_2<br>    original_3 = original_2.set_index(time_nu)<br>    pred_2 = pd.DataFrame(pred)<br>    col_1 = [<span class="hljs-string">&quot;预测值&quot;</span>]<br>    pred_2.columns = col_1<br>    pred_3 = pred_2.set_index(time_nu)<br>    <span class="hljs-keyword">if</span> plot:<br>        plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">6</span>))<br>        plt.plot(original_3, color=<span class="hljs-string">&quot;red&quot;</span>, label=<span class="hljs-string">&quot;真实值&quot;</span>)<br>        plt.plot(pred_3, color=<span class="hljs-string">&quot;blue&quot;</span>, label=<span class="hljs-string">&quot;预测值&quot;</span>)<br>        <span class="hljs-comment"># plt.title(&quot; 站点A氨氮预测&quot;)</span><br>        plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br>        plt.ylabel(<span class="hljs-string">&quot; 预测值&quot;</span>)<br>        plt.locator_params(axis=<span class="hljs-string">&quot;x&quot;</span>, nbins=<span class="hljs-number">10</span>)<br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(time_nu), <span class="hljs-number">48</span>), rotation=<span class="hljs-number">45</span>)  <span class="hljs-comment"># 刻度线显示优化</span><br>        plt.legend()<br>        plt.show()<br>    mae = mean_absolute_error(original, pred)<br>    mse = mean_squared_error(original, pred)<br>    mape = np.mean(np.<span class="hljs-built_in">abs</span>(original - pred) / original)<br>    r2 = r2_score(original, pred)<br>    acc = <span class="hljs-number">1</span> - <span class="hljs-built_in">abs</span>((pred - original) / original)<br>    acc = np.mean(acc)<br>    <span class="hljs-built_in">print</span>(<br>        <span class="hljs-string">&quot;MSE : &#123;&#125;,MAE : &#123;&#125;, MAPE : &#123;&#125;, r2 : &#123;&#125;, 准确率:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>            mse, mae, mape, r2, acc<br>        )<br>    )<br>    <span class="hljs-keyword">return</span> pred<br></code></pre></td></tr></table></figure><p>数据集采用临江河站点A、站点B、站点C、站点D等4个站点，预测站点A高指、氨氮、总磷3个因子。数据范围为2022&#x2F;5&#x2F;19  5:00:00 至 2022&#x2F;9&#x2F;21  4:00:00。共3000个数据。测试集占比0.2。<br>测试集预测评价结果如下：MSE、MAE、R2均表现较好，总磷准确率、MAPE较差，与水质浓度波动大，关系密切，可以通过进一步优化数据清理减少数据波动。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663748742440-449f9585-7da7-4cb7-94b3-abd50057295a.png#averageHue=%23fbf9f9&clientId=u7a4f3748-f2cd-4&from=paste&height=775&id=u86202cc0&originHeight=775&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=true&size=180426&status=done&style=none&taskId=ucbe6b03a-dccc-4fc7-88ef-d7315592a3a&title=%E8%8C%A8%E5%9D%9D%E9%AB%98%E6%8C%87%E6%B5%8B%E8%AF%95%E9%9B%86%E9%A2%84%E6%B5%8B%E5%AF%B9%E6%AF%94&width=1495" alt="站点A高指测试集预测对比" title="站点A高指测试集预测对比"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663748769105-f0cd0097-09a1-4d51-8017-c00e7fa2954f.png#averageHue=%23fbf9f9&clientId=u7a4f3748-f2cd-4&from=paste&height=668&id=uc07496b7&originHeight=668&originWidth=1278&originalType=binary&ratio=1&rotation=0&showTitle=true&size=139917&status=done&style=none&taskId=u55750a39-849c-495c-869a-d9d796f0667&title=%E8%8C%A8%E5%9D%9D%E6%B0%A8%E6%B0%AE%E6%B5%8B%E8%AF%95%E9%9B%86%E9%A2%84%E6%B5%8B%E5%AF%B9%E6%AF%94&width=1278" alt="站点A氨氮测试集预测对比" title="站点A氨氮测试集预测对比"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663748800563-6bd58632-1cd4-4139-b64f-a79ff1e45b3d.png#averageHue=%23fbf9f9&clientId=u7a4f3748-f2cd-4&from=paste&height=684&id=u660ab49f&originHeight=684&originWidth=1293&originalType=binary&ratio=1&rotation=0&showTitle=true&size=122752&status=done&style=none&taskId=u0e9c73da-d000-46c4-95b8-04afcc7a735&title=%E8%8C%A8%E5%9D%9D%E6%80%BB%E7%A3%B7%E6%B5%8B%E8%AF%95%E9%9B%86%E9%A2%84%E6%B5%8B%E5%AF%B9%E6%AF%94&width=1293" alt="站点A总磷测试集预测对比" title="站点A总磷测试集预测对比"></p><table><thead><tr><th>因子</th><th>MSE</th><th>MAE</th><th>MAPE</th><th>r2</th><th>准确率</th></tr></thead><tbody><tr><td>高指</td><td>0.00004273</td><td>0.00521874</td><td>0.037992</td><td>0.968379</td><td>0.962008</td></tr><tr><td>氨氮</td><td>0.01103716</td><td>0.07946250</td><td>0.016475</td><td>0.959818</td><td>0.983525</td></tr><tr><td>总磷</td><td>0.00081064</td><td>0.01672249</td><td>0.698055</td><td>0.947509</td><td>0.301945</td></tr></tbody></table><h5 id="对未来的预测"><a href="#对未来的预测" class="headerlink" title="对未来的预测"></a>对未来的预测</h5><p>模型可以自定义模型预测时长，本次以72小时为例。运行预测评价模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm2 = LSTMTimePredictor(dm2,test_ratio=<span class="hljs-number">0.2</span>,n_past=<span class="hljs-number">72</span>,p_step=<span class="hljs-number">1</span> )<br>lstm2.grid_search()<br>lstm2.evaluate()<br>lstm2.fig_predict()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fig_predict</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    查看数据概览图;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df = self.predict()<br>    plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">6</span>))<br>    plt.plot(df, color=<span class="hljs-string">&quot;red&quot;</span>, label=<span class="hljs-string">&quot;预测值&quot;</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot; 预测值&quot;</span>)<br>    plt.title(<span class="hljs-string">&quot;水质预测&quot;</span>)<br>    plt.locator_params(axis=<span class="hljs-string">&quot;x&quot;</span>, nbins=<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># plt.xticks(range(1,len(time_nu),48),rotation=45) # 刻度线显示优化</span><br>    plt.legend()<br>    plt.show()<br></code></pre></td></tr></table></figure><p>预测结果分别为，整体呈下降趋势<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663750110262-e079044e-bf26-4ddb-afc5-2294ed2c7e34.png#averageHue=%23fcfbfb&clientId=u7a4f3748-f2cd-4&from=paste&height=692&id=u1651b8bc&originHeight=692&originWidth=1517&originalType=binary&ratio=1&rotation=0&showTitle=true&size=64780&status=done&style=none&taskId=u47331cb8-9abd-484c-a939-22e23994822&title=%E6%80%BB%E7%A3%B7%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&width=1517" alt="总磷预测结果" title="总磷预测结果"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663750136399-ca6af9e7-7c7d-48a4-aa17-05441f977fea.png#averageHue=%23fcfbfb&clientId=u7a4f3748-f2cd-4&from=paste&height=674&id=u7c3530d7&originHeight=674&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=true&size=58938&status=done&style=none&taskId=ub5e03c6e-36a6-4d63-aa04-ae31f2f94bd&title=%E9%AB%98%E6%8C%87%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&width=1440" alt="高指预测结果" title="高指预测结果"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663750153213-46506788-4bb8-4d26-83af-9f7662d09818.png#averageHue=%23fcfbfb&clientId=u7a4f3748-f2cd-4&from=paste&height=576&id=uba2f3d8e&originHeight=576&originWidth=1237&originalType=binary&ratio=1&rotation=0&showTitle=true&size=50652&status=done&style=none&taskId=u09e53097-9ce9-475d-bb56-d1e9eb9e240&title=%E6%B0%A8%E6%B0%AE%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&width=1237" alt="氨氮预测结果" title="氨氮预测结果"></p><h2 id="3-应用场景及展望"><a href="#3-应用场景及展望" class="headerlink" title="3 应用场景及展望"></a>3 应用场景及展望</h2><p>LSTM作为成熟的神经网络模型，可以实现多因子，连续时间序列预测，可以应用在有一定连续水质检测数据的平台上，预测结果较准确。因子关联可根据实际情况选择，例如上下游关系，机理关系等。<br>shuju ，与ＲNN一样，LSTM隐藏层具有随时间序列的重复节点。LSTM节点相较ＲNN更<br>为复杂，它将ＲNN中隐含层中的神经元替换为记忆体，以此实现序列信息的保留与长期记忆。TM是ＲNN的一种变体，与ＲNN一样，LSTM隐藏层具有随时间序列的重复节点。LSTM节点相较ＲNN更为复杂，它将ＲNN中隐含层中的神经元替换为记忆体，以此实现序列信息的保留与长期记忆。<br>短的的多连续适用于时记忆网络(LSTM)应用</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如有帮助，请收藏点赞，如需引用转载请注明出处。<br>微信公众号：环境猫 er<br>CSDN：细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">wallflowers (maoyu92.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>生态环境</tag>
      
      <tag>BP神经网络</tag>
      
      <tag>水质模型</tag>
      
      <tag>时间序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锻炼 读书笔记 番外 身体激素及神经递质</title>
    <link href="/2024/07/02/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E7%95%AA%E5%A4%96%20%E8%BA%AB%E4%BD%93%E6%BF%80%E7%B4%A0%E5%8F%8A%E7%A5%9E%E7%BB%8F%E9%80%92%E8%B4%A8/"/>
    <url>/2024/07/02/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E7%95%AA%E5%A4%96%20%E8%BA%AB%E4%BD%93%E6%BF%80%E7%B4%A0%E5%8F%8A%E7%A5%9E%E7%BB%8F%E9%80%92%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>最近在读《锻炼》的时候，对于各种激素很感兴趣，多巴胺、内啡肽、荷尔蒙、肾上腺素、褪黑素、皮质醇、糖化、氧化等等。索性认真梳理下它们是什么，思考当处于心流状态时，人体发生什么样的变化，分泌什么激素？在玩电子游戏时，主要分泌什么激素，为什么会出现沉迷现象？分析食物的糖化与糖化食物对人体的影响，分析人衰老的原因，以及对抗衰老的办法，并从中找到正确生活的方式。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>多巴胺 (Dopamine)</strong><br>多巴胺是一种神经递质，主要在大脑的奖赏中心、运动控制和认知功能中发挥作用。多巴胺的释放与愉悦感和期待感有关，当我们经历令人愉快的事情或者预期会得到奖励时，大脑中的多巴胺水平会升高，这与成瘾行为的形成密切相关。在基底神经节中调节运动，影响学习、记忆和注意力，对于维持精神警觉和决策能力至关重要。还抑制垂体前叶分泌催乳素，对生殖系统的调节有重要作用。<br><strong>内啡肽（Endorphins）</strong><br>内啡肽是大脑分泌的一类内源性物质，属于阿片肽的一种。它们主要作用于大脑中的疼痛调节系统，能够产生镇痛和愉悦感，有时被称作“自然的止痛剂”。运动、大笑、亲密接触等活动可以刺激内啡肽的释放，有助于缓解压力和提升心情。<br><strong>荷尔蒙（Hormones）</strong><br>荷尔蒙是指由内分泌腺或特定细胞合成并分泌到血液中，通过血液循环传递至靶器官或组织，对其产生特定生物学效应的化学信使分子。荷尔蒙在人体内扮演着调节各种生理功能的关键角色，包括生长发育、代谢速率、情绪状态、生殖功能等。<br><strong>皮质醇（Cortisol）</strong><br>皮质醇是一种由肾上腺皮质分泌的甾体激素，主要在应激反应中起关键作用。它能帮助身体应对压力，提高血糖水平，抑制免疫系统反应，并影响脂肪、蛋白质和碳水化合物的代谢。长期高水平的皮质醇与多种健康问题相关，如肥胖、高血压和抑郁等。<br><strong>褪黑素 (Melatonin)</strong><br>褪黑素是由松果体分泌的一种激素，主要与昼夜节律和睡眠周期有关。它的作用一是调节睡眠-觉醒周期：褪黑素的分泌随着一天中的光照条件而变化，夜晚分泌增加，帮助诱导睡眠，早晨分泌减少，促使醒来。二是抗氧化作用：褪黑素具有强大的抗氧化特性，能够清除自由基，保护细胞免受氧化应激的损害。三是免疫调节：褪黑素影响免疫系统的功能，可能在炎症和免疫反应中起到调节作用。<br><strong>肾上腺素 (Adrenaline)</strong><br>肾上腺素是一种由肾上腺髓质分泌的激素，也是神经系统中的神经递质。它在“战斗或逃跑”反应中起关键作用，主要作用包括：<br>心血管效应：肾上腺素增加心率、血压和心肌收缩力，确保身体在紧急情况下获得足够的氧气和能量。<br>代谢效应：它促进肝糖原分解为葡萄糖，增加血糖水平，提供即时能量来源。<br>呼吸效应：肾上腺素扩张呼吸道，增加肺部通气量，以应对紧急情况下的氧气需求。<br>神经效应：提高警觉性，增强注意力和反应速度。<br><strong>糖化（Glycation）</strong><br>糖化是指蛋白质、脂质或核酸等生物分子与糖类（如葡萄糖）非酶促结合的过程，形成糖基化终末产物（AGEs）。这一过程在正常生理条件下缓慢进行，但高血糖状态下会加速，导致蛋白质结构和功能改变，与糖尿病并发症、衰老和某些慢性疾病的发生有关。<br><strong>氧化（Oxidation）</strong><br>氧化是一个广泛的化学反应类型，涉及电子从一个物质（还原剂）向另一个物质（氧化剂）的转移。在生物体内，氧化反应通常发生在细胞呼吸过程中，将食物转化为能量。然而，过量的氧化反应会产生自由基，导致氧化应激，损伤细胞膜、DNA 和蛋白质，与衰老和疾病的发展相关联。</p><hr><h2 id="心流状态下，身体发生什么变化？"><a href="#心流状态下，身体发生什么变化？" class="headerlink" title="心流状态下，身体发生什么变化？"></a>心流状态下，身体发生什么变化？</h2><p>当个体处于心流状态（Flow State）时，这是一种高度专注、投入和享受的体验，通常在从事某项既具挑战性又与个人技能相匹配的活动中出现。<br>在心流状态下，人体经历了一系列生理变化，包括激素分泌的调整，以支持这种高度集中的精神状态。<br>在心流状态下分泌的激素和神经递质包括多巴胺、去甲肾上腺素、皮质醇、血清素、γ-氨基丁酸。<br>多巴胺让人愉悦；去甲肾上腺素让人清醒和专注、警觉、注意力提高；适量皮质醇让人保持能量应对挑战；血清素调节情绪；γ-氨基丁酸让人深度放松并集中注意力。<br>这些生理和神经化学的变化共同作用，使得心流状态成为一种高效和令人愉悦的体验，人们在这种状态下往往能发挥出最佳表现。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407021611293.jpg" alt="愉悦"></p><h2 id="玩电子游戏时，主要分泌什么激素，为什么会沉迷？"><a href="#玩电子游戏时，主要分泌什么激素，为什么会沉迷？" class="headerlink" title="玩电子游戏时，主要分泌什么激素，为什么会沉迷？"></a>玩电子游戏时，主要分泌什么激素，为什么会沉迷？</h2><p>当人类在玩电子游戏时，主要分泌的激素和神经递质包括多巴胺、肾上腺素、去甲肾上腺素，以及在某些情况下产生内啡肽。<br><strong>多巴胺</strong>，多巴胺是与奖励系统紧密相关的神经递质，当玩家在游戏中达成目标、获得成就或是经历刺激时，大脑会释放多巴胺，这会带来愉悦感和满足感。游戏设计往往包含奖励机制，如积分、升级、解锁新内容等，这些都能刺激多巴胺的释放，鼓励玩家持续参与。<br><strong>肾上腺素与去甲肾上腺素</strong>，在紧张刺激的游戏场景中，身体会释放肾上腺素和去甲肾上腺素，这是“战斗或逃跑”反应的一部分。这些激素会增加心率、血压和警觉性，让玩家更加集中注意力，体验到高度的兴奋和刺激。这类反应常见于竞技游戏或需要快速反应的游戏。<br><strong>内啡肽</strong>，在长时间或高强度的游戏后，身体可能会释放内啡肽，这是一种自然的止痛剂，能够产生放松和愉快的感觉，帮助缓解紧张和疲劳。虽然不是所有游戏都会引发内啡肽的大量释放，但在某些情况下，特别是当玩家经历成功或克服困难后，可能会有这种反应。</p><h2 id="多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？"><a href="#多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？" class="headerlink" title="多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？"></a>多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？</h2><p>多巴胺、内啡肽和荷尔蒙在人体内都有其特定的作用和相互关联，尤其是在影响情绪和愉悦感方面。</p><h3 id="多巴胺"><a href="#多巴胺" class="headerlink" title="多巴胺"></a>多巴胺</h3><p>多巴胺是一种神经递质，主要与奖赏系统、动机和欲望相关。当你经历令人愉快的事件，如吃美食、听喜欢的音乐或达到某个目标时，大脑中的多巴胺水平会升高，产生一种即时的快感和满足感。多巴胺还与成瘾行为有关，因为它强化了与奖赏相关的行为模式。</p><h3 id="内啡肽"><a href="#内啡肽" class="headerlink" title="内啡肽"></a>内啡肽</h3><p>内啡肽是一组内源性的肽类物质，它们与阿片受体结合，产生镇痛效果和愉悦感。内啡肽的释放通常与运动、笑、亲密接触或达到某种成就有关。它们带来的愉悦感往往伴随着身体的放松和幸福感觉，与多巴胺不同，内啡肽的快感更倾向于生理上的舒适和放松。在长时间的锻炼，克服困难、或者在心流状态更多分泌的是内啡肽。</p><h3 id="荷尔蒙"><a href="#荷尔蒙" class="headerlink" title="荷尔蒙"></a>荷尔蒙</h3><p>荷尔蒙是一类由内分泌腺分泌的化学信使，它们通过血液运输到全身，调节多种生理过程，包括生长、代谢、情绪和性行为等。有些荷尔蒙，如催产素（Oxytocin）和血清素（Serotonin），也与情感状态和社交行为有关，可以影响人的幸福感和社交连接。</p><h3 id="愉悦感的高低"><a href="#愉悦感的高低" class="headerlink" title="愉悦感的高低"></a>愉悦感的高低</h3><p>多巴胺和内啡肽带来的愉悦感在性质上有所不同，但很难绝对地说哪一个更高或更低，因为这取决于个人的体验和情境。多巴胺的快感往往更加直接和强烈，而内啡肽的快感则更持久且伴有放松感。荷尔蒙如催产素在社会互动和亲密关系中提供了一种深层次的情感连接和安全感，这也是另一种形式的愉悦。<br>例如，多巴胺的高峰可能在短暂的奖励行为中迅速出现，比如收到一条期待已久的短信；而内啡肽的释放则可能在长时间的运动或完成一项艰巨任务后慢慢累积，带来一种成就感和满足感。荷尔蒙的效应则可能贯穿于长期的社会和情感联系中，如亲情、友情和爱情。<br>因此，多巴胺、内啡肽和荷尔蒙在不同的情境下给人们带来的愉悦感是互补的，而不是简单的高低比较。它们共同构成了我们对生活中的快乐和满足感的多维度体验。</p><h2 id="食物的糖化与糖化食物对人体的影响"><a href="#食物的糖化与糖化食物对人体的影响" class="headerlink" title="食物的糖化与糖化食物对人体的影响"></a>食物的糖化与糖化食物对人体的影响</h2><p>食物的糖化以及摄入糖化食物对人体的影响是一个复杂但重要的营养学话题，主要涉及到美拉德反应（Maillard reaction）和糖基化终末产物（Advanced Glycation End products, AGEs）的概念。</p><h3 id="食物的糖化"><a href="#食物的糖化" class="headerlink" title="食物的糖化"></a>食物的糖化</h3><p>在烹饪过程中，尤其是当食物加热至较高温度时（如煎、烤、炸），蛋白质和碳水化合物之间会发生一系列复杂的化学反应，称为美拉德反应。这一过程不仅改变了食物的颜色和风味，还产生了新的化合物，其中一些就是糖基化终末产物（AGEs）。这些 AGEs 在食物中天然存在，但在高温处理下其含量显著增加。</p><h3 id="糖化食物对人体的影响"><a href="#糖化食物对人体的影响" class="headerlink" title="糖化食物对人体的影响"></a>糖化食物对人体的影响</h3><p>摄入富含 AGEs 的食物可能对人体健康产生不利影响，主要表现在以下几个方面：</p><ol><li><strong>炎症反应增强</strong>：AGEs 能够激活体内的炎症途径，促进炎症因子的释放，长期而言，这可能加剧慢性炎症状态，与心血管疾病、糖尿病、肾病等多种慢性疾病的风险增加有关。    </li><li><strong>氧化应激增加</strong>：AGEs 可引发氧化应激，即自由基的产生超过抗氧化防御机制的能力，损害细胞和组织，加速老化过程，并可能促进疾病的发展。    </li><li><strong>胰岛素抵抗和糖尿病风险</strong>：有研究表明，高 AGEs 饮食可能加重胰岛素抵抗，这是 2 型糖尿病的一个关键特征。此外，AGEs 还可能直接损害胰岛β细胞的功能。    </li><li><strong>血管功能受损</strong>：AGEs 与血管内皮细胞上的受体结合后，可导致血管功能障碍，如血管硬化和血流减少，增加心血管疾病的风险。<br>为了减少糖化食物对健康的潜在负面影响，建议采取以下措施：</li></ol><ul><li><strong>选择烹饪方法</strong>：尽量采用低温烹饪方法，如蒸、煮或炖，避免长时间高温烹饪。</li><li><strong>多样化饮食</strong>：均衡饮食，多吃新鲜水果、蔬菜和全谷物，这些食物中 AGEs 含量较低。</li><li><strong>控制糖分摄入</strong>：减少加工食品和含糖饮料的摄入，因为它们往往含有较高的 AGEs。</li><li><strong>适量运动</strong>：定期的身体活动可以帮助改善代谢，减少 AGEs 的积累。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407021606928.jpg"></p><h2 id="人体衰老的原因及抵抗衰老的方法"><a href="#人体衰老的原因及抵抗衰老的方法" class="headerlink" title="人体衰老的原因及抵抗衰老的方法"></a>人体衰老的原因及抵抗衰老的方法</h2><p>从生物学的角度看，人体衰老是一个涉及多个层面的复杂过程，包括遗传、分子、细胞、组织、器官乃至整个系统的退化。衰老的原因可以分为内在因素和外在因素，其中一些是可干预的，而另一些则不是。以下是衰老的生物学原因以及抵抗衰老的策略，特别强调了身体产生的激素和神经递质的角色：</p><h3 id="衰老的生物学原因"><a href="#衰老的生物学原因" class="headerlink" title="衰老的生物学原因"></a>衰老的生物学原因</h3><ol><li><strong>遗传因素</strong>    <ul><li><strong>端粒缩短</strong>：每次细胞分裂，染色体末端的端粒会缩短，最终导致细胞失去复制能力。</li><li><strong>基因突变</strong>：随时间积累的基因突变影响蛋白质功能，导致细胞功能障碍。</li></ul></li><li><strong>分子损伤</strong>    <ul><li><strong>氧化应激</strong>：自由基和其他活性氧物种（ROS）的积累导致DNA、蛋白质和脂质氧化损伤。</li><li><strong>糖化</strong>：糖基化终末产物（AGEs）的形成，影响蛋白质结构和功能。</li></ul></li><li><strong>细胞衰老</strong>    <ul><li><strong>细胞凋亡和自噬减少</strong>：细胞清理受损分子和结构的能力下降。</li><li><strong>干细胞功能下降</strong>：组织修复和再生能力减弱。</li></ul></li><li><strong>激素失衡</strong>    <ul><li><strong>性激素下降</strong>：如雌激素和睾酮水平随年龄下降，影响骨密度、肌肉质量和心血管健康。</li><li><strong>生长激素和IGF-1减少</strong>：影响代谢和组织修复。</li></ul></li><li><strong>神经递质变化</strong>    <ul><li><strong>多巴胺和血清素减少</strong>：影响情绪、认知和运动功能。</li><li><strong>乙酰胆碱减少</strong>：与记忆力和学习能力下降有关。</li></ul></li><li><strong>免疫功能衰退</strong>    <ul><li><strong>慢性炎症</strong>：低度持续的炎症状态加速组织损伤。</li></ul></li></ol><h3 id="可干预的抵抗衰老方法"><a href="#可干预的抵抗衰老方法" class="headerlink" title="可干预的抵抗衰老方法"></a>可干预的抵抗衰老方法</h3><ol><li><strong>生活方式改变</strong>    <ul><li><strong>健康饮食</strong>：富含抗氧化剂的食物，如蓝莓、绿茶、坚果，有助于减少氧化应激。</li><li><strong>规律运动</strong>：增强肌肉和骨骼健康，促进神经生长因子（NGF）和脑源性神经营养因子（BDNF）的分泌，维护大脑健康。</li><li><strong>充足睡眠</strong>：有助于激素平衡和细胞修复。</li></ul></li><li><strong>心理和社交活动</strong>    <ul><li><strong>压力管理</strong>：减少皮质醇水平，避免慢性压力对身体的负面影响。具体方式包括读书、冥想、规律运动等方式可以缓解压力。</li><li><strong>社交互动</strong>：维护神经递质平衡，如增加内啡肽和催产素的水平。</li></ul></li></ol><h3 id="不可干预的因素"><a href="#不可干预的因素" class="headerlink" title="不可干预的因素"></a>不可干预的因素</h3><ul><li><strong>遗传倾向</strong>：个体的遗传背景在很大程度上决定了衰老的速度和方式。</li><li><strong>既往伤害</strong>：过去的疾病、伤害和环境暴露可能留下不可逆的影响。<br>抵抗衰老的关键在于优化可控因素，如生活方式选择和医疗干预，同时适应和管理不可控因素，如遗传和年龄本身。通过综合方法，可以显著提高健康寿命，即在较长的生命中保持较高的健康和功能状态。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407021605394.jpg" alt="规律运动"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> 七步搭建水环境模型--以 SWMM 模型搭建为例</title>
    <link href="/2024/06/28/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E4%B8%83%E6%AD%A5%E6%90%AD%E5%BB%BA%E6%B0%B4%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B--%E4%BB%A5%20SWMM%20%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%E4%B8%BA%E4%BE%8B/"/>
    <url>/2024/06/28/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E4%B8%83%E6%AD%A5%E6%90%AD%E5%BB%BA%E6%B0%B4%E7%8E%AF%E5%A2%83%E6%A8%A1%E5%9E%8B--%E4%BB%A5%20SWMM%20%E6%A8%A1%E5%9E%8B%E6%90%AD%E5%BB%BA%E4%B8%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近在学习水环境数学模型，结合一些讲座和文献资料，总结了模型搭建的大体步骤，以小流域非点源污染模型为例，依次梳理具体步骤的大体工作。以后有机会再对关键步骤进行记录。<br>模型搭建分为三个阶段：准备阶段、构建阶段、应用阶段。<br>主要步骤共七步。</p><ol><li>问题识别及目标设置</li><li>模型选择-&gt;模型原理</li><li>基础资料获取</li><li>模型网格划分-&gt;模型概化</li><li>边界条件初始条件设置</li><li>敏感性分析及参数率定</li><li>模型应用及部署</li></ol><p>详细流程图如下，灰色填充为核心步骤。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407031017858.png" alt="模型搭建流程图">  </p><h2 id="问题识别及目标设置"><a href="#问题识别及目标设置" class="headerlink" title="问题识别及目标设置"></a>问题识别及目标设置</h2><h3 id="区域概况"><a href="#区域概况" class="headerlink" title="区域概况"></a>区域概况</h3><p>模型评价区域为 D 流域源头区域，出境断面 W 为两省交界处，属于国控断面。流域面积 22 万平方公里，为农业区域，无工业及较大城镇。主河道总长约 9.2 km，河道比降 2.45‰，平均径流深 463.3 mm，平均径流深 463.3 mm，径流量约 1010 万方&#x2F;年。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407031427637.png" alt="流域预览"></p><h3 id="问题识别"><a href="#问题识别" class="headerlink" title="问题识别"></a>问题识别</h3><p>流域及国控断面主要问题包括：</p><ol><li>流域面积小，水资源少，水环境容量小。</li><li>堰坝多，枯水期几乎禁止，雨季流水不畅通</li><li>农业面源广，降雨时空不均。</li><li>国控断面水质达标压力大，主要污染指标 COD、高锰酸盐指数、氨氮。</li></ol><h3 id="模型目标"><a href="#模型目标" class="headerlink" title="模型目标"></a>模型目标</h3><p>搭建流域非点源模型主要实现以下两个目标：<br>一是精准识别面源污染时空分布特征，便于决策者实施针对性的干预措施，减少污染物入河量，减缓季节性、异常天气及农业面源引起的水质恶化幅度。<br>二是实现闸坝开闭、调蓄水、人工湿地等 LID 措施的预测预演，为决策者制定管理措施提供依据。</p><h2 id="模型选型及模型原理"><a href="#模型选型及模型原理" class="headerlink" title="模型选型及模型原理"></a>模型选型及模型原理</h2><p>实现上述模型目标有非常多的模型可以选择，比如 SWMM、SWAT、HSPF。这里不展开叙述，本文以 SWMM 模型为例进行阐述。<br>SWMM（Storm Water Management Model，暴雨洪水管理模型）是由美国环境保护署（U.S.EPA）于 1971 年开发并推广使用的一个动态降水-径流模拟模型， SWMM 模型可以跟踪模拟不同时间步长任意时刻每个子汇水区所产生径流的水质和水量。<br>SWMM 模型体积小、速度快、开源免费，且国内二次开发的人很多，学习成本相对较低。<br>目前城市排水管网设计、城市雨洪与污染模拟以及低影响开发等方面研究与应用中使用最为广泛的一款模型。<br>SWMM 模型功能模块及原理涉及内容较多，篇幅限制，本文不展开描述。</p><h2 id="基础资料获取"><a href="#基础资料获取" class="headerlink" title="基础资料获取"></a>基础资料获取</h2><p>在启动 SWMM 模型构建之前，首要任务是构建一个全面且精细的数据基础架构，以确保模型输入的准确性和可靠性。这一过程不仅涵盖数据的采集与预处理，还包括构建一个高效的数据管理系统，以为模型运行提供坚实的数据支撑。所需数据囊括了多个维度，具体包括但不限于：</p><p><strong>子汇区划信息</strong>：明确流域内部的水文响应单元，为径流模拟奠定空间基础。</p><p><strong>地形坡度与地貌数据</strong>：基于数字高程模型 (DEM) 获取，用以分析地形对水流方向和速度的影响。</p><p><strong>土地利用分类</strong>：详细的土地利用地图，区分不同活动区域（如农业、住宅、工业、自然保护区等），对理解污染物来源至关重要。</p><p><strong>河道与水系结构</strong>：流域内河流、沟渠、湖泊等水体的分布与连通性，直接影响水流路径。</p><p><strong>气象参数</strong>：长期的降雨、温度、湿度等气象记录，用以模拟不同气候条件下的水文响应。</p><p><strong>水文与水质监测数据</strong>：历史水位、流量、水质参数记录，用于模型校准与验证。</p><h3 id="静态信息"><a href="#静态信息" class="headerlink" title="静态信息"></a>静态信息</h3><ol><li>闸坝堰口（经纬度、坝低高程、坝高、坝宽、类型、出水孔径）</li><li>人工湿地（几何中心经纬度，长度）</li><li>净化塘（几何中心经纬度，有效容积，可用容积，所在河流）</li><li>前置库（经纬度、面积、汇水量、状态、备注，所在河流）</li><li>水库（经纬度、设计库容、当前库容、死库容、平均库容、水质）</li><li>典型农田入河口（经纬度、面积、深度）</li></ol><h3 id="动态信息（时序数据）"><a href="#动态信息（时序数据）" class="headerlink" title="动态信息（时序数据）"></a>动态信息（时序数据）</h3><ol><li>闸坝堰口（流量、水位、水质）</li><li>人工湿地（水位、水质）</li><li>前置库（水位、水质）</li><li>水库（当前库容、水位、水质）</li><li>典型农田入河口水质。</li><li>实时降雨量及预测降雨量<br>为了获取动态数据往往需要依靠物联监控设备，包括水质、水位、流量等数据。</li></ol><h2 id="模型概化"><a href="#模型概化" class="headerlink" title="模型概化"></a>模型概化</h2><p>流域空间概化是将实际流域的地理信息转化为模型输入数据的过程，收集流域的地形图、土地利用图、DEM 等基础地理数据；通过 GIS 软件进行流域边界的确定和地形地貌的分析，识别流域内的高程、坡度、流向、特征宽度，计算径流系数；对土地利用进行分类，识别主要的水系网络，并简化排水系统；提取流域的关键特征参数，如流域面积和高程，并根据模型需求设定合适的空间分辨率；最后，将概化后的空间信息转换为模型输入所需的格式，并进行数据验证和备份，确保模型输入的准确性和一致性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407111042979.png" alt="概化数据"></p><h2 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h2><p>在 SWMM 模型搭建阶段，我们首先汇总并整理先前收集的流域内详尽数据，包括地形、土地利用、降雨、水文监测记录等，利用 GIS 技术完成流域的空间概化与子流域划分，并将这些数据集成至专为 SWMM 设计的数据库中。随后，基于流域特性和预处理数据，在 SWMM 上构建模型框架，细致设定子流域属性、管道网络、节点及出流条件等模型组件，并依据流域实际情况初步配置模型参数。</p><h2 id="边界条件初始条件设置"><a href="#边界条件初始条件设置" class="headerlink" title="边界条件初始条件设置"></a>边界条件初始条件设置</h2><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>边界条件通常指模型计算区域边缘处的条件，对于 SWMM 模型而言，包括：<br>入口流量：上游河流或排水系统的流入量。<br>出口条件：下游边界可以设定为自由出口（允许水流无限制地流出），或者设定为水位控制的出口（如潮汐边界条件）。<br>降雨边界条件：包括降雨强度和持续时间，这通常是模型的输入数据之一。</p><h3 id="初始条件设置"><a href="#初始条件设置" class="headerlink" title="初始条件设置"></a>初始条件设置</h3><p>初始条件反映的是模型开始运行时系统状态，包括：<br>水库、水池水位：各水库或池塘的初始水位。<br>管道和节点状态：管道中的水量和节点水位等。<br>污染物浓度：各个部分的初始污染物浓度。</p><h2 id="敏感性分析及参数率定"><a href="#敏感性分析及参数率定" class="headerlink" title="敏感性分析及参数率定"></a>敏感性分析及参数率定</h2><h3 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h3><p>敏感性分析用于评估模型输出对不同参数变化的反应程度，帮助确定哪些参数对模型结果的影响最大。在 SWMM 中，涉及以下参数：</p><ul><li><strong>降雨径流系数</strong>：影响径流产生和地面渗透。</li><li><strong>截留曲线</strong>：描述雨水被植被和土壤截留的关系。</li><li><strong>污染物负荷降级系数</strong>：影响非点源污染的模拟。</li></ul><h3 id="参数率定"><a href="#参数率定" class="headerlink" title="参数率定"></a>参数率定</h3><p>SWMM 模型的率定是一个迭代且精细的过程，它涉及将模型在不同降雨事件下的预测输出与实际观测数据进行细致对比，以此来评估并优化模型参数。我们首先选取具有代表性的历史降雨期间的水文与水质观测记录作为校准基准，通过模型敏感性分析识别出对模拟结果影响最大的参数集合，如降雨径流转换参数、渗透系数、管道糙率等。随后，采用逐步逼近策略，可能结合自动化算法如遗传算法、粒子群优化或手动微调，反复调整这些关键参数，直到模型模拟的径流过程、峰值流量、污染物负荷与实测数据之间达到最佳拟合状态，确保模型的预测能力与现实情况高度契合，为流域水文模拟和污染控制策略提供可靠依据。</p><h2 id="模型应用及部署"><a href="#模型应用及部署" class="headerlink" title="模型应用及部署"></a>模型应用及部署</h2><p>模型应用包括产出预测数据、决策指导、专题图等。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407111054161.png" alt="子汇水区污染负荷专题图"></p><p>模型部署如果研究用不用考虑太多，随便弄个服务器就行，如果在政府事业单位应用需要考虑国产化方案，包括数据库、服务器、操作系统等等。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上只是对于 SWMM 水环境建模的一些粗浅思考记录，是一个小结也是一个开始，先了解整体流程，后续会对每个部分认真学习和记录，一起加油💪⛽️。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>第七届水环境模拟与预测学术论坛  </li><li>基于 SWMM 模型肇兰新河哈尔滨段流域非点源污染研究  </li><li>小小小 up 北京工业大学王昊 - ArcGIS 与 swmm 结合对城市管网进行建模</li></ul><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a>  </p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生态环境</tag>
      
      <tag>机理模型</tag>
      
      <tag>SWMM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian中用check list 打造待办清单</title>
    <link href="/2024/06/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/check%20list%20%E6%89%93%E9%80%A0%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"/>
    <url>/2024/06/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/check%20list%20%E6%89%93%E9%80%A0%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在快节奏的现代生活中，有效管理个人时间和任务成为提升生活与工作效率的关键。<br>Obsidian，作为一款强大的知识管理和笔记应用，通过其丰富的插件生态，为我们提供了高度自定义的任务管理解决方案。本文旨在详细介绍如何在Obsidian中集成待办事项管理功能到日常日记记录中，帮助您轻松规划每日任务，保障工作的有序进行。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p> <strong>Check list</strong><br>Checklist插件通过识别文件中的特定标签（如 <code>#todo</code>）和格式Markdown checklist语法），自动生成一个整洁的侧边栏任务列表。这不仅使任务一目了然，还实现了任务与日记内容的无缝衔接，便于追踪和回顾。<br><strong>Editing toolbar</strong><br>此插件扩展了Obsidian的编辑器工具栏，加入了一个直观的待办事项切换按钮。用户无需记忆Markdown语法，一键即可在文本中插入或转换待办事项格式，大大提升了录入效率。<br><strong>日记</strong><br>自带插件：日记的元数据中添加 todo 标签，日记中所有代办事项均会在侧边栏显示。</p><h2 id="清单原则"><a href="#清单原则" class="headerlink" title="清单原则"></a>清单原则</h2><ol><li>每天需要完成的清单不能太多，堆满屏幕会让人崩溃。</li><li>整理回顾清单，长时间未完成的及时划掉重新开始，好过长期霸占清单栏。</li><li>明确核心任务，根据任务重要新自上而下罗列。</li><li>简洁明了，减少分析清单的精力消耗。</li></ol><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>具体工作流如下</p><ol><li>新增日记（点击日历视图或者按钮）</li><li>写待办事项</li><li>全选事项点击编辑栏待办按钮</li><li>结束</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406221431476.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件推荐 caj2pdf</title>
    <link href="/2024/06/18/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%20caj2pdf/"/>
    <url>/2024/06/18/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%20caj2pdf/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="推荐内容"><a href="#推荐内容" class="headerlink" title="推荐内容"></a>推荐内容</h2><p>用 zotero 管理文献时，不能处理知网 caj 格式，有大佬做了相应的工作并开源。<br>今天推荐两个 GitHub 项目</p><ol><li><a href="https://github.com/caj2pdf/caj2pdf">https://github.com/caj2pdf/caj2pdf</a></li><li><a href="https://github.com/ElonH/caj2pdf_gui">https://github.com/ElonH/caj2pdf_gui</a></li></ol><p>一是 python 做的 caj 2 pdf 源码，二是结合caj 2pdf 和QT5 做的应用。<br>其中二的软件在 Releases 里可以直接下载。</p><p>感谢大佬们的贡献。</p><h2 id="软件界面"><a href="#软件界面" class="headerlink" title="软件界面"></a>软件界面</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406181400793.png" alt="image.png"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>输入 caj 格式文件</li><li>点击 show 可插件 caj 文件信息</li><li>点击 convert 生成 pdf</li><li>输入生成后的 pdf，点击 outlines 添加目录信息到 pdf</li></ol><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>成功转换后，文字排版，目录等都很好的保留了，效果和好。<br>再次感谢大佬的无私奉献。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406181413552.png" alt="转换后预览对比"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zotero</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>streamlit快速搭建芝加哥雨型应用</title>
    <link href="/2024/06/16/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2024/06/16/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E5%9E%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过streamlit快速搭建芝加哥雨型应用，该应用实现以下功能：</p><ul><li>内置重庆各区县的暴雨强度计算公式，</li><li>支持自定义城市的暴雨公式参数，</li><li>支持雨型生成，输出图片和文字</li><li>提供降雨历时、汇水面积、径流系数输入，支持径流量计算</li><li>在线部署，网页使用。</li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>用 obsidian excalidraw 简单绘制原型。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162135564.png" alt="image.png"></p><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><ul><li>《关于发布重庆市暴雨强度修订公式及设计暴雨雨型的通知》（渝建〔2017〕443 号）</li><li><a href="https://www.vivifree.com/rain-model-chicago-formula.html">芝加哥合成暴雨过程线的公式推导 (vivifree.com)</a></li></ul><h2 id="主要功能实现"><a href="#主要功能实现" class="headerlink" title="主要功能实现"></a>主要功能实现</h2><h3 id="雨强计算"><a href="#雨强计算" class="headerlink" title="雨强计算"></a>雨强计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">intensity</span>(<span class="hljs-params">A, B, C, N, t, P</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    雨强计算。</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    - a,b,c,n: 参数。</span><br><span class="hljs-string">    - p (float): 设计重现期（单位：年）。</span><br><span class="hljs-string">    - t (np.ndarray): 分钟数组</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    - its: 雨强（单位：mm/min）。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a = A * <span class="hljs-number">0.4</span> * (<span class="hljs-number">1</span> + C * math.log10(P))<br>    its = a * ((<span class="hljs-number">1</span> - N) * t + B) / np.power(t + B, N + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> its<br>    <br>q = (A * (<span class="hljs-number">1</span> + C * math.log10(P))) / ((duration_minutes + B) ** N)<br></code></pre></td></tr></table></figure><h3 id="雨强分布计算"><a href="#雨强分布计算" class="headerlink" title="雨强分布计算"></a>雨强分布计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rainCalc_single_period</span>(<span class="hljs-params">A, B, C, N, T: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">float</span>, peak_ratio: <span class="hljs-built_in">float</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算单一时段内的降雨强度分布。</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    - T (int): 降雨持续时间（单位：分钟）。</span><br><span class="hljs-string">    - p (float): 设计重现期（单位：年）。</span><br><span class="hljs-string">    - peak_ratio (float): 雨强峰值所在时间占总降雨历时的比例。</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    - np.ndarray: 随时间变化的降雨强度数组（单位：mm/min）。</span><br><span class="hljs-string">    内部参数:</span><br><span class="hljs-string">    - t (np.ndarray): 分钟数组</span><br><span class="hljs-string">    - peak_time (float): 峰值时间</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># ...函数实现代码...</span><br>    t = np.arange(<span class="hljs-number">0</span>, T)<br>    peak_time = T * peak_ratio<br>    itAr = np.zeros(<span class="hljs-built_in">len</span>(t))<br>    <span class="hljs-comment"># 计算雨强</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(t)):<br>        <span class="hljs-keyword">if</span> t[i] &lt; peak_time:<br>            itAr[i] = intensity(A, B, C, N, (peak_time - t[i]) / peak_ratio, p) / <span class="hljs-number">60</span><br>        <span class="hljs-keyword">else</span>:<br>            itAr[i] = intensity(A, B, C, N, (t[i] - peak_time) / peak_ratio, p) / <span class="hljs-number">60</span><br>    <span class="hljs-keyword">return</span> itAr<br></code></pre></td></tr></table></figure><p>其余功能实现均较为简单，项目所有代码均开源在 GitHub，有兴趣的可以去参观，点个 star 最好了，仓库如下：<br><a href="https://github.com/maoyu92/Chicago_rain_pattern">maoyu92&#x2F;Chicago_rain_pattern (github.com)</a><br>如果发现代码有不对的地方，也留言提醒我一下。</p><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><p>Streamlit 是非常好用的一个应用框架，支持免费部署一个应用，非常方便。</p><h3 id="部署-GitHub"><a href="#部署-GitHub" class="headerlink" title="部署 GitHub"></a>部署 GitHub</h3><p>应用部署在 GitHub。通过 git 将本地仓库部署在 GitHub 上，具体方法可参考：<br><a href="https://blog.csdn.net/weixin_42984235/article/details/136906942">在vscode中使用git-新手向_新手vscode git-CSDN博客</a><br>这里跳过。</p><h3 id="Streamlit-应用发布"><a href="#Streamlit-应用发布" class="headerlink" title="Streamlit 应用发布"></a>Streamlit 应用发布</h3><p>登录 Streamlit，登录后点击右上角 create app。<br>选择 I have an app。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162151546.png" alt="image.png"></p><p>在连接上自己的 GitHub 后，依次选择仓库地址，分支，主文件，定义 url 名称，点击 depoly。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162152131.png" alt="image.png"></p><p>稍等片刻，如果一切顺利就成功了，非常丝滑~</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>仓库文件需要包括 requirement.txt，为项目运行需要的环境。</li><li>注意代码引用文件需要用相对应用的方式，不要绝对引用。</li></ol><h3 id="成果预览"><a href="#成果预览" class="headerlink" title="成果预览"></a>成果预览</h3><p>网址：<a href="https://chicagorainpattern.streamlit.app/">Streamlit (chicagorainpattern.streamlit.app)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162156332.png" alt="image.png"></p><h2 id="制作-exe-发布"><a href="#制作-exe-发布" class="headerlink" title="制作 exe 发布"></a>制作 exe 发布</h2><h3 id="nativefier"><a href="#nativefier" class="headerlink" title="nativefier"></a>nativefier</h3><p>安装nativefier<br>如果安装不快或者安装不成功，可以试下先换为阿里源。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npmjs.org/</span><br>npm install -g nativefier<br></code></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">nativefier</span> <span class="hljs-built_in">--name</span> <span class="hljs-string">&#x27;&lt;app.exe name&gt;&#x27;</span> <span class="hljs-string">&#x27;&lt;streamlit sharing website url&gt;&#x27;</span> <span class="hljs-built_in">--platform</span> &lt;<span class="hljs-string">&#x27;windows&#x27;</span> <span class="hljs-string">or</span> <span class="hljs-string">&#x27;mac&#x27;</span> <span class="hljs-string">or</span> <span class="hljs-string">&#x27;linux&#x27;</span>&gt;<br><br><span class="hljs-string">nativefier</span> <span class="hljs-built_in">--name</span> <span class="hljs-string">&quot;rainmaker&quot;</span> <span class="hljs-string">&quot;https://chicagorainpattern.streamlit.app/&quot;</span> <span class="hljs-built_in">--platform</span> <span class="hljs-string">windows</span><br></code></pre></td></tr></table></figure><p>完成后会在执行命令的目录下生成一个可执行文件。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182057691.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182057740.png" alt="image.png"></p><p>点击就可以直接运行<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182058701.png" alt="image.png"></p><p>这种方法感觉像是内置了一个浏览器，缺点也很明显，只能根据网址生成，如果取消已生成的 web 应用，则无法生效。可能也是防止可以随便生成应用吧。还有就是文件比较大，分享比较麻烦，还不如直接发网址。</p><h4 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h4><p>包装 PyInstaller包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pyinstaller<br></code></pre></td></tr></table></figure><p>检查是否安装</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">pip <span class="hljs-keyword">show</span> pyinstaller<br></code></pre></td></tr></table></figure><p>将 pyinstaller. exe 路径放入系统变量<br>通常在 C:\ProgramData\anaconda 3\Scripts 这个下面。</p><p>创建一个.spec文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pyinstaller <span class="hljs-attr">--name</span> rainmaker <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><p>遇到问题<br>pathlib与 pyinstaller 不兼容</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pip uninstall pathlib</span><br></code></pre></td></tr></table></figure><p>继续执行创建. Spec 文件<br>运行了半天，结束后出现好几个文件<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182139227.png" alt="image.png"></p><p>修改. Spec 文件<br>主要修改内容</p><ol><li>Pathex 路径正确</li><li>Datas 都包括所有信息和位置关系</li><li>Hookspath 指定自定义 hook 路径</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># -*- mode: python ; coding: utf-8 -*-</span><br><br>block_cipher = None<br><br>a = Analysis(<br>    [<span class="hljs-string">&#x27;main.py&#x27;</span>],<br>    pathex=[<span class="hljs-string">&#x27;D:\\BaiduSyncdisk\\pythonprograms\\rainmaker&#x27;</span>],  # 确保路径正确<br>    binaries=[],<br>    datas=[(<span class="hljs-string">&#x27;raincode.xlsx&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>), (<span class="hljs-string">&#x27;hook/hook-streamlit.py&#x27;</span>, <span class="hljs-string">&#x27;hook&#x27;</span>)],<br>    hiddenimports=[],  # 根据需要添加隐藏导入<br>    hookspath=[<span class="hljs-string">&#x27;./hooks&#x27;</span>],  # 指定自定义hook路径<br>    hooksconfig=&#123;&#125;,<br>    runtime_hooks=[],<br>    excludes=[],<br>    <span class="hljs-attribute">noarchive</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">optimize</span>=0,  # 根据需求调整<br>)<br>pyz = PYZ(a.pure)<br><br>exe = EXE(<br>    pyz,<br>    a.scripts,<br>    [],<br>    <span class="hljs-attribute">exclude_binaries</span>=<span class="hljs-literal">True</span>,<br>    <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rainmaker&#x27;</span>,<br>    <span class="hljs-attribute">debug</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">bootloader_ignore_signals</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">strip</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">upx</span>=<span class="hljs-literal">True</span>,<br>    <span class="hljs-attribute">console</span>=<span class="hljs-literal">True</span>,  # 或<span class="hljs-literal">False</span>，根据应用类型<br>    <span class="hljs-attribute">disable_windowed_traceback</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">argv_emulation</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">target_arch</span>=None,<br>    <span class="hljs-attribute">codesign_identity</span>=None,<br>    <span class="hljs-attribute">entitlements_file</span>=None,<br>)<br>coll = COLLECT(<br>    exe,<br>    a.binaries,<br>    a.datas,<br>    <span class="hljs-attribute">strip</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">upx</span>=<span class="hljs-literal">True</span>,<br>    upx_exclude=[],<br>    <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rainmaker&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>使用. Spec 文件打包</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">pyinstaller rainmaker.<span class="hljs-keyword">spec</span><br></code></pre></td></tr></table></figure><p>失败，感觉打包还是有点难度。后面有空继续</p><p>打包完成后，在 <code>dist/ </code>（Windows上可能是 <code>dist/YourAppName.exe</code>）找到可执行文件，并运行它来测试打包是否成功。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pyinstaller <span class="hljs-attr">--onefile</span> <span class="hljs-attr">--additional-hooks-dir</span>=./hooks run<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--clean</span><br>pyinstaller <span class="hljs-attr">--onefile</span> <span class="hljs-attr">--additional-hooks-dir</span>=./hooks <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span> <span class="hljs-attr">--clean</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>生态环境</tag>
      
      <tag>水文分析</tag>
      
      <tag>经验分享</tag>
      
      <tag>streamlit</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>芝加哥雨量计算径流量</title>
    <link href="/2024/06/14/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E9%87%8F%E8%AE%A1%E7%AE%97%E5%BE%84%E6%B5%81%E9%87%8F/"/>
    <url>/2024/06/14/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E9%87%8F%E8%AE%A1%E7%AE%97%E5%BE%84%E6%B5%81%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>降雨量数据与市政给排水设计、初期污染源控制关系密切，本文以重庆永川某小流域为例，记录暴雨径流产生量的计算过程及芝加哥雨型的生成。<br>下一期介绍用 streamlit 制作暴雨径流及雨型生成器的制作。</p><p>本文提到的所有工具及资料均用云盘分享，大家可以直接下载使用。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>计算重庆永川某小流域，暴雨径流产生量及雨型。</p><h2 id="暴雨强度"><a href="#暴雨强度" class="headerlink" title="暴雨强度"></a>暴雨强度</h2><p>根据《关于发布重庆市暴雨强度修订公式及设计暴雨雨型的通知》（渝建〔2017〕443 号）可知，<br>重庆永川暴雨流量计算公式：</p><p>$$<br>q&#x3D;\frac{1312(1+0.971 \lg P)}{(t+7.739)^{0.631}}<br>$$</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141147630.png" alt="image.png"><br>式中：<br>P—设计降雨重现期，<br>T—降雨历时 min<br>Q—设计暴雨强度（L&#x2F;s·hm 2）<br>综上，重现期 10 年, 降雨历时 60 分钟, 暴雨强度 180.87 L&#x2F;s·hm 2。</p><h4 id="雨水重现期"><a href="#雨水重现期" class="headerlink" title="雨水重现期"></a>雨水重现期</h4><p>设计雨水重现期按照 4.1.3 规定，项目为农村地区取 10 年。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141610046.png" alt="image.png"></p><h4 id="降雨历时"><a href="#降雨历时" class="headerlink" title="降雨历时"></a>降雨历时</h4><p>降雨历时取值范围为 1~1440 min，本文取60 min。</p><h2 id="初期雨量计算"><a href="#初期雨量计算" class="headerlink" title="初期雨量计算"></a>初期雨量计算</h2><h3 id="雨水量计算公式"><a href="#雨水量计算公式" class="headerlink" title="雨水量计算公式"></a>雨水量计算公式</h3><p>根据《室外排水设计标准》（GB 50014-2021），初期雨水量计算公式如下 ：<br>$$<br>Q &#x3D; q \times \psi \times F<br>$$<br>Q&#x3D;q×ψ×F<br>    式中：Q─雨水设计流量 （L&#x2F;s）；<br>    ψ─径流系数，取ψ&#x3D;0.45；<br>    F─汇水面积（hm2），为 hm2。<br>    q—暴雨强度（ L&#x2F;s•hm2）  </p><h4 id="径流系数"><a href="#径流系数" class="headerlink" title="径流系数"></a>径流系数</h4><p>室外排水设计标准中径流系数规定如下，并没有以耕地、水田为主的农业区域的径流系数信息。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141610951.png" alt="image.png"></p><p>在等雨量条件下 ,覆盖度在 95 %以上的耕地 ,径流系数为 0. 23 ,而覆盖度为 15 %的农地径流系数为0. 59<sup>[1]</sup>，根据《重庆市永川区水利发展“十三五”规划》，径流系数为 0.45，综合考虑，本次计算取 0.45。</p><p>综上，重现期10年,降雨历时60分钟, 暴雨强度180.87 L&#x2F;s·hm<sup>2</sup>,流域面积2000.0公顷，径流系数为0.45，流量为 162780.99 L&#x2F;s,累计汇水量586011.58 m³</p><h4 id="芝加哥雨型"><a href="#芝加哥雨型" class="headerlink" title="芝加哥雨型"></a>芝加哥雨型</h4><p>芝加哥雨型是一种用于城市雨洪设施设计的短历时设计雨型，由Keifer和Chu在1957年提出，主要用于模拟短时间内高强度的降雨过程，以评估和设计排水系统的能力。芝加哥雨型通过暴雨强度公式（IDF，Intensity-Duration-Frequency relationship）推导得出，并通过特定的处理方法来表达降雨过程中的峰值和衰减特性。<br>芝加哥雨型的特色在于它将暴雨分为峰前和峰后的两个阶段，通过一个系数 𝑟（介于0到1之间）来确定雨峰的位置，使得降雨过程更符合实际中雨强先增后减的变化规律。<br>一般情况下雨峰系数可取 0.35 。</p><p>通过芝加哥雨型计算可以相对较好的模拟降雨过程，计算累计雨量。<br>直接用芝加哥雨型生成器制作。计算结果可放入 swmm 模型中。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141340955.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406161744651.png" alt="image.png"></p><p>经过计算，重现期 10 年，降雨历时 60 分钟，累计雨量为 65 毫米。</p><p>下一期将介绍如何用 streamlit 制作暴雨径流及雨型生成器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>重庆市水土流失的影响因素及防治对策<br>《室外排水设计标准》（GB 50014-2021）<br>《重庆市永川区水利发展“十三五”规划》<br>《关于发布重庆市暴雨强度修订公式及设计暴雨雨型的通知》（渝建〔2017〕443 号）</p><p><a href="https://www.vivifree.com/rain-model-chicago-formula.html">芝加哥合成暴雨过程线的公式推导 (vivifree.com)</a><br><a href="https://weather.sz.gov.cn/qixiangfuwu/qihoufuwu/qihouguanceyupinggu/baoyuqiangdugongshi/mindex.html">暴雨强度公式-深圳市气象局（台） (sz.gov.cn)</a><br><a href="https://blog.csdn.net/weixin_43012724/article/details/129505354">【水文模型】11 芝加哥雨型生成器-CSDN博客</a></p><h2 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h2><p>链接： <a href="https://pan.baidu.com/s/1qERiyC-kXL0uZoRfErQ63A">https://pan.baidu.com/s/1qERiyC-kXL0uZoRfErQ63A</a><br>提取码：uokm </p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水文分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锻炼 精读笔记 01</title>
    <link href="/2024/06/05/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/"/>
    <url>/2024/06/05/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 锻炼</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/80/cpPlatform_3tKaC95Z1mL61tPJbbGW2F/t7_cpPlatform_3tKaC95Z1mL61tPJbbGW2F.jpg" alt=" 锻炼|200"></li><li>书名： 锻炼</li><li>作者： 丹尼尔·利伯曼</li><li>简介： 我们是为休息而生，还是为跑而生？<br>跑步会毁了你的膝盖吗?<br>哪种运动项目蕞适合我？<br>懒惰是不正常的行为吗？<br>每晚都需要睡够 8 个小时吗？<br>我们可以跑得又快又远吗？<br>体育等于锻炼吗？<br>在不算太遥远的过去，我们那些狩猎采集者、农耕者祖先，为了获得足够的食物，每天需要进行数小时的身体活动，偶尔也会为了娱乐或者社交而做游戏或者跳舞，但没人会为了健康而奔跑或者行走几千米。锻炼只是人类进化过程中近期才出现的现象。哈佛大学进化生物学家丹尼尔·利伯曼凭借自己多年在世界各地的研究与经验，向我们讲述为什么我们从未进化出锻炼的本能。<br>在这本打破神话的书中，利伯曼告诉我们，锻炼，并不是人类的本能。利伯曼从人类学和进化学的角度探讨了我们的身体，破解了关于锻炼的 12 个谬误，教我们可以正确地对待自己的身体并进行正确的身体活动，帮助那些对锻炼感到焦虑、困惑和纠结的人们把锻炼重新放到正确的位置上。</li><li>出版时间 2022-06-01 00:00:00</li><li>ISBN： 9787574202009</li><li>分类： 生活百科-体育</li><li>出版社： 天津科学技术出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/f2432ab0813ab6e75g012b2d">https://weread.qq.com/web/reader/f2432ab0813ab6e75g012b2d</a></li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们可能从很多地方了解到，久坐影响身体健康，啤酒肚对身体不好，压力影响健康，但不了解其中的原因，甚至不知道这些说法对不对，这本书的意义是用详实的科学研究证明一些看似简单的道理。<br>读这本书的像是初读丹尼尔•卡尼曼的《思考快与慢》，以及《人类简史》。一方面惊叹作者对研究的认真态度，一方面书中阐述的知识，感觉像是打开了一扇窗，有种醍醐灌顶的融通感，而且本书的观点还可以指导养成良好的生活习惯，做一些简单的身体活动就起到健身的作用。</p><h2 id="我们从未进化出锻炼的本能"><a href="#我们从未进化出锻炼的本能" class="headerlink" title="我们从未进化出锻炼的本能"></a>我们从未进化出锻炼的本能</h2><p>锻炼的定义——为了改善健康、提高身体机能或运动技能而进行的有计划、成体系的身体活动，锻炼行为是人类独有的。<br>锻炼是最近才兴起的运动，对于早期的人类设置我的爷爷奶奶一辈，都是没有锻炼这个说法的，是在人类创造了足够的物质后，随着身体活动越来越少，而逐渐开始的活动。<br>而锻炼本身是枯燥而乏味，耗费时间，甚至痛苦的，我们往往因为没有锻炼而懊恼，同时有无法坚持锻炼。</p><h2 id="每天运动-1-小时"><a href="#每天运动-1-小时" class="headerlink" title="每天运动 1 小时"></a>每天运动 1 小时</h2><p>狩猎采集部落的人类工作时间为每天 7 小时，其中绝大部分时间用于完成轻体力劳动，而用于完成重体力劳动的时间最多为 1 小时。<br>“身体活动水平”（Physical Activity Level，PAL）是联合国粮食及农业组织用来衡量人体能量消耗标准的方法。PAL 的计算方法是：用一个人正常工作和生活 24 小时消耗的能量除以完全不离开床的情况下所消耗的能量。<br>办公室白领的 PAL 为 1.4-1.6，建筑工人为 1.7-2.0，狩猎采集者男性为 1.9，女性为 1.8。典型狩猎采集者的身体活动量与每天健身一小时的欧美人相当。<br>还有一种意想不到的数据解读方式，如果你是极少锻炼的普通人，那么你每天只需步行一两小时，便可以达到与狩猎采集者相当的身体活动水平。但即使是这样，现在的欧美人也极少能达到这样的活动水平。现代社会中成年工业化人口的平均 PAL 值是 1.67，而久坐人群的数据比这个值还要低。<br>如果每天不运动，虽然看起来少消耗的卡路里不多（100 卡），一年下来，至少能少消耗 2.6 万卡路里，足够跑 10 场马拉松了，这就是减少运动后肥胖的成因之一。</p><p>静止时身体的消耗<br>82 kg 的美国成年男性 24 小时静止不动消耗的能量为 1700 大卡。正常情况下，静息新城代谢消耗的能量占全部消耗能量的 63%。<br>由于脂肪是一种相对惰性的组织，对新陈代谢影响不大，哈扎男性的平均体重为 53.1 千克，基础代谢率为 1 300 大卡；哈扎女性的平均体重为 46.7 千克，基础代谢率为 1 060 大卡。</p><p>从明尼苏达大学的一位研究人员安塞尔·基斯博士（Dr. Ancel Keys）在二战后做的实验得出，</p><ol><li>极度饥饿会让人无精打采、情绪低落、欲望降低、抑郁、暴躁易怒、器官减小、体温降低。</li><li>脂肪是身体为了预防可能出现的食物匮乏情况，而形成的能量储备库。</li><li>饥饿状态下，身体会进入保护状态，调低基础代谢率，降低各种欲望，消耗脂肪，减少高耗能行文，仅维持基本的身体需要。</li><li>人体的基础代谢率是可变的。</li></ol><p>实际上，身体的能量只能用在身体生长、生命维持（静息代谢）、能量存储、身体活动、繁衍等五个方面。漫长的进化，使得人类选择尽可能能保持静态，为了让有限的能量用在有意义的事情上。你的身体在这 5 项功能之间所做的分配取决于你的年龄和你所处的能量环境。例如，如果你尚且年幼，处于成长期，你的生殖系统应该不会得到太多的能量，这也就是为什么动物通常会在停止生长之后才开始生育后代。如果你今天要去爬山，你在生命维持、储存脂肪或许还有繁衍方面分配到的能量会减少。如果你正在节食，你在身体活动和繁衍方面的能量会被削减。但是，请记住，从自然选择的角度看，不是所有权衡都是公平的。就像简·奥斯丁那样理智冷静的小说家一样，自然选择根本就不会在乎我们是否快乐、善良或者富有，它只偏爱那些有利于繁衍后代的可遗传性状，而权衡也是一种可遗传的性状。</p><p>生而懒惰，避免非必要的身体活动是人类的正常选择。</p><p>未完待续~<br>后面更精彩。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://blog.csdn.net/weixin_42984235/article/details/140129827">锻炼 读书笔记 番外 身体激素及神经递质-CSDN博客</a></p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p><h2 id="BY-1"><a href="#BY-1" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>锻炼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 离群值检验算法对比实战</title>
    <link href="/2024/06/05/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/python%20%E7%A6%BB%E7%BE%A4%E5%80%BC%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%AE%9E%E6%88%98/"/>
    <url>/2024/06/05/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/python%20%E7%A6%BB%E7%BE%A4%E5%80%BC%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离群数据统计检验是数据分析中的一个重要环节，用于识别和处理那些与主体数据集显著不同的数据点。在水质在线数据分析过程中往往会遇到各种异常值，需要我们进行识别。</p><p>本文尝试通过对比不同的离群值检验方法，探究适合本地水质在线数据的检验方法。</p><p>常用的离群数据统计检验方法有四分位法、Z-Score 方法、孤立森林法、3σ原则等 4 种方法。<br>经过对比分析，Z-Score 与 3σ原则方法是最适合水质在线数据离群值检验的方法。具有离群值检验准确，原理清晰易懂，实现简单，配置参数少等优点。</p><h2 id="示例数据集概览"><a href="#示例数据集概览" class="headerlink" title="示例数据集概览"></a>示例数据集概览</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051158386.png" alt="fig1. 数据集折线图"></p><p>上图是一个实际环境中运行的水质变化曲线，可见存在明显的离群值，如果不去除异常值，则是对后续分析是不利的。</p><h2 id="不同离群值检验方法实现"><a href="#不同离群值检验方法实现" class="headerlink" title="不同离群值检验方法实现"></a>不同离群值检验方法实现</h2><h3 id="IQR-法（四分位距）方法"><a href="#IQR-法（四分位距）方法" class="headerlink" title="IQR 法（四分位距）方法"></a>IQR 法（四分位距）方法</h3><p>IQR 方法是识别极端值的非参数方法，不需要数据遵循正态分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <span class="hljs-comment"># Load the uploaded CSV file </span><br>file_path = <span class="hljs-string">&#x27;/mnt/data/2024-06-05T03-18_export.csv&#x27;</span> <br>data = pd.read_csv(file_path)<br><span class="hljs-comment"># Convert &#x27;监测时间&#x27; to datetime format for better plotting</span><br>data[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(data[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><span class="hljs-comment"># Sort the data by &#x27;监测时间&#x27; for better visualization in the plot</span><br>data_sorted = data.sort_values(by=<span class="hljs-string">&#x27;监测时间&#x27;</span>)<br><span class="hljs-comment"># Create a boxplot for the &#x27;双河口&#x27; column</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>plt.boxplot(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>], vert=<span class="hljs-literal">False</span>)<br>plt.title(<span class="hljs-string">&#x27;Box Plot of 双河口&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.show()<br><br><span class="hljs-comment"># Calculate IQR</span><br>Q1 = data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>].quantile(<span class="hljs-number">0.25</span>)<br>Q3 = data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>].quantile(<span class="hljs-number">0.75</span>)<br>IQR = Q3 - Q1<br><span class="hljs-comment"># Define the boundaries for outliers</span><br>lower_bound = Q1 - <span class="hljs-number">1.5</span> * IQR<br>upper_bound = Q3 + <span class="hljs-number">1.5</span> * IQR<br><span class="hljs-comment"># Filter out the outliers</span><br>outliers = data_sorted[(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>] &lt; lower_bound) | (data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>] &gt; upper_bound)]<br><span class="hljs-comment"># Display the outliers</span><br>outliers<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051343400.png" alt="fig2.箱线图"></p><h2 id="Z-Score-方法"><a href="#Z-Score-方法" class="headerlink" title="Z-Score 方法"></a>Z-Score 方法</h2><p>Z-Score 方法，也称为标准分数，是一种用于评估数据点相对于数据集平均值的标准偏差的统计方法。这种方法通过计算每个数据点与数据集平均值的偏差，然后除以数据集的标准差，来衡量每个数据点的异常程度。具体来说，Z-Score 的计算公式如下：<br>$$<br>Z &#x3D; \frac{(X - \mu)}{\sigma}<br>$$<br>其中：</p><ul><li>𝑍是标准分数。</li><li>𝑋 是数据点的值。</li><li>𝜇是数据集的平均值。</li><li>𝜎 是数据集的标准差。</li></ul><p>Z-Score 的值可以用于判断数据点是否为离群值。一般来说，如果一个数据点的 Z-Score 大于 3 或小于-3，那么它就被认为是离群值。这是因为，根据正态分布的性质，大约 99.7%的数据点（在正态分布中）的 Z-Score 将落在-3 到 3 之间。因此，Z-Score 大于 3 或小于-3 的数据点可以被认为是异常值。</p><p>总之，Z-Score 方法是一种简单而强大的离群值检测方法，它通过计算数据点与数据集平均值的标准偏差来衡量每个数据点的异常程度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><span class="hljs-comment"># Calculate Z-Scores for the &#x27;双河口&#x27; column</span><br>data_sorted[<span class="hljs-string">&#x27;z_score&#x27;</span>] = stats.zscore(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>])<br><span class="hljs-comment"># Define the threshold for outliers based on Z-Score</span><br>z_threshold = <span class="hljs-number">3</span><br>outliers_z_score = data_sorted[(data_sorted[<span class="hljs-string">&#x27;z_score&#x27;</span>] &gt; z_threshold) | (data_sorted[<span class="hljs-string">&#x27;z_score&#x27;</span>] &lt; -z_threshold)]<br><span class="hljs-comment"># Display the outliers based on Z-Score</span><br>outliers_z_score[[<span class="hljs-string">&#x27;监测时间&#x27;</span>, <span class="hljs-string">&#x27;双河口&#x27;</span>, <span class="hljs-string">&#x27;z_score&#x27;</span>]]<br><br></code></pre></td></tr></table></figure><p>使用 Z-Score 方法检测到的离群值及其对应的监测时间如下：</p><ul><li>2024-04-25 00 时，值为 0.744，Z-Score 为 10.098</li><li>2024-05-03 16 时，值为 0.665，Z-Score 为 8.908</li><li>2024-05-03 20 时，值为 0.694，Z-Score 为 9.345</li><li>2024-05-04 00 时，值为 0.650，Z-Score 为 8.682</li><li>2024-05-04 04 时，值为 0.608，Z-Score 为 8.049</li><li>2024-05-04 08 时，值为 0.717，Z-Score 为 9.691</li><li>2024-05-04 20 时，值为 0.685，Z-Score 为 9.209</li><li>2024-05-07 12 时，值为 0.685，Z-Score 为 9.209</li></ul><p>使用折线图来展示整个时间序列，并使用红圈标出 Z-Score 方法识别出的离群值。这样可以直观地看到这些离群值在整个时间序列中的分布情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))<br>plt.plot(data_sorted[<span class="hljs-string">&#x27;监测时间&#x27;</span>], data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>], label=<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>outliers_z_score.plot(x=<span class="hljs-string">&#x27;监测时间&#x27;</span>, y=<span class="hljs-string">&#x27;双河口&#x27;</span>, kind=<span class="hljs-string">&#x27;scatter&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, ax=plt.gca(), label=<span class="hljs-string">&#x27;Outliers&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;双河口 Time Series with Outliers Highlighted&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Monitoring Time&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>plt.legend()<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.xticks(rotation=<span class="hljs-number">45</span>)  <br>plt.tight_layout()  <br>plt.show()<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051147385.png" alt="fig3. Z-Score 方法离群值可视化"></p><h3 id="3σ原则"><a href="#3σ原则" class="headerlink" title="3σ原则"></a>3σ原则</h3><p>3σ原则（3 倍标准差原则）是一种用于检测数据集中离群值的经典方法。根据这个原则，如果一个数据点的值大于 𝜇+3𝜎或小于 𝜇−3𝜎（其中 𝜇是数据的平均值，𝜎 是标准差），那么这个数据点就可以被认为是离群值。可以看到 3σ原则与 Z-Score 方法 z_threshold 取 3 意义是一样的，<br>两者的异同点如下：</p><ul><li><strong>相同点：</strong> 两者都依赖于数据的均值 (𝜇) 和标准差 (𝜎)，并且都是用来识别数据中的极端值或离群点。</li><li><strong>不同点：</strong> Z-Score 提供了每个数据点相对于分布中心位置的标准化度量，适用于更广泛的分析场景，包括但不限于离群值检测；而 3σ原则是一个更具体的规则，直接用来界定离群值的界限，且主要基于正态分布的特性。</li><li><strong>适用性：</strong> Z-Score 方法更为灵活，可以用于理解数据点的相对位置，而 3σ原则则是一个快速且直观的筛选工具，尤其适合正态分布数据集的初步离群值识别。</li></ul><p>Python 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载CSV文件 </span><br>file_path = <span class="hljs-string">&#x27;/mnt/data/2024-06-05T03-18_export.csv&#x27;</span> <br>df = pd.read_csv(file_path)<br><span class="hljs-comment"># 使用双河口列的数据</span><br>data_column = <span class="hljs-string">&#x27;双河口&#x27;</span><br><span class="hljs-comment"># 计算 mean 和 std</span><br>mean = df[data_column].mean()<br>std = df[data_column].std()<br><br><span class="hljs-comment"># 应用3σ法则来检测离群值</span><br>outliers = <span class="hljs-built_in">abs</span>(df[data_column] - mean) &gt; <span class="hljs-number">3</span> * std<br><span class="hljs-comment"># 将监测时间列转换为日期时间格式</span><br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><br><span class="hljs-comment"># 重新绘制时间序列和离群值</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>plt.plot(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>], df[data_column], label=<span class="hljs-string">&quot;时间序列&quot;</span>)<br>plt.plot(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>][outliers], df[data_column][outliers], <span class="hljs-string">&#x27;ro&#x27;</span>, label=<span class="hljs-string">&quot;离群值&quot;</span>)  <span class="hljs-comment"># 离群值用红色圆圈标记</span><br>plt.axhline(mean + <span class="hljs-number">3</span> * std, color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">&quot;上界&quot;</span>)<br>plt.axhline(mean - <span class="hljs-number">3</span> * std, color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">&quot;下界&quot;</span>)<br>plt.legend()<br>plt.title(<span class="hljs-string">&quot;时间序列离群值检测&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;监测时间&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;双河口值&quot;</span>)<br>plt.tight_layout()  <span class="hljs-comment"># 调整布局</span><br>plt.show()<br><span class="hljs-comment"># 计算有多少异常值 </span><br>outliers.<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051703178.png" alt="fig4. 3σ原则离群值可视化"></p><p>途中可以看出异常值的分布情况，共检测到了 8 个离群值。与 Z-Score 方法更接近。</p><h3 id="孤立森林法"><a href="#孤立森林法" class="headerlink" title="孤立森林法"></a>孤立森林法</h3><p>孤立森林（Isolation Forest）是一种用于检测离群值的机器学习方法，它适用于高维数据集，并且是一种无监督学习方法，不需要标签数据。但是缺点也很明显，就是配置参数较多，使用不方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> IsolationForest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_outliers_isolation_forest</span>(<span class="hljs-params">data_series</span>):<br>    iso_forest = IsolationForest(n_estimators=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>)<br>    outliers = iso_forest.fit_predict(data_series.values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">return</span> data_series[outliers == -<span class="hljs-number">1</span>]<br><span class="hljs-comment"># Apply the Isolation Forest method to detect outliers in the &#x27;双河口&#x27; column</span><br>outliers_isolation_forest = detect_outliers_isolation_forest(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>])<br><span class="hljs-comment"># Create a boolean mask for the outliers for plotting</span><br>outliers_mask = data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>].isin(outliers_isolation_forest)<br><span class="hljs-comment"># Plot the time series with outliers highlighted using Isolation Forest</span><br>plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))<br>plt.plot(data_sorted[<span class="hljs-string">&#x27;监测时间&#x27;</span>], data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>], label=<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br><span class="hljs-comment"># Highlight the outliers with red circles</span><br>plt.scatter(data_sorted[outliers_mask][<span class="hljs-string">&#x27;监测时间&#x27;</span>], <br>            data_sorted[outliers_mask][<span class="hljs-string">&#x27;双河口&#x27;</span>], <br>            color=<span class="hljs-string">&#x27;red&#x27;</span>, <br>            label=<span class="hljs-string">&#x27;Outliers&#x27;</span>)<br><br>plt.title(<span class="hljs-string">&#x27;双河口 Time Series with Outliers Highlighted by Isolation Forest&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Monitoring Time&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>plt.legend()<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.xticks(rotation=<span class="hljs-number">45</span>)  <span class="hljs-comment"># Rotate x-axis labels for better readability</span><br>plt.tight_layout()  <span class="hljs-comment"># Adjust layout to ensure all labels are displayed</span><br><span class="hljs-comment"># Show the plot</span><br>plt.show()<br><span class="hljs-comment"># Display the outliers detected by Isolation Forest</span><br>outliers_isolation_forest<br><br></code></pre></td></tr></table></figure><p>结果。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051233465.png" alt="fig5. 孤立森林法离群值可视化"></p><p>监测到离群值的数量太多，即使修改参数也很难达到想要的效果。<br>以下是 <code>IsolationForest</code> 算法中一些重要参数的介绍：</p><ol><li><code>n_estimators</code>:    <ul><li>表示决策树的数量。</li><li>增加 <code>n_estimators</code> 的值可以提高模型的稳定性，但同时可能会增加计算成本。</li><li>减少 <code>n_estimators</code> 的值可能会使模型对离群值的检测更加“宽容”，从而减少检测到的离群值数量。</li></ul></li><li><code>max_samples</code>:    <ul><li>表示从数据集中抽取用于训练每棵决策树的最大样本数。</li><li>减少 <code>max_samples</code> 的值可能会使模型对离群值的检测更加“宽容”，因为它限制了每棵树看到的数据点的数量。</li><li>默认值是‘auto’，表示每个节点都会从所有样本中随机抽取一个子样本。</li></ul></li><li><code>contamination</code>:    <ul><li>表示数据集中离群值的比例。</li><li>默认为 0.1，意味着模型会假设数据集中大约 10% 的数据是离群值。</li><li>如果设置为‘auto’，模型会自动估计数据集中的离群值比例。</li></ul></li><li><code>random_state</code>:    <ul><li>表示随机数生成器的种子，用于确保结果的可重复性。</li><li>设置 <code>random_state</code> 为一个固定的值（例如 42），可以确保每次运行模型时，生成的随机数序列是相同的。<br>在使用 <code>IsolationForest</code> 算法时，通常需要根据具体的数据集和应用场景来调整这些参数。在实际应用中，可能需要多次尝试不同的参数设置，以找到最适合特定数据集的配置。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Z-Score 方法和 3σ原则确实是离群值检验中广泛应用且效果显著的方法，尤其在处理水质在线监测数据时展现出其独特的优势。这两种方法之所以成为优选，原因可归纳为以下几点：</p><ol><li><strong>离群值检验准确</strong>：Z-Score 通过将每个数据点转化为标准分数，能够准确反映其相对于数据集平均值的偏离程度，而 3σ原则利用正态分布的特性，能有效识别出极少数的极端值，确保了检验结果的准确性。    </li><li><strong>原理一致且易于理解</strong>：二者均基于正态分布的统计理论，原理相通，易于解释。Z-Score 通过标准化处理使数据间的比较标准化，而 3σ原则直接依据正态分布的性质设定离群值边界，逻辑简洁明了。    </li><li><strong>实现简便，配置参数少</strong>：这两种方法的计算过程相对直接，仅需均值 (𝜇μ) 和标准差 (𝜎σ) 两个基本统计量即可实施，无需复杂的模型训练或调整大量参数，降低了实际操作的技术门槛。    </li><li><strong>适应水质数据特性</strong>：一个重要前提是水质在线数据往往倾向于呈现正态或近似正态分布，这与自然环境因素的随机波动、监测设备的稳定性能等因素有关。因此，基于正态分布假设的 Z-Score 和 3σ原则能够较好地匹配水质数据的特点，有效识别出因设备故障、污染事件或其他异常情况引起的离群值。</li></ol><p>综上所述，Z-Score 方法和 3σ原则凭借其检验准确度高、原理直观、实现便捷以及对水质在线数据特性的良好匹配性，成为了这类数据离群值检验的理想选择，特别是在追求高效实时监控和数据分析的水质管理领域。</p><p>感谢看完，如果对你有用请点赞关注哦。</p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>算法</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian zotero 联动方案 配置记录</title>
    <link href="/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20zotero%20%E8%81%94%E5%8A%A8%E6%96%B9%E6%A1%88%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20zotero%20%E8%81%94%E5%8A%A8%E6%96%B9%E6%A1%88%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Obsidian 和 zotero 都是非常好用的开源软件，两个软件能做到无缝联动也是很多人的想法，文献笔记可以丝滑的放进 obsidian 中，那多好，网上有很多教程，但能够一步到位讲清楚的很少。我也踩了很多坑才完成部署，希望本文能帮你少走弯路。<br>搭建 zotero 与 Obsidian 联动部署的目的是让我们更加专注做笔记，从来回折腾笔记中抽离出来，让我们更加沉浸的阅读和总结。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405311730349.png"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>Obsidian 插件（插件市场搜索下载）</p><ul><li>Zotlit<br>Zotero 插件</li><li>Obsidian Note for Zotero </li><li><strong>Zotero style</strong></li></ul><p>GitHub 搜索 zotero style 或者Obsidian Note for Zotero<br>点击 Releases 选择最新版本 xpi 下载。<br>Obsidian Note for Zotero 地址：<br><a href="https://github.com/aidenlx/obsidian-zotero/releases/download/zt1.0.1/zotero-obsidian-note-1.0.1.xpi">https://github.com/aidenlx/obsidian-zotero/releases/download/zt1.0.1/zotero-obsidian-note-1.0.1.xpi</a></p><h3 id="Note-for-Zotero配置"><a href="#Note-for-Zotero配置" class="headerlink" title="Note for Zotero配置"></a>Note for Zotero配置</h3><p>Obsidian Note for Zotero  启动 enable</p><h3 id="Zotero-style-配置"><a href="#Zotero-style-配置" class="headerlink" title="Zotero style 配置"></a>Zotero style 配置</h3><p>Zotero style 功能非常强大，作者在 B 站也做了很详细的讲解，包括自定义文件属性列，修改标签格式，修改标记格式等等，这里不展开讲，主要讲怎么设置标注的颜色和注释。<br>安装后，enable。<br>Shfit+P, 点击或者输入标注<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301428862.png" alt="image.png"></p><p>点开后默认有 8 种颜色，是以颜色命名的。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301641250.png" alt="image.png"><br>鼠标移动到颜色标记的位置，长按鼠标左键，进入配置界面，如果点按右键则是删除配置。可以点击下方的加号，再新增。<br>长按后根据自己喜好设置颜色及名称。这是我的设置，其实一般也记不住那么多标记，默认有 8 种分类，太多，根本用不完。设置四种颜色完全够用了，红、蓝、黄、绿，背景色调整低一点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301637938.png" alt="image.png"></p><p>安装好 Zotero style 插件后，会对标注进行美化。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301646817.png" alt="image.png"><br>类似这样，会比之前好看很多。这也大致是导入 obsidian 后的样子。</p><h3 id="Zotlit-设置"><a href="#Zotlit-设置" class="headerlink" title="Zotlit 设置"></a>Zotlit 设置</h3><p>设置各种文件存储、读取位置</p><h4 id="文献笔记位置"><a href="#文献笔记位置" class="headerlink" title="文献笔记位置"></a>文献笔记位置</h4><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301648497.png" alt="image.png"></p><h4 id="Zotero-数据库位置"><a href="#Zotero-数据库位置" class="headerlink" title="Zotero 数据库位置"></a>Zotero 数据库位置</h4><p>点击 启用服务器enable<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301649040.png" alt="image.png"></p><h4 id="笔记模板文件位置"><a href="#笔记模板文件位置" class="headerlink" title="笔记模板文件位置"></a>笔记模板文件位置</h4><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301649890.png" alt="image.png"></p><h4 id="修改模板配置文件"><a href="#修改模板配置文件" class="headerlink" title="修改模板配置文件"></a>修改模板配置文件</h4><p>修改文件名配置代码，用标题就好了<br>修改模板，代码看不懂没关系，可以用已经设置好的。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">&lt;%= it.<span class="hljs-built_in">title</span>%&gt;.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301652660.png" alt="image.png"></p><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><p>将ZtTemplates 对应文件进行修改。</p><h5 id="Zt-annot-Eta"><a href="#Zt-annot-Eta" class="headerlink" title="Zt-annot. Eta"></a>Zt-annot. Eta</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&lt;%<br><span class="hljs-keyword">var</span> colorToLabelMap = &#123;<br>    <span class="hljs-string">&quot; <span class="hljs-subst">#ffd400</span>&quot;</span>: <span class="hljs-string">&quot;重要方法&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#ff6666</span>&quot;</span>: <span class="hljs-string">&quot;重要概念&quot;</span>,<br>    <span class="hljs-string">&quot;#5fb236&quot;</span>: <span class="hljs-string">&quot;重要结论&quot;</span>,<br>    <span class="hljs-string">&quot;#2ea8e5&quot;</span>: <span class="hljs-string">&quot;研究背景&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#a28ae5</span>&quot;</span>: <span class="hljs-string">&quot;硏究路线&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#e56eee</span>&quot;</span>: <span class="hljs-string">&quot;文章素材&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#f19837</span>&quot;</span>: <span class="hljs-string">&quot;优秀配图&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#aaaaaa</span>&quot;</span>: <span class="hljs-string">&quot;其他&quot;</span>,<br>    <span class="hljs-string">&quot;default&quot;</span>: <span class="hljs-string">&quot;暂时未分类 &quot;</span> <br>&#125;;<br><span class="hljs-keyword">var</span> labelToShow = colorToLabelMap[<span class="hljs-literal">it</span>.color] || colorToLabelMap[<span class="hljs-string">&quot;default&quot;</span>];<br>%&gt;<br><br>[!note] &lt;span style=<span class="hljs-string">&quot; background:&lt;%= it.color %&gt;&quot;</span>&gt;&lt;%= labelToShow %&gt;&lt;/span&gt;<br><br>&lt;font color=<span class="hljs-string">&quot;#000000&quot;</span>&gt;&lt;%= <span class="hljs-literal">it</span>.imgEmbed %&gt;&lt;%= <span class="hljs-literal">it</span>.text %&gt;&lt;/font&gt;<br></code></pre></td></tr></table></figure><h5 id="zt-annots-eta"><a href="#zt-annots-eta" class="headerlink" title="zt-annots.eta"></a>zt-annots.eta</h5><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">&lt;% <span class="hljs-keyword">for</span> (const <span class="hljs-keyword">annotation</span> <span class="hljs-title">of</span> <span class="hljs-title">it</span>) &#123; %&gt;<br>&lt;%~ <span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;annotation&quot;</span>, <span class="hljs-keyword">annotation</span>) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><h5 id="Zt-field-Eta"><a href="#Zt-field-Eta" class="headerlink" title="Zt-field. Eta"></a>Zt-field. Eta</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&lt;%= it.title %&gt;&quot;</span><br><span class="hljs-symbol">citekey:</span> <span class="hljs-string">&quot;&lt;%= it.citekey %&gt;&quot;</span><br><span class="hljs-symbol">itemType:</span> <span class="hljs-string">&quot;&lt;%= it.itemType %&gt;&quot;</span><br>标题翻译: <span class="hljs-string">&quot;&lt;%= it.shortTitle %&gt;&quot;</span><br><span class="hljs-symbol">tags:</span> <span class="hljs-string">&quot;&lt;%= it.tags %&gt;&quot;</span><br>影响因子: <span class="hljs-string">&quot;&lt;%= it.libraryCatalog %&gt;&quot;</span><br><br>出版期刊: <span class="hljs-string">&quot;&lt;%= it.publicationTitle %&gt;&quot;</span><br>出版年份: <span class="hljs-string">&quot;&lt;%= it.date %&gt;&quot;</span><br>修改日期: <span class="hljs-string">&quot;&lt;%= it.dateModified %&gt;&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Zt-note-Eta"><a href="#Zt-note-Eta" class="headerlink" title="Zt-note. Eta"></a>Zt-note. Eta</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># &lt;%= it.title %&gt;</span><br><span class="hljs-comment">## 基础信息</span><br><br>|<span class="hljs-string"> 属性           </span>|<span class="hljs-string"> 信息                                 </span>|<br>|<span class="hljs-string"> ------------ </span>|<span class="hljs-string"> ---------------------------------- </span>|<br>|<span class="hljs-string"> **标题翻译**     </span>|<span class="hljs-string"> &lt;%= it.shortTitle %&gt;               </span>|<br>|<span class="hljs-string"> **作者**       </span>|<span class="hljs-string"> &lt;%= it.creators %&gt;                 </span>|<br>|<span class="hljs-string"> **出版年份**     </span>|<span class="hljs-string"> &lt;%= it.date %&gt;                     </span>|<br>|<span class="hljs-string"> **期刊**       </span>|<span class="hljs-string"> &lt;%= it.publicationTitle %&gt;         </span>|<br>|<span class="hljs-string"> **期刊等级**     </span>|<span class="hljs-string"> &lt;%= it.libraryCatalog %&gt;           </span>|<br>|<span class="hljs-string"> **标签**       </span>|<span class="hljs-string"> &lt;%= it.tags %&gt;                     </span>|<br>|<span class="hljs-string"> **附件链接**     </span>|<span class="hljs-string"> &lt;%= it.fileLink %&gt;                 </span>|<br>|<span class="hljs-string"> **zotero跳转** </span>|<span class="hljs-string"> [点这里跳回zotero哈](&lt;%= it.backlink %&gt;) </span>|<br><br>&gt; [!note]- 论文摘要<br>&gt; <span class="hljs-variable">&lt;%= it.abstractNote[[0]].replace(/\n/g, &#x27;&#x27;)   %&gt;</span><br>&gt; <br><br><span class="hljs-comment">## 论文注释</span><br><br><span class="hljs-variable">&lt;%~ include(&quot;annots&quot;, it.annotations) %&gt;</span><br></code></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>笔记流程<br>Zotero 做标注笔记，切换到列表视图，右键 obsidian Actions-Create notes。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301700082.png" alt="image.png"></p><p>Obsidian 中就新建了一条笔记。这个笔记会带有完善的元数据，方便检索。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405311715137.png" alt="image.png"><br>以下是笔记正文：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406010905743.png" alt="image.png"></p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><p>No literature note found for zotero item withkey K9HQMJ9Q</p><p>Not implemented yet</p><p>点击创建笔记时出错。</p><p>错误记录</p><p>以前的插件<br>Zotero tag<br>Better bibtex<br>Obsidian note<br>Reference<br>Style<br>Bnotes<br>茉莉花<br>翻译</p><p>Jasminum<br><a href="https://zotero-chinese.com/">Zotero 中文社区 | Zotero 中文维护小组 (zotero-chinese.com)</a></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p>[PKMer_ZotLit：Obsidian 与 Zotero 联动，有 \ <a href="https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/zotero-obsidian/zotlit%E5%AE%9E%E7%8E%B0obsidian%E5%92%8Czotero%E8%81%94%E5%8A%A8/">@ 就够了</a></p><p>简单导入方法</p><p>打开命令面板选择 “ZotLit: Open quick switcher for literature notes”</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>obsidian</tag>
      
      <tag>Zotero</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian 文本生成流程图 Excalidraw Mermaid</title>
    <link href="/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE%20%E6%B3%B0%E9%85%B7%E5%95%A6%20Excalidraw%20Mermaid%20Syntax/"/>
    <url>/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE%20%E6%B3%B0%E9%85%B7%E5%95%A6%20Excalidraw%20Mermaid%20Syntax/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介绍一个很酷的工具，<strong>Excalidraw Mermaid</strong> 。作用是用代码生成流程图。<br><strong>Mermaid</strong>  是一款强大的、轻量级的文本到图表的转换工具，它允许用户使用简单的Markdown风格的语法编写文本描述，然后通过JavaScript引擎将其转换成美观的图表。Mermaid的设计初衷是为了简化图表的创建过程，让用户能够更专注于内容本身而非复杂的图形界面操作。<br>Obsidian Excalidraw 可以直接用这个作图，而且部分类型图还可以编辑，简直完美。<br>再结合<strong>大预言模型</strong>，我们可以快速做出好看的流程图，还不来看下 QAQ。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>打开 Obsidian Excalidraw 点击工具栏最右侧工具图标，选择 <strong>Mermaid to Excalidraw</strong> </p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291421743.png" alt="image.png"><br>具体语法在 Mermaid 官网有，我们不需要了解的很深。因为可以借助大预言模型直接抄作业。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291424197.png" alt="image.png"></p><p>把文本代码微调下，<font color="#ffc000">就可以了</font>。</p><pre><code class=" Mermaid">graph TDStart((开始)) --&gt; QCCheck(质控判断)QCCheck --&gt;|合格| DataAnalysis(数据分析)QCCheck --&gt;|异常| InvalidData(无效数据)DataAnalysis --&gt;|正常| PollutionAnalysis(污染原因分析)DataAnalysis --&gt;|异常| 无效数据PollutionAnalysis --&gt;|污染指标同时上升| 上下游污染传递PollutionAnalysis --&gt;|pH等指标相关性| 藻类影响PollutionAnalysis --&gt;|雨量相关性| 雨污混流</code></pre><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291424058.png" alt="image.png"><br>然后插入 Excalidraw 中优化下就可以了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291428899.png" alt="image.png"><br>不到 3 分钟完成流程图绘制，而且是可以复制的，是不是很方便。</p><p>这个功能远远不止流程图这么简单，还可以绘制，饼图、序列图、甘特图、思维导图、折线图、雷达图，简直是个宝藏功能。其中流程图（Flowchart）、时序图（Sequence Diagram）和类图（Class Diagram）是支持在 Obsidian Excalidraw 中编辑的，其他的只能作为图片插入。当然作为图片插入也很好看~</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291449838.png" alt="image.png"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>如果觉得有用，别忘了点赞、收藏、关注、留言、分享哦。</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水质预测模型精度评估实例</title>
    <link href="/2024/05/27/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%B2%BE%E5%BA%A6%E8%AF%84%E4%BC%B0/"/>
    <url>/2024/05/27/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%B2%BE%E5%BA%A6%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>随着水资源管理需求的日益增长，水质预测模型的精准度成为了评估其有效性的关键因素。本文旨在通过实证研究，探讨自建水质预测模型的实际应用效能，通过与真实监测数据的比对，揭示模型预测精度的真实情况。</p><h2 id="数据基础情况"><a href="#数据基础情况" class="headerlink" title="数据基础情况"></a>数据基础情况</h2><p>数据来源：自研水质模型预测结果<br>时间范围：2023 年全年<br>指标：高锰酸盐指数、总磷、氨氮、氟化物</p><h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><p>本研究采用基于一维水质的机理模型，通过实时监测数据动态调整降解系数与污染物迁移速度，实现了单次对高锰酸盐指数、总磷、氨氮、氟化物长达20天以上的高适应性预测，尤其擅长捕捉水质突变事件。</p><h3 id="当前预测界面"><a href="#当前预测界面" class="headerlink" title="当前预测界面"></a>当前预测界面</h3><p>曲线图展示当前最新的预测结果。下部展示预测结果是否超标，峰值及超标时间范围，预测月均值与实际累计月均值。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405280926129.png" alt="Fig.1 模型可视化页面"></p><h3 id="模型评价界面"><a href="#模型评价界面" class="headerlink" title="模型评价界面"></a>模型评价界面</h3><p>可以查询历史预测区间的预测结果对比。下部为模型评价，通过多元统计指标（如MAPE、RMSE）深入剖析模型性能，特别是通过准确率区间分布图，多维度验证了模型的稳定性和可靠性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405280928978.png" alt="Fig.2 模型评价界面"></p><h2 id="模型精度评价方法"><a href="#模型精度评价方法" class="headerlink" title="模型精度评价方法"></a>模型精度评价方法</h2><p>为了评估模型的准确率，本文采用比较直观的“预测误差率”来表达，用于评估预测值与真实值之间的接近程度。<br>$$<br>\text{A} &#x3D; 1 - \frac{|Y - \hat{Y}|}{Y}<br>$$<br>A 表示相对准确性，𝑌 是观测到的真实值（或准确值），而 Y^ 是模型预测的值。这个公式量化了预测误差相对于真实值的比例，其逆值给出了预测相对于实际观察值的接近程度，可以视为一种衡量预测准确性的度量，这种表达通常被称为相对误差的倒数或者归一化绝对误差。</p><p>理论情况下，模型每天至少运行一次，预测因子包括高锰酸盐指数、总磷、氨氮、氟化物，每次预测不少于 7 天，模型评价方法是每个因子，每次所有预测结果，依次与监测指标进行比对，单个指标每次每个值得预测准确率计为 A。<br>$$ \bar &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^{N} A_i $$<br>这段公式表示求所有单次单个因子所有预测值的算术平均，其中 N 是预测值的数量。<br>用这种方法观察一年每次预测准确率的变化。</p><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>创建了一个 <code>WaterQualityPredictor</code> 类，该类封装与数据库交互、数据处理、预测数据获取、监测数据获取、准确率计算以及绘图等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaterQualityPredictor</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, db_config</span>):<br>        self.db_config = db_config<br>        self.conn = self._connect_db() <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_connect_db</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;连接数据库&quot;&quot;&quot;</span><br>        conn = pymysql.connect(**self.db_config)<br>        <span class="hljs-keyword">return</span> conn<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_model_data</span>(<span class="hljs-params">self, sql</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;从数据库获取模型数据&quot;&quot;&quot;</span><br>        df = pd.read_sql(sql, self.conn)<br>        <span class="hljs-keyword">return</span> self._process_data(df) <br>    @<span class="hljs-built_in">staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_process_data</span>(<span class="hljs-params">df</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;处理数据，包括时间格式转换和数值处理&quot;&quot;&quot;</span><br>        df[<span class="hljs-string">&quot;create_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;create_time&quot;</span>])<br>        df[<span class="hljs-string">&quot;start_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;start_time&quot;</span>])<br>        df[<span class="hljs-string">&quot;date_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;date_time&quot;</span>])<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;CODmn&quot;</span>, <span class="hljs-string">&quot;NH3&quot;</span>, <span class="hljs-string">&quot;TP&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>]:<br>            df[col] = df[col].astype(<span class="hljs-built_in">float</span>).<span class="hljs-built_in">round</span>(<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> df<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_prediction_dataset</span>(<span class="hljs-params">self, factor, create_time, prediction_days=<span class="hljs-number">7</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据因子和创建时间获取预测数据集&quot;&quot;&quot;</span><br>        subset = self.model_data[(self.model_data[<span class="hljs-string">&quot;create_time&quot;</span>] == create_time) &amp; (self.model_data[factor].notnull())].iloc[:<span class="hljs-number">6</span>*prediction_days]<br>        subset = subset[[<span class="hljs-string">&quot;date_time&quot;</span>, factor]].set_index(<span class="hljs-string">&quot;date_time&quot;</span>).reset_index()<br>        <span class="hljs-keyword">return</span> subset<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_monitor_data</span>(<span class="hljs-params">self, begin_time, end_time, station, period</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;获取监测数据&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 这里省略具体的请求逻辑，</span><br>        <span class="hljs-keyword">pass</span> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_accuracy</span>(<span class="hljs-params">self, prediction_df, monitor_df, factor</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;计算准确率&quot;&quot;&quot;</span><br>        concatenated_data = pd.merge(prediction_df, monitor_df, on=<span class="hljs-string">&quot;date_time&quot;</span>, suffixes=(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;_y&#x27;</span>))<br>        concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>] = <span class="hljs-number">1</span> - (<span class="hljs-built_in">abs</span>(concatenated_data[factor] - concatenated_data[factor+<span class="hljs-string">&#x27;_y&#x27;</span>]) / concatenated_data[factor])<br>        concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>] = concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>] * <span class="hljs-number">100</span><br>        average_accuracy = concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>].mean()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span>(average_accuracy, <span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_comparison</span>(<span class="hljs-params">self, concatenated_data, factor</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;绘制预测值与监测值对比图&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> concatenated_data[<span class="hljs-string">&#x27;date_time&#x27;</span>].equals(concatenated_data[<span class="hljs-string">&#x27;date_time_y&#x27;</span>]):<br>            plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>            plt.plot(concatenated_data[<span class="hljs-string">&#x27;date_time&#x27;</span>], concatenated_data[factor], label=<span class="hljs-string">&#x27;Prediction&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>            plt.plot(concatenated_data[<span class="hljs-string">&#x27;date_time_y&#x27;</span>], concatenated_data[factor+<span class="hljs-string">&#x27;_y&#x27;</span>], label=<span class="hljs-string">&#x27;Monitor&#x27;</span>, marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>            plt.xlabel(<span class="hljs-string">&#x27;Date Time&#x27;</span>)<br>            plt.ylabel(factor + <span class="hljs-string">&#x27; Value&#x27;</span>)<br>            plt.title(<span class="hljs-string">f&#x27;Comparison of <span class="hljs-subst">&#123;factor&#125;</span> Prediction and Monitor Values&#x27;</span>)<br>            plt.xticks(rotation=<span class="hljs-number">45</span>)<br>            plt.legend()<br>            plt.show()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;date_time and date_time_y are not aligned&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_analysis</span>(<span class="hljs-params">self, factor, create_time, station, period, prediction_days=<span class="hljs-number">7</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;执行整个分析流程&quot;&quot;&quot;</span><br>        self.model_data = self.fetch_model_data(<span class="hljs-string">&quot;SELECT * FROM mechanism&quot;</span>)<br>        prediction_df = self.get_prediction_dataset(factor, create_time, prediction_days)<br>        monitor_df = self.fetch_monitor_data(prediction_df[<span class="hljs-string">&quot;date_time&quot;</span>].<span class="hljs-built_in">min</span>(), prediction_df[<span class="hljs-string">&quot;date_time&quot;</span>].<span class="hljs-built_in">max</span>(), station, period)<br>        accuracy = self.calculate_accuracy(prediction_df, monitor_df, factor)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Average Accuracy: <span class="hljs-subst">&#123;accuracy&#125;</span>%&quot;</span>)<br>        self.plot_comparison(pd.concat([prediction_df, monitor_df], axis=<span class="hljs-number">1</span>), factor) <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    db_config = &#123;<br>        <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;port&quot;</span>: ,<br>        <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;db&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;charset&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    predictor = WaterQualityPredictor(db_config)<br>    predictor.run_analysis(<span class="hljs-string">&quot;factor&quot;</span>, datetime.now() - timedelta(days=<span class="hljs-number">7</span>), <span class="hljs-string">&quot;station&quot;</span>, <span class="hljs-string">&quot;h4&quot;</span>)<br></code></pre></td></tr></table></figure><p>实现任意预测时间的单词预测结果对比。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405280951942.png" alt="Fig.3单次预测高指预测对比"></p><h3 id="折线图分析准确率变化"><a href="#折线图分析准确率变化" class="headerlink" title="折线图分析准确率变化"></a>折线图分析准确率变化</h3><p>循环计算单词预测结果，取 2023 年整个时间段，四个指标准确率变化分别绘图。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405281034254.png" alt="Fig.4 预测精度折线图"><br><em>注：部分预测异常时段，存在站点运行问题，为展示真实预测情况，未对齐进行剔除。从预测异常的频次看出，异常频率并不高。</em></p><h3 id="饼图分析准确率占比"><a href="#饼图分析准确率占比" class="headerlink" title="饼图分析准确率占比"></a>饼图分析准确率占比</h3><p>为了更直观的分析预测准确率的分布，对四个因子准确率的分布划分为（小于40, 40<del>60, 60</del>80, 80~100）四个区间，分别作图如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_data_for_piechart</span>(<span class="hljs-params">df, column</span>):<br>    bins = [-np.inf, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>]<br>    labels = [<span class="hljs-string">&#x27;&lt;40%&#x27;</span>, <span class="hljs-string">&#x27;40%-60%&#x27;</span>, <span class="hljs-string">&#x27;60%-80%&#x27;</span>, <span class="hljs-string">&#x27;80%-100%&#x27;</span>]<br>    <span class="hljs-comment"># 使用cut函数将数据切分为区间，并计算每个区间内数据点的数量</span><br>    intervals = pd.cut(df[column], bins=bins, labels=labels, include_lowest=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 计算每个区间的频率</span><br>    frequencies = intervals.value_counts(normalize=<span class="hljs-literal">True</span>) * <span class="hljs-number">100</span><br>    <span class="hljs-keyword">return</span> frequencies<br>columns_to_analyze = df_2023.columns.tolist() <br>fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>), facecolor=<span class="hljs-string">&#x27;white&#x27;</span>)<br>axs = axs.ravel()  <span class="hljs-comment"># 将2x2的数组展平以便循环 </span><br><span class="hljs-keyword">for</span> i, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(columns_to_analyze):<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(axs):  <span class="hljs-comment"># 确保不会超出子图的范围</span><br>        frequencies = prepare_data_for_piechart(df_2023, column)<br>        axs[i].pie(frequencies, labels=frequencies.index, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>)<br>        axs[i].set_title(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;column&#125;</span> Precision Distribution&#x27;</span>)<br>        axs[i].axis(<span class="hljs-string">&#x27;equal&#x27;</span>)  <span class="hljs-comment"># 确保饼图是圆形</span><br><span class="hljs-comment"># 隐藏未使用的子图</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(axs)):<br>    fig.delaxes(axs[j])<br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405281028472.png" alt="Fig.5 预测准确率分布饼图"></p><p>上图表明，高锰酸盐指数准确率超过 60%的比例占比 95.4%，总磷准确率准确率超过 60%的比例 91.7%。详细指标可见下表。</p><table><thead><tr><th></th><th>年平均准确率</th><th>预测天数</th><th>&gt;80%</th><th>80~ 60%</th></tr></thead><tbody><tr><td>高锰酸盐指数</td><td>84.78</td><td>327</td><td>83.2</td><td>14.1</td></tr><tr><td>总磷</td><td>79.52</td><td>327</td><td>70.6</td><td>21.1</td></tr><tr><td>氨氮</td><td>-186</td><td>321</td><td>0.9</td><td>4</td></tr><tr><td>氟化物</td><td>81.27</td><td>119</td><td>36.1</td><td>63.95</td></tr><tr><td><em>注：受站点运行情况影响，部分时段无数据。</em></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="直方图分析准确率分布"><a href="#直方图分析准确率分布" class="headerlink" title="直方图分析准确率分布"></a>直方图分析准确率分布</h3><p>直方图（Histogram）是一个更好的可视化选择，因为它能清晰地展示每个准确率区间内的数据点数量，非常适合观察数据分布特征，如中心趋势、偏斜程度及异常值等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>bin_width = <span class="hljs-number">10</span><br>bins = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">110</span>, bin_width)) + [<span class="hljs-number">100</span>]  <span class="hljs-comment"># 包含100%的边界</span><br><span class="hljs-comment"># 创建一个2x2的子图网格</span><br>fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment"># 遍历每个因子，并绘制其准确率的直方图</span><br><span class="hljs-keyword">for</span> i, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(df_2023.columns):<br>    row = i // <span class="hljs-number">2</span><br>    col = i % <span class="hljs-number">2</span><br>    <span class="hljs-comment"># 绘制直方图</span><br>    axs[row, col].hist(df_2023[column], bins=bins, edgecolor=<span class="hljs-string">&#x27;black&#x27;</span>, alpha=<span class="hljs-number">0.7</span>)<br>    axs[row, col].set_title(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;column&#125;</span> Accuracy Distribution&#x27;</span>)<br>    axs[row, col].set_xlabel(<span class="hljs-string">&#x27;Accuracy (%)&#x27;</span>)<br>    axs[row, col].set_ylabel(<span class="hljs-string">&#x27;Frequency&#x27;</span>)<br><span class="hljs-comment"># 如果因子少于4个，隐藏多余的子图</span><br><span class="hljs-keyword">for</span> ax <span class="hljs-keyword">in</span> axs.flat[<span class="hljs-built_in">len</span>(df_2023.columns):]:<br>    ax.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><span class="hljs-comment"># 紧凑布局</span><br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405281046534.png" alt="Fig.6 预测精度分布直方图"><br>直方图能清晰的看出高锰酸盐指数、总磷预测准确率更好，且分布更集中。</p><p>本模型氨氮预测准确率低的原因是：该目标站点氨氮指标长期较低。月均值波动在 0<del>0.2 之间，小时值可能长期处于 0</del>0.1 之间，即使较小的波动，准确率的值波动也很大。同时氨氮指标该站点与上游站点的关系不密切，只有较大的污染传递才能引起轻微升高。<br>经过长期观察，氨氮并非该站点的重点污染指标。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>机理模型在某站点高锰酸盐指数、总磷、氟化物等指标 2023 年的预测均有较好的表现。以准确率（归一化绝对误差的逆）评价，累计分别为 84.78%、79.52%、81.27%。</li><li>由于氨氮值较低，且与上游站点变化较弱，对于氨氮指标的预测准确率不高。也因为氨氮值较低并非重点关注对象，若要考虑提高预测精度，可选择大数据模型，如 LSTM、prophet 等。</li><li>准确率（归一化绝对误差的逆）并不是水质模型精度评价的必选指标，只是因为其较为通俗易懂，而受用户认可，仍需注意其具有一定的局限性，作为一个模型评价的参考指标即可，不宜过分求高，水质模型是否准确，应考虑其预测水质变化的能力，水质影响（峰值、污染持续时间）等，是否能够知道业务需要，才是水质模型最重要的指标。</li></ol><p>综上所述，本研究构建的机理模型在多数水质指标预测上展现了良好的效果，尤其在高锰酸盐指数、总磷和氟化物的预测上取得了显著成绩。然而，氨氮预测的挑战凸显了模型对低浓度污染物处理能力的局限，后续将结合先进的机器学习技术以增强特定条件下的预测能力。水质模型的终极目标不仅是追求高精度数值，更重要的是能否有效指导水环境管理和应对策略，确保模型服务于实际的环境治理需求。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>生态环境</tag>
      
      <tag>时间序列模型</tag>
      
      <tag>机理模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian Excalidraw 更换字体 最新</title>
    <link href="/2024/05/26/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20excaildraw%20%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/"/>
    <url>/2024/05/26/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20excaildraw%20%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>​<meta name="referrer" content="no-referrer" /></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Excalidraw 是 obsidian 中最厉害的插件之一，长期霸占插件排行榜第一。以其强悍的性能和灵活的可塑性受到大家的喜爱，可默认的字体对中文并不友好，网上大多数教程要不是过时了，要不是错的，还有就是太复杂，因此本文介绍如何更换本地字体，参考的是 obsidian 官方 YouTube 教程。<br><strong>Obsidian 版本：v 1.5.12</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8ae99ee9eb4634ff04bc243d04d67421.png" alt="默认字体效果预览">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>默认字体效果预览</p><h2 id="文件链接设置"><a href="#文件链接设置" class="headerlink" title="文件链接设置"></a>文件链接设置</h2><p>首先打开设置-文件与链接-开启检测所有类型文件</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bca4ebd36084209275591a06cf1fd35d.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><h2 id="下载并存放本地字体"><a href="#下载并存放本地字体" class="headerlink" title="下载并存放本地字体"></a>下载并存放本地字体</h2><p>下载喜欢的字体，一开始我随便下载字体，比如 <strong>霞鹜文楷</strong>开源字体，但是设置不能生效。 折腾了很久后发现，只能用 Google fonts 网站下载的字体文件才可以。 这个 Google fonts网站真的良心，秒杀国内一众广告字体网站。<br>打开网站，语言选择中文简体，我用的 MaShanZheng 这个字体。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f61b35846239ff3eb82a36c07a7e0e7.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><p>文件下载好后，放在 obsidian 任意文件夹下，最好放在Excaildraw 相关文件，便于管理，文件夹命名为 Fonts，obsidian 会自动识别字体。</p><h2 id="修改-excaildraw-设置"><a href="#修改-excaildraw-设置" class="headerlink" title="修改 excaildraw 设置"></a>修改 excaildraw 设置</h2><p>重启 obsidian，打开设置-第三方插件 excalidraw-非 excalildraw 官方支持的特性-自定义字体-开启自定义-选择字体。如果没有看到字体则重启 obsidian</p><p><img src="https://img-blog.csdnimg.cn/img_convert/271ff7c764d3757a3f852a6522d30e4f.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑<br>成功。文字元素会对一些功能，可以选择本地字体。<br><img src="https://img-blog.csdnimg.cn/img_convert/c4d8e2d61e872494e1779bae876f70f0.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动"><br>结果：<br><img src="https://img-blog.csdnimg.cn/img_convert/d72dfdf7238ae5b7d6fec3e3da106daf.png" alt="image.png">​</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>obsidian</tag>
      
      <tag>excaildraw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown 文件渲染工具推荐 obsidian publish</title>
    <link href="/2024/05/24/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/markdown%20%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%20obsidian%20publish/"/>
    <url>/2024/05/24/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/markdown%20%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%20obsidian%20publish/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> Markdown 是一种轻量级的标记语言，最开始使用它是觉得码字非常方便，从一开始的 word 排版到 markdown ，还不太不习惯，用了 obsidian 把一些文字发在网上后，才逐渐发现他的厉害之处。</p><ol><li>让人更加专注于内容本身，markdown 可以轻松转为 HTML，意味着可以直接生成博客。</li><li>可以配置元数据，无缝对接博客设置标签</li><li>跨平台、易学习，版本控制优化，利用 Git 等版本控制系统，能有效地追踪和管理文档变更。</li><li>Markdown 可以直接转为带有 css 格式的文字，可以直接复制粘贴就是一篇排版精美的文字。也就是今天要推荐的工具。</li><li>很多社区、笔记软件都支持 markdown，意味着你的笔记可以任意迁移，任意传播，不需要多次修改格式。</li><li>有了 markdown 和码字工具 obsidian，那么就可以建立一个丝滑的工作流。</li></ol><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>![[写作流程]]<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405242138321.png" alt="image.png"></p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><p>要实现快速丝滑的发表在各个平台上，之前都是直接复制 markdown 源码，这也是我喜欢发 CSDN 的原因。<br>近来开了个公众号，才发现，公众号的编辑器是真的拉胯，居然衍生了诸如 96 编辑器、秀米、135 编辑器等诸多编辑器工具，编辑格式费时、费力，违背了重视内容的初衷。</p><p>可总有前辈做了改变的工作，一开始尝试了 B 站大佬孙博士研究所的 obsidian 插件。</p><p><a href="https://github.com/sunbooshi/note-to-mp">https://github.com/sunbooshi/note-to-mp</a></p><p>存在 2 个问题，一是代码超过 10 条数字就异常，二是复制进入公众号后，页面会很窄。</p><p>通过查找，发现了今天的主角。<br><a href="https://md.openwrite.cn/">微信 Markdown 编辑器 (openwrite.cn)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405242146512.png" alt="image.png"></p><p>该编辑器支持 Markdown 语法，实时预览，支持代码高亮，自带样式效果已经够用。</p><p>希望对你有所帮助，通过这些工具建立自己的写作工作流。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QGIS DEM数据快速获取</title>
    <link href="/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/QGIS%20DEM%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96/"/>
    <url>/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/QGIS%20DEM%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Dem 是非常重要的数据，30 m 的精度也是最容易获取的，目前有很多种方式可以获取，比如地理空间数据云，今天介绍用 QGIS插件获取。<br>这种方式的最大优势是方便快捷，当我们有评价区域范围图层时，更加方便。</p><h2 id="插件下载与安装"><a href="#插件下载与安装" class="headerlink" title="插件下载与安装"></a>插件下载与安装</h2><p>插件-管理并安装插件-搜索下载<br>OpenTopography DEM Downloader<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221855383.png" alt="image.png"></p><p>注册账号并获取 key<br>操作非常简单，没有限制，国内能访问，但有点慢。<br><a href="https://portal.opentopography.org/myopentopo">myOpenTopo Workbench (opentopography.org)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221845374.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221844472.png" alt="image.png"></p><h2 id="下载-dem"><a href="#下载-dem" class="headerlink" title="下载 dem"></a>下载 dem</h2><p>选着你要下载的区域，点击插件图标<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221846162.png" alt="image.png"><br>选择 dem 类型，推荐 30 m，选择下载范围，然后输入 key，就可以了。<br>选择下载方式可以通过图层、显示范围及手动画范围等三种方式。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221848829.png" alt="image.png"></p><p>成功，注意网站下载的默认是 wgs 84 坐标系，其他坐标系需要自己转换。<br>下载后导入 ArcGIS 使用时，需要定义坐标系。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221850911.png" alt="image.png"></p><p>转换投影建议在 ArcGIS 中操作<br>搜索投影栅格，选择合适的投影坐标系即可。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406181607135.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水文分析</tag>
      
      <tag>arcgis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解ArcGIS 水文分析模型构建</title>
    <link href="/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%20%E6%B0%B4%E6%96%87%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/"/>
    <url>/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%20%E6%B0%B4%E6%96%87%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在地理信息系统（GIS）领域，水文分析是一项至关重要的任务，它涉及到对地表水流动路径、河流网络、流域划分等关键水文特征分析。这些分析对于水资源管理、洪水预警、环境规划以及城市排水系统设计等众多领域都具有重要的应用价值。</p><p>本文旨在探讨ArcGIS中水文分析的全过程，并展示如何构建一个可复用的水文分析模型。通过本文的学习和实践，读者将能够深入了解ArcGIS在水文分析方面的应用，掌握从数据预处理到模型构建、从模型运行到结果输出的整个流程。此外，本文还将介绍如何将ArcGIS模型脚本化，以提高模型的复用性和自动化程度。</p><p>在接下来的章节中，我们将详细介绍水文分析的各个步骤，包括资料背景的准备、操作中可能出现的问题及注意事项、分析框架的梳理、水文模型的搭建、模型思维和图形化界面的构建等。通过这些内容的学习，读者将能够全面掌握 ArcGIS 水文分析的相关知识和技能。</p><h2 id="项目环境、条件"><a href="#项目环境、条件" class="headerlink" title="项目环境、条件"></a>项目环境、条件</h2><ul><li>ArcGIS 10.8 中文包</li><li>已开启 Spatial Analyst Tools 分析工具</li><li>Win 10<br>理论上 ArcGIS 10.2 也几乎一样，部分工具可能由翻译问题，建议初学者完全按照本文的文档结构进行。</li></ul><h2 id="Dem-数据预览"><a href="#Dem-数据预览" class="headerlink" title="Dem 数据预览"></a>Dem 数据预览</h2><p> <strong>DEM</strong>（Digital Elevation Model，数字高程模型）是一种用于表示地表地形起伏的数字模型。它通过规则格网的矩阵形式，记录每个格网单元的高程值，从而在计算机中构建出地形的三维模型。DEM 是地理信息系统（GIS）中重要的空间数据类型之一，广泛应用于地形分析、水文模拟、城市规划、地质灾害评估等多个领域。<br> Dem 可以通过地理空间数据云、QGIS 插件、CAD 地形文件生产等多种方式获取。此前有介绍，本文不多赘述。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221924998.png" alt="image.png"></p><h2 id="ArcGIS模型构建器"><a href="#ArcGIS模型构建器" class="headerlink" title="ArcGIS模型构建器"></a>ArcGIS模型构建器</h2><p><strong>ArcGIS模型构建器</strong>是Esri公司开发的ArcGIS软件中的一个强大工具，它允许用户通过图形化界面来创建、编辑和运行一系列自动化的GIS分析模型。模型构建器的核心优势在于能够将复杂的GIS分析流程简化为一系列可视化的步骤，使得用户无需编写代码即可完成复杂的空间分析任务。<br>可以在空白文件夹下，点击按钮打开，也可以在文件夹内，右键打开。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231055335.png" alt="image.png"><br>建议像笔者一样，建立好文件夹框架，依次新建文件数据库-工具集-模型。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231057487.png" alt="image.png"><br>在模型构建器中，数据类型如下，本文将用到项目数据、工具、派生数据和值等类型。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231059219.png" alt="image.png"><br>将数据、工具等可以直接拖入模型界面中，非常方便。</p><h2 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h2><h3 id="填洼"><a href="#填洼" class="headerlink" title="填洼"></a>填洼</h3><p>dem-填洼-fill<br><strong>填洼</strong>（Fill）是去除 dem 中的洼地（sinks）或凹陷（depressions）。这些洼地在地形分析中可能会导致错误的水流方向和流域划分，需要通过填洼操作来纠正。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221609608.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221926917.png" alt="image.png"></p><h3 id="流向"><a href="#流向" class="headerlink" title="流向"></a>流向</h3><p>fill-流向-FlowDirection<br>注意选着 fill 时需要选择蓝色循环的那个，为变量值。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221614049.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221618226.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221930624.png" alt="image.png"></p><h3 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h3><p>FlowDirection-流量-fillacc<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221620132.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221620254.png" alt="image.png"><br>根据栅格数值大小隐约能看出河流的线条。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221934241.png" alt="image.png"><br>点击栅格可以查询该处的数值，通过这种方法判断最小径流的值，后面有用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221937003.png" alt="image.png"></p><h3 id="河流长度"><a href="#河流长度" class="headerlink" title="河流长度"></a>河流长度</h3><p>FlowDirection-河流长度-flowlength 测量方向选择 upstream，<br>水流长度工具的主要用途是计算给定盆地内最长水流的长度。该度量值常用于计算盆地的聚集时间。这可使用 UPSTREAM 选项来完成。该工具也可通过将权重栅格用作下坡运动的阻抗，来创建假设降雨和径流事件的距离-面积图。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221949623.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230838124.png" alt="image.png"></p><h3 id="栅格计算器"><a href="#栅格计算器" class="headerlink" title="栅格计算器"></a>栅格计算器</h3><p>栅格计算器 或者条件函数<br>栅格计算器（Raster Calculator）  条件函数 Con(FlowAccu&gt;R,1)<br>目的是将流量栅格数据中提取河流的部分，公式为”flowacc” &gt;&#x3D; 1000。<br>在模型构建器中使用左右%代表变量。新增一个变量，作为流量限值 R，建议通过流量栅格 (flowacc), 点击查询河流的最小栅格，我这里根据实际情况，选择输入 1000。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230842687.png" alt="image.png"></p><p>具体公式以自己实验为准，添加变量后，修改为”%fillacc%” &gt;&#x3D;  “%任意值%”<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221641559.png" alt="image.png"><br>记得点击任意值，添加 1000，这样以后只需要修改这个值，就可以调整河流长度了。<br>Acc 1000 结果，可见满足条件的，也就是河流为 1，不满足的为 0.<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230854890.png" alt="image.png"></p><h3 id="河流链接"><a href="#河流链接" class="headerlink" title="河流链接"></a>河流链接</h3><p>acc1000+FlowDirection&#x3D;Streamlink<br>by 河流链接<br>河流链接的作用有：<strong>构建连续的河流网络</strong>：河流链接工具能够识别并连接相邻的河流段，确保河流网络在空间上是连贯和正确的。<strong>分配唯一标识符</strong>：给河流网络中的每个部分分配唯一的 ID，便于管理和进一步分析。这有助于区分不同的河流分支和主流，以及分析它们各自的属性（如流量、长度等）。<strong>优化数据结构</strong>，减少在模型中处理大量独立线段时的复杂性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221642956.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230924178.png" alt="image.png"></p><h3 id="河网分级"><a href="#河网分级" class="headerlink" title="河网分级"></a>河网分级</h3><p>acc1000+FlowDirection&#x3D;StreamOrder<br>by 河网分级<br>河网结构用于识别河流上下级，常见的河网分级方法有斯特拉勒（Strahler）、希科特（Horton）和谢内（Shreve）等。斯特拉勒法是最常用的，它基于河流交汇规则来分配等级，即每次支流汇入时，如果两支流的等级相同，则合并后的河段等级加1；如果不同，则高等级保持不变。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221635748.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230928380.png" alt="image.png"></p><h3 id="栅格河网矢量化"><a href="#栅格河网矢量化" class="headerlink" title="栅格河网矢量化"></a>栅格河网矢量化</h3><p>StreamOrder+FlowDirection&#x3D;StreamOrder1000<br>by 栅格河网矢量化<br>顾名思义，栅格河网矢量化就是将河流网络的栅格数据转换成矢量数据格式，便于分析、可视化及水文建模应用。注意如果要增加河流长度等字段，需要在投影坐标系下进行。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221824966.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230932035.png" alt="image.png"></p><h3 id="绘制倾泻点"><a href="#绘制倾泻点" class="headerlink" title="绘制倾泻点"></a>绘制倾泻点</h3><p>StreamOrder 1000+end&#x3D;FeatureVert_1000<br>By要素折点转点<br><strong>倾泻点</strong>是指汇流区域中具有最低高程的边界象元。它标志着水从一个流域流向另一个流域的出口点，或者是水流离开一个封闭流域（如盆地）的地点。<br>可以通过要素折点转点生成，也可以根据自己手工增加，形式是一些离散的点。<br>要素折点转点，顾名思义，指通过矢量线的折点或转点然后生成点，有 all、mindle、end、start、both_ends、dangle（悬挂点，指离散点） 等类型，绘制倾泻选择 end 。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221825292.png" alt="image.png"><br>倾泻点非常关键，是汇水区分析的重要参数，除了自动生成的点外，可以根据实际需要，添加、删除点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230948266.png" alt="河流与倾泻点"></p><h3 id="栅格流域提取"><a href="#栅格流域提取" class="headerlink" title="栅格流域提取"></a>栅格流域提取</h3><h6 id="集水区"><a href="#集水区" class="headerlink" title="集水区"></a>集水区</h6><p>集水区也就是分水岭，根据流向和倾泻点一起做的汇水范围。有倾泻点的会比盆域分析更细，他与倾泻点的点位有很大关系。<br>FlowDirection+FeatureVert_1000&#x3D;倾泻点字段为空&#x3D;watersh</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221645662.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230956061.png" alt="image.png"></p><h4 id="盆域分析"><a href="#盆域分析" class="headerlink" title="盆域分析"></a>盆域分析</h4><p>流向 FlowDirection 盆域分析&#x3D; basin<br>盆域分析，也就是流域分析，可以理解为没有倾泻点的大范围流域分析。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221647107.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230957148.png" alt="image.png"></p><p>运行模型-成功<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221731875.png" alt="image.png"></p><h3 id="栅格转面"><a href="#栅格转面" class="headerlink" title="栅格转面"></a>栅格转面</h3><p>上述流域栅格，转为矢量图层。用于可视化和计算，作用与栅格河网矢量化类似。<br> basin&#x2F;watersh 栅格转面 RasterT_basin &#x2F;RasterT_watersh</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221727096.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230955132.png" alt="子流域范围.png"></p><p>至此，水文分析基本结束。<br>调试模型，运行成功。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221742623.png" alt="image.png"></p><p>调整模型架构，让连接线不交叉。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231005860.png" alt="image.png"></p><h2 id="模型应用"><a href="#模型应用" class="headerlink" title="模型应用"></a>模型应用</h2><h3 id="导出-py-文件"><a href="#导出-py-文件" class="headerlink" title="导出 py 文件"></a>导出 py 文件</h3><p>可以导出 py 文件，进行模型复用。在 ArcGIS 环境中导入脚本，注意导入前修改绝对地址注意保持一致。另外它基于 ArcPy 模块，一个专为 ArcGIS 设计的空间分析和数据处理库。因此，它的运行环境依赖于 ArcGIS，使用 ArcGIS Python 2.X 环境编写的。不能用于 python 3 中。<br>经过测试，代码并不能直接使用，需要重新编译后才能使用，后续会出一期 python 水文分析的文章。</p><h3 id="完善脚本"><a href="#完善脚本" class="headerlink" title="完善脚本"></a>完善脚本</h3><ol><li>将 dem 输入变为变量，方法为新增变量-栅格数据集，然后选择对应的 dem 位置。</li><li>重命名，将 dem 命名为输入 dem。双精度命名为输入流量下限值。</li><li>完善模型参数，模型-模型属性-参数将输入 dem、输入流量下限值作为必填项</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231021444.png" alt="image.png"></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>点击模型打开，输入 dem 和下限值，点击运行。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231038360.png" alt="1716431898456.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231039764.png" alt="image.png"><br>运行成功，结果输出在模型内指定的文件夹。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231040644.png" alt="image.png"><br>重新运行将会替换结果文件，运行一次后，结果移动出来，再次使用。总之，非常方便。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文通过详细探讨ArcGIS水文分析的全过程，不仅展示了如何利用ArcGIS模型构建器来创建一个高效、可复用的水文分析模型，还深入介绍了模型构建器的图形化界面和强大功能。通过本文的学习，读者可以清晰地看到，即使是GIS编程新手，也能通过模型构建器实现复杂的空间分析任务，而无需深入代码层面。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>水文分析</tag>
      
      <tag>arcgis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝藏网站推荐-封面图片生成器</title>
    <link href="/2024/05/21/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2024/05/21/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />  <p>封面图片生成器：<a href="https://spacexcode.com/coverview">封面图生成器 | 太空编程 (spacexcode.com)</a><br>最近爱上了写文案，在网上冲浪的时候发现一个宝藏网站。Spacecode，一个大神维护的个人网站，含有前端知识库、个人博客及他做的开源项目。<br>其中封面图片生成器简单好用，完全免费，自来水一下。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211851977.png" alt="image.png"><br>其他作品，如毛玻璃效果生成器、代码图片生成器、文字卡片等等，都非常棒。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211852301.png" alt="image.png"><br>作者项目做的很好，从他的简介也可以看出，是个很棒的家伙，向他学习。Build in public，learn in public。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 CAD 到 ArcGIS：高精度DEM 数字高程文件生成</title>
    <link href="/2024/05/21/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%E5%AF%BC%E5%85%A5autoCAD%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%95%B4%E7%90%86/"/>
    <url>/2024/05/21/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%E5%AF%BC%E5%85%A5autoCAD%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常工作中，我们常需要对特定区域地形进行深入分析。易于获得的地形数据为 30 m 精度，有时无法满足项目要求，需要更高精度的地形资料，而这些资料通常以 AutoCAD 文件的形式存在。<br>这些数据需经过 GIS 系统处理，以生成所需的 dem 数据。本篇文章将循序渐进，从 CAD 地形图层常用名称开始，详尽阐述在 ArcGIS 平台上，如何处理 AutoCAD 地形文件，最终产出高精度的 DEM（数字高程模型），希望对你有所帮助。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="DEM"><a href="#DEM" class="headerlink" title="DEM"></a>DEM</h3><p><strong>DEM（Digital Elevation Model）</strong>：即数字高程模型，是通过有限的地形高程数据实现对地面地形的数字化模拟。是数字地形模型（Digital Terrain Model，简称 DTM）的一个分支。狭义的 dem 是栅格数据，在水文分析中，dem 数据可以用来生成坡向、坡度、水系、分水岭、泄水点等信息。</p><h3 id="TIN"><a href="#TIN" class="headerlink" title="TIN"></a>TIN</h3><p><strong>TIN（Triangular Irregular Network）</strong>：即不规则三角网，是基于矢量的数字地理数据的一种形式，通过将一系列折点组成的三角形来构建。各折点通过由一系列边进行连接，最终形成一个三角网。TIN 是一种更为精细的表示方法，适用于复杂地形的精确表示和分析。</p><h3 id="CAD-图层常用名称"><a href="#CAD-图层常用名称" class="headerlink" title="CAD 图层常用名称"></a>CAD 图层常用名称</h3><p>以下是常用的 CAD 地形图常用图层名称。</p><ol><li>DGX–等高线</li><li>DLSS–道路设施</li><li>DLDW–独立地物</li><li>DMTZ–地貌特征</li><li>GCD–高程点</li><li>JMD–居民地</li><li>SXSS–水系设施</li><li>ZBTZ–植被特征</li><li>GXYZ–管线设施</li><li>TK–图框</li></ol><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>新建 ArcGIS 项目，不要在已有坐标系的文件中添加。<br>在导入前，设置好坐标系，这需要问资料来源方。<br>右键-属性-常规-编辑，选择合适的坐标系。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211514712.png" alt="image.png"><br>将 CAD 文件拖入 ArcGIS。</p><h3 id="确定要保留的图层"><a href="#确定要保留的图层" class="headerlink" title="确定要保留的图层"></a>确定要保留的图层</h3><p>导入 CAD 文件后，会发现有很多文件，<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211516876.png" alt="image.png"><br>分别为：</p><ul><li>Annotation 注释</li><li>Point 点</li><li>Polyline 多段线</li><li>Polygon 多边形</li><li>MultiPatch 3 D 几何图形<br>一般需要关注的是 Polyline 、Point、Polygon 根据自己的需要整理对应的数据。地形数据在 Polyline 中，通过查询工具，点击对应的图层可以查询其图层名称。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211526491.png" alt="image.png"><br>比如，地形图层为 DGX。<br>右键 Polyline-属性-绘制图层-选择 DGX。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211528230.png" alt="image.png"><br>右键 Polyline-打开属性表-点击表选项-按属性选择, 输入表达式<br>“Elevation” &gt;0，可根据自己的文件属性，定义筛选表达式。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211531228.png" alt="image.png"><br>导出数据，右键 Polyline-数据-导出数据，导出所选要素。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211534372.png" alt="image.png"><br>可以用同样的方法将需要的图层导出 GIS 图层数据。<br>如地貌特征（DMTZ） 、水系设施（SXSS）、居民地（JMD）、道路设施（DLSS）等, 选择不同的图层时，记得提前在显示区域右键-清楚所选区域。<br>在本文示例文件中，因为是农业区域地貌特征和等高线都有高程信息，为提高精度，将两者合并导出图层精细分析。</p><h3 id="创建-TIN"><a href="#创建-TIN" class="headerlink" title="创建 TIN"></a>创建 TIN</h3><p>工具搜索-创建 TIN，高度字段输入 Elevation，注意在创建之前，最好打开属性表，观察 Elevation 值的范围，从 CAD 导入的数据可能存在异常。因此需要用前面表达式筛选的方式，选择合适的等高线范围。例如本示例需要将 Elevation 控制在 0-500 之间，500 以上的异常值去掉。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211629026.png" alt="image.png"><br>点击属性-符号系统选择分区及配色。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211647927.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211707784.png" alt="image.png"></p><h3 id="TIN-转-dem"><a href="#TIN-转-dem" class="headerlink" title="TIN 转 dem"></a>TIN 转 dem</h3><p>使用 TIN 转栅格工具，转出的数据就是我们需要的 dem 数据。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211711236.png" alt="image.png"><br>得到区域 dem 数据如下，完成。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211711285.png" alt="image.png"></p><p>用查询工具点击 dem 可得到精度信息。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211717057.png" alt="image.png"></p><p>有了 dem 数据，我们就能做很多工作了，如水文分析的河流水系、坡度、坡向、产流量、河流链接、分水岭、流域等等。后续也会整理 dem 水文分析的操作步骤。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>本方法实际精度与 DWG 文件质量关系很大，例如示例文件中，由于地貌特征图层文件，大部分高指为 0，无法参与 dem 结果生成，降低了最终生成文件的效果。若深入探究，还可以用克里金插值等方法，提高精度。<br>总之，以上就是用 CAD 文件生产 DEM 的过程，如果有帮助到你，请点赞关注。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>水文分析</tag>
      
      <tag>arcgis</tag>
      
      <tag>地形数据</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡片笔记写作法 精读笔记 02</title>
    <link href="/2024/05/20/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2002/"/>
    <url>/2024/05/20/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2002/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405271919838.png" alt="image.png"></p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 卡片笔记写作法：如何实现从阅读到写作</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/15/YueWen_39136896/t7_YueWen_39136896.jpg" alt=" 卡片笔记写作法：如何实现从阅读到写作|200"></li><li>书名： 卡片笔记写作法：如何实现从阅读到写作</li><li>作者： 申克·阿伦斯</li><li>简介： 卢曼的“盒中笔记”通常很简短，因为这些只是他庞大繁杂研究中的索引，等需要时，他会借由这些线头进行延伸思考，然后不断链接知识要点，从而形成自己的知识树。你也可以试试。</li><li>出版时间 2021-06-01 00:00:00</li><li>ISBN： 9787115564672</li><li>分类： 文学-语言文字</li><li>出版社： 人民邮电出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/3d8326d072552e803d87c41">https://weread.qq.com/web/reader/3d8326d072552e803d87c41</a></li></ul></blockquote><p>继续这本书后面的部分。</p><h3 id="关于写作，你需要具备的能力"><a href="#关于写作，你需要具备的能力" class="headerlink" title="关于写作，你需要具备的能力"></a>关于写作，你需要具备的能力</h3><p>构建一个<strong>不被干扰、专心思考的笔记系统</strong>。<br>工具箱</p><ul><li>书写工具纸、笔。</li><li>文献管理工具</li><li>卡片系统</li><li>编辑工具<br>目前用的是 obsidian、zotero，其中 obsidian 用的更频繁就是我的卡片盒。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405261639805.png" alt="我的笔记工具"></li></ul><h2 id="关于写作，你需要的注意的几个问题"><a href="#关于写作，你需要的注意的几个问题" class="headerlink" title="关于写作，你需要的注意的几个问题"></a>关于写作，你需要的注意的几个问题</h2><p>不要让卡片笔记盒，沦为思想的坟场，不要只有囤积癖，没有整理的习惯。<br>我自己深有体会，之前用印象笔记 -剪藏插件的时候，会收集很多笔记，然后再也没看过。<br>笔记系统逐渐臃肿，完全不能发挥作用。</p><h3 id="三类笔记的区别"><a href="#三类笔记的区别" class="headerlink" title="三类笔记的区别"></a>三类笔记的区别</h3><p>1.闪念笔记 (Fleeting Notes)：这类笔记只是对收集信息起提醒作用，可以用任何方式来写，最后会在一两天内被扔进垃圾桶。<br>2.永久笔记 (Permanent Notes)：这种笔记以一种永久可以理解的方式包含了必要的信息，并且永远不会被扔掉。它们总是以同样的方式存放在同一个地方，或者是在文献管理系统中，或者按出版标准写好放在卡片盒中。<br>3.项目笔记 (Project Notes)：它们只与某一特定项目有关，保存在特定项目的文件夹内，项目结束后即可丢弃或存档。只有将这三类笔记分开保存，才有可能实现卡片盒笔记的群聚效应，而对这些类别的混淆也是人们写作或发表作品不多的主要原因之一。<br>项目笔记相关内容：与项目有关的文献、大纲、草稿片段、备忘录、待办事项<br>当你结束一天的工作，你的桌面除了纸和笔，没有留下任何东西，说明你已经区分好了三种笔记类型。</p><h3 id="有效写作的四个原则"><a href="#有效写作的四个原则" class="headerlink" title="有效写作的四个原则"></a>有效写作的四个原则</h3><h4 id="写作是唯一重要的事"><a href="#写作是唯一重要的事" class="headerlink" title="写作是唯一重要的事"></a>写作是唯一重要的事</h4><p>没有私密知识，有了想法只有自己知道，就等于没有想法，无法重现的论据就算不上论据。<br>只有成果公布出来，供人阅读，才有意义。专注于写作，同时也要学习与交流。</p><h4 id="简洁是最重要的"><a href="#简洁是最重要的" class="headerlink" title="简洁是最重要的"></a>简洁是最重要的</h4><p>这里指的是卡片盒笔记系统相较于传统笔记的组织方式更简洁。区分好三类笔记，按照不同的处理方式处理，最后形成群聚效应。</p><h4 id="没有人完全从零开始写作"><a href="#没有人完全从零开始写作" class="headerlink" title="没有人完全从零开始写作"></a>没有人完全从零开始写作</h4><p>日常收集整理感兴趣的素材，形成素材库。写作是非线性的，不是自上而下的，功夫在诗外。</p><h4 id="让工作推动你前进"><a href="#让工作推动你前进" class="headerlink" title="让工作推动你前进"></a>让工作推动你前进</h4><p>建立一个良好的工作机制。让工作成为一个良性循环，热爱你从事的工作，做自己喜欢做的事情。不断的形成正反馈。这一点与最近看的&#x3D;&#x3D;《重来》（贾森、戴维）卸负篇&#x3D;&#x3D;-哪来的从错误中学习有联系，我们基本很少从失败中汲取经验，只有成功才能让我们成长。良性的正反馈，是我们不断前进的动力。这里的工作应该是广义的，做你喜欢的事，做好。<br>除了具备成长的心态外，需要周期性的给自己反馈，而不是间隔很长时间的反馈，太长时间难以坚持，短期的反馈更容易让人接受，更能加强理解和改进。</p><h2 id="成功写作的六个步骤"><a href="#成功写作的六个步骤" class="headerlink" title="成功写作的六个步骤"></a>成功写作的六个步骤</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405271912873.png" alt="image.png"></p><h3 id="明确区分独立而又相关联的任务"><a href="#明确区分独立而又相关联的任务" class="headerlink" title="明确区分独立而又相关联的任务"></a>明确区分独立而又相关联的任务</h3><p>不要一心多用<br>不同的任务需要不同的关注度，比如区分写作与校对，两者需要站在不同的角度去看待事物，校对应作为批评家，从逻辑、规范等等方面去思考文章的合理性。在不同的环节需要的关注度和耗费的精力不同。<br>结合自己的经验深有体会，我以前很难做好审稿这个角色，不光是对自己写的，还是同事写的，审查的时候总是很为难，不愿意做，也没有花更多的心思，当然做不好。<br>推而广之，精读与速读，概括与修改提纲都是需要区别对待的工作，都应该有自己的方法论，不应该因为相似就不去总结。<br>艺术和科学都需要“集中的注意力”与“漂浮的注意力”，大多数杰出的科学家也都具备切换不同注意力的能力。杰出科学家解决问题的行为可以在‘对特定概念的超常专注程度’和‘对想法的有趣探索’之间交替进行。这表明，要想成功解决问题，可能需要根据任务和需求灵活地选择应对策略。”<br>有时候我们需要天马行空，而有时候我们要细微严谨，对待不同任务要切换不同的应对策略。不要把自己局限死，以为自己不擅长，而懒得去做。</p><h4 id="做专家，不作计划制定者"><a href="#做专家，不作计划制定者" class="headerlink" title="做专家，不作计划制定者"></a>做专家，不作计划制定者</h4><p>人只有不断的实践，才能积累经验。<br><strong>德雷福斯的技能获取理论</strong>:人类在特定领域习得技能时，从低技能阶段到高技能阶段的认知转变过程，并将这个过程拆分为五个阶段：新手（Novice）、高级新手（Advanced Beginner）、胜任者（Competent）、精通者（Proficient）和专家（Expert）。<br>做详细计划是没有用的，如写什么，什么时候写，怎么写。只有在具体时间中才能形成洞见。<br>同样，&#x3D;&#x3D;《重来》（贾森、戴维）卸负篇&#x3D;&#x3D;-计划即瞎猜，也提到类似的观点，作者对长期计划是呲之以鼻的，建议最多只做周计划，长期计划只是猜想，写的越细致，越是浪费时间。</p><h4 id="写下来为大脑减负"><a href="#写下来为大脑减负" class="headerlink" title="写下来为大脑减负"></a>写下来为大脑减负</h4><p>蔡格尼克效应，即未完成的任务往往会占据我们的短期记忆，直到它们被完成。<br>GTD 的思想，也是把待办事项列出，好腾出精力，一件一件应对。<br>有了想法，或者遇到素材，立马作为笔记记录下来，随后再处理。</p><h4 id="减少做决定"><a href="#减少做决定" class="headerlink" title="减少做决定"></a>减少做决定</h4><p>一般情况下，或一个心理学猜想：我们的大脑存在以下局限性：</p><ol><li>一次只能专注的做一件事。</li><li>一次只能容纳七件事的短期记忆（我感觉我都记不住 7 件）。</li><li>驱动力及意志力有限，再次回复需要时间和休息（类似能量槽）。<br>为了节约有限的意志力资源，我们需要减少做决定，比如少在工具、形式上纠结，专注于记笔记本身。重点放在文章中什么更重要、什么不重要，判断笔记之间的联系，设计文本的结构等难点上。<br>推而广之，对于日常也是，减少对非核心问题的纠结与内耗。<br>休息不仅有助于恢复精力，也对学习至关重要，休息可以让大脑处理信息并将其移入长期记忆，从而可以接受新信息。散散步，甚至打个盹儿，都有助于学习和思考。</li></ol><h3 id="阅读和理解"><a href="#阅读和理解" class="headerlink" title="阅读和理解"></a>阅读和理解</h3><blockquote><p>阅读和理解“我建议你在阅读时手里拿支笔，在小本子上记下你觉得常见的或可能有用的简短提示，因为这将是把这种痕迹印在你的记忆中的最好方法。”——本杰明·富兰克林</p></blockquote><p><strong>好记性不如烂笔头，不记录和整理，任何想法都很快会消失，难以找寻和回溯。</strong></p><h4 id="阅读时要有笔"><a href="#阅读时要有笔" class="headerlink" title="阅读时要有笔"></a>阅读时要有笔</h4><p>如何阅读文献，摘录文件内容时，表明出处，并用自己的语句阐述上下文。<br>根据文献的复杂程度，笔记也要有区分，简单的内容只需要用关键词备注即可，复杂的需要结合上下文尽可能记录清楚。这是一个锻炼自己提炼信息能力的机会。<br>文献笔记的目的是为了变成永久笔记。<br>目前的工作流是通过 zotero 、微信读书结合 obsidian，作为论文、书籍的文献笔记记录方式。<br>在文献上标注、划线等先做文献笔记，然后整理为永久笔记。<br>文献笔记形式不重要，适合自己的即可，文献笔记应该简短、流畅，形式不应太复杂，而分散注意力。<br>重点在文献笔记转换为永久笔记的过程。</p><blockquote><p>如果你说不清楚，就表示你自己也不明白。——John Searle</p></blockquote><h4 id="保持开放的心态"><a href="#保持开放的心态" class="headerlink" title="保持开放的心态"></a>保持开放的心态</h4><p>确认偏差：指人们在处理信息时倾向于寻找、解释、记忆和重视与自己已有信念或假设相一致的信息，而忽略或轻视与之相矛盾的信息。这种偏差会导致人们在决策和评估信息时，无意识地保持自己的先入之见，从而影响客观判断。<br>确实我们很容易掉入这种认知错误中去，总带着一个预设的答案去寻找答案，固执己见、刚愎自用，都是这样的形成的。<br>保持开放的心态，是分析和学习的重要基调，广泛的收集意见（相关的或者矛盾的），审慎的考虑，避免掉入确认偏差，也不要沉浸信息茧房，多与他人讨论学习，认真倾听。<br>知难行易，认识到这个问题已经很重要了。</p><h4 id="推动项目进展的步骤"><a href="#推动项目进展的步骤" class="headerlink" title="推动项目进展的步骤"></a>推动项目进展的步骤</h4><ul><li>确认是否已分解任务，专注于理解阅读的文本或者课程讲解</li><li>为阅读理解的内容做好笔记</li><li>找到笔记的关联，并建立联系<br>我们对将要添加笔记盒的内容无法提前预知，只需要添加相关联的内容，并把他们串联起来就好。</li></ul><h3 id="培养抓住重点的能力"><a href="#培养抓住重点的能力" class="headerlink" title="培养抓住重点的能力"></a>培养抓住重点的能力</h3><blockquote><p>那些拥有大量思考工具并知道如何应用的人是拥有“普世智慧”的人。——查理芒格</p></blockquote><blockquote><p>“阅读学术文章的困难似乎在于短期记忆对我们没有帮助，我们需要长期记忆来提供参考资料，帮助我们区分什么事情重要、什么事情不重要，哪些信息是新的、哪些信息是重复的。但是除非死记硬背，不然我们不可能记住所有的东西。换句话说，我们必须在阅读方面有非常好的选择能力，并能够提取广泛且有联系的参考资料，必须能够跟踪反复出现的问题。只是，如果没有指导，那该如何掌握这样的能力呢？最好的方法可能不是摘录，而是做笔记，就是对所阅读的文本进行浓缩重写。对所阅读的材料进行重写，能够自动地训练人们把注意力转移到文本的框架、模式和类别中来，或者是转移到文本的条件或假设上面，注意到这些以后，你的表述就会变得与之前不同。有效的办法是在阅读过程中时刻谨记以下问题：当文章中提出某个主张时，作者想要说明的是什么，想要排除的又是什么？比如有人提到了‘人权’，他要对比的是什么？是‘没有人权’？还是‘义务’？是一种文化的对比？还是与历史上的那些没有人权概念却依然能和平相处的人们对比？对于这个问题，往往难以从文本中找到直接或明确的答案，只能依靠读者自己的理解。”——卢曼</p></blockquote><p>写作的目标：言简意赅、表达清晰、切中要害。辨别模式、质疑所用框架，并发现不同作品间差异的能力，是进行批判性思考并审视文本或谈话背后观点的先决条件。能够对问题、论断和信息进行重新构架，甚至比拥有广博的学识更重要，因为如果没有这种能力，我们就无法将知识用于实践。<br>只有刻意练习才能达到，快速抓住重点的能力，只有一篇篇笔记被记录，并进行总结和练习，才能逐渐形成这种能力。</p><h3 id="在阅读中学习"><a href="#在阅读中学习" class="headerlink" title="在阅读中学习"></a>在阅读中学习</h3><blockquote><p>只有去做才能学。——泰利·道尔</p></blockquote><p>自己制作大纲，思维导图，不要过分依赖别人总结好的内容，因为这部分工作正是学习的过程。<br>在学习过程中适当增加难度，如增加测试，情景练习，讲解输出等，反而有助于学习，单纯的重复阅读没有任何意义。提取强度比存储强度更有重要，以用促学，以教促学，与费曼学习法相通。<br>回顾毕业后的学习，很多时候真的是假学习，没有记录，没有练习，没有实践，纯粹浪费时间，没有思考的学习是无效的。</p><h2 id="记卡片笔记-养成习惯"><a href="#记卡片笔记-养成习惯" class="headerlink" title="记卡片笔记&#x2F;养成习惯"></a>记卡片笔记&#x2F;养成习惯</h2><h3 id="坚持每天记几条笔记"><a href="#坚持每天记几条笔记" class="headerlink" title="坚持每天记几条笔记"></a>坚持每天记几条笔记</h3><blockquote><p>卢曼的卡片盒里大约有 9 万条笔记，听起来是一个非常庞大的数字，但这仅仅意味着，从他开始使用卡片盒进行工作的那天起，直到他去世，每天也只要写 6 条笔记。</p></blockquote><p>养成记笔记的习惯，养成思考的习惯，相信时间的力量。<br>我计划在 CSDN 、公众号上发表永久笔记，每周 5 篇左右，至少2 篇有深度的文章，3 篇分享工作经验和工具推荐。</p><h3 id="在大脑之外思考"><a href="#在大脑之外思考" class="headerlink" title="在大脑之外思考"></a>在大脑之外思考</h3><p>没有作品是完全复制脑海中的想法形成的，需要转化，从一个语境到另外一个语境，从一种形式到另外一种形式。</p><blockquote><p>将想法写下来，再思考的意义在于，只有在书面形式下，我们才能以一定的距离从字面意思上看待一个论点。我们需要这种距离来思考一个论点，否则，论点本身就会占据我们审视论点所需要的心理资源。</p></blockquote><p>写作的过程就是一个审视想法的过程，有时候有一个想法觉得很好，很兴奋，但当我们实际整理的时候，却发现有很多不成熟的，矛盾的地方，写下来不仅是固定我们飘忽的想法，是让我们在大脑之外思考，更加平和的面对自己的想法，更关心执行。</p><blockquote><p>大脑是“一台能跳跃式得出结论的机器”——丹尼尔·卡尼曼</p></blockquote><h2 id="发展想法"><a href="#发展想法" class="headerlink" title="发展想法"></a>发展想法</h2><p>松散的记录，提纲挈领的总结，根据笔记内容设定主题，以笔记为参考网格，不断联系、丰富和完善。<br>笔记的集合会从复杂逐渐变成有秩序的。<br>谨慎的设置关键词和分类，定期回顾，建立索引，建立文件之间的链接。<br>比较、纠正和区分笔记。审视旧笔记本，有助于我们发展新的想法，纠正曾经错误的想法，事物总在不断发展和进步，以前的笔记很多时候错漏的，需要纠正并建立新的想法。<br>将卡片盒作为思考的工具箱<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405262139869.png" alt="有联系的笔记系统"></p><h2 id="分享你的洞见"><a href="#分享你的洞见" class="headerlink" title="分享你的洞见"></a>分享你的洞见</h2><p>放弃头脑风暴，从笔记中寻找灵感，在兴趣的驱动下完成任务，在完稿后反复修改自己的作品，并分享你的洞见。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>免费图片素材网站推荐</title>
    <link href="/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="免费图片素材网站推荐"><a href="#免费图片素材网站推荐" class="headerlink" title="免费图片素材网站推荐"></a>免费图片素材网站推荐</h2><p>最近在找一些免费的图片素材，收集整理如下：</p><ul><li><a href="https://wallpaperhub.app/">https://wallpaperhub.app/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li><li><a href="https://www.pexels.com/">https://www.pexels.com/</a></li><li><a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></li></ul><p><strong>注意：如果要自己用最好是选择明确标注免费的图片。</strong></p><h3 id="wallpaperhub"><a href="#wallpaperhub" class="headerlink" title="wallpaperhub"></a>wallpaperhub</h3><p>支持不同尺寸下载</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192108439.png" alt="网站截图"></p><h3 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a>Unsplash</h3><p>下载速度快，包括照片、矢量图、图集等。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192116523.png" alt="网站截图"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192113133.jpg" alt="andrew-small-EfhCUc_fjrU-unsplash.jpg"></p><h2 id="Pexels"><a href="#Pexels" class="headerlink" title="Pexels"></a>Pexels</h2><p>中规中矩，下载速度较慢。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192119347.png" alt="image.png"></p><h3 id="Pixabay"><a href="#Pixabay" class="headerlink" title="Pixabay"></a>Pixabay</h3><p>加载较慢，支持不同尺寸下载，但是直接点下载并没有反应…<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192124520.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192129471.webp" alt="多彩窗户.webp"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后，如果这篇文章有帮助到你，记得收藏。<br>也欢迎关注我的个人微信公众号：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192215003.jpg" alt="qrcode_for_me.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
      <tag>素材</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGLM 智能体 搭建属于自己的AI知识库</title>
    <link href="/2024/05/19/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/ChatGLM%20%E6%99%BA%E8%83%BD%E4%BD%93%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84AI%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <url>/2024/05/19/06%20%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/ChatGLM%20%E6%99%BA%E8%83%BD%E4%BD%93%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84AI%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看一本书《在线》，将所有数据都需要在线，才有生命力，那么我们的知识库也是。我们现在就可以用先进的大预言模型搭建属于自己的在线 AI 知识库，他就是 ChatGLM 智谱清言智能体。<br>它可以将自己的知识库与 ChatGLM 结合，成为某一方面的专业知识问答系统。当然，市面上有很多类似解决方案，但是智谱清言是我试过国内最好用的一个产品，整体知识库最多免费支持1000个文件（每个100MB），知识库总字数不超过1亿字。完全够用了，而且具备联网功能。</p><p>本文以搭建水文分析智能体为例，讲解如何快速搭建智能体。</p><h2 id="创建智能体"><a href="#创建智能体" class="headerlink" title="创建智能体"></a>创建智能体</h2><p>进入智谱清言，点击创建智能体。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122102223.png" alt="image.png"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>名称：简介、开场白随便填。<br>配置信息按照需求填，我的水质分析内容如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122104516.png" alt="image.png"><br>推荐问题随便填。<br>模型调用建议全点上。<br>知识库文件最关键，建议将你本地知识库全部上传，比如平常写的分析报告，标准导则等等，互联网已经有的文件不用传，文件类型也可以是 url。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122110778.png" alt="微信截图_20240512210752.png"><br>知识库设置可以选择显示段落来源，或者仅从知识库回答。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122111537.png" alt="image.png"><br>添加 API 可以选择一些开源的 API，或者自己创建 API，这里添加了天气查询的 API。那么就能实现查询城市天气的功能。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122112037.png" alt="image.png"></p><p>最后点击发布即可，发布方式可以用邀请的方式，可以定向分享，这样你不想公开的智能体，其他人就无法访问。</p><h2 id="测试智能体"><a href="#测试智能体" class="headerlink" title="测试智能体"></a>测试智能体</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122115270.png" alt="image.png"></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>现在的 AI 发展很快，我们只有不断学习才能跟上时代的脚步，就想这个智能体功能， ChatGLM 也更新的非常快，API 功能也是最近才上线的，感觉非常好用。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AIGC</tag>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片识别公式神器推荐</title>
    <link href="/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB%E5%85%AC%E5%BC%8F%E7%A5%9E%E5%99%A8%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB%E5%85%AC%E5%BC%8F%E7%A5%9E%E5%99%A8%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>你是否遇到在某个资料上看到一个很复杂的公式，但有懒得在word 或者其他文件上打出来。<br>比如这个：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111841378.png" alt="image.png"><br>如果直接截图的话，只能说非常丑陋。</p><p>推荐一个网站 mathpix，点击 try for free，注册登录。<br><a href="https://mathpix.com/">Mathpix: AI-powered document automation</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111843929.png" alt="image.png"><br>上传图片<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111844471.png" alt="image.png"></p><p>结果非常完美，中间是预览，右侧为 Latex 代码，复制在支持 Latex 的文本编辑器（比如 obsidian），可以直接用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111845938.png" alt="image.png"><br>真香。</p><p>右边的 code 是代码在不同场景的应用，说几个常用到的。</p><ul><li>Equation LaTeX<br>  LaTeX 代码</li><li>LaTeX block math (not numbered)<br>  LaTeX 代码含块儿符号，可直接复制进 markdown 编辑器，如 obsidian</li><li>LaTeX block math (numbered)<br>  LaTeX 代码含块儿符号，可直接复制进 word</li></ul><p>另外这个网站只能免费 10 次，再推荐一个类似的网站：<br><a href="https://simpletex.cn/ai/latex_ocr">https://simpletex.cn/ai/latex_ocr</a><br>功能一样，无需登录就能使用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141338338.png" alt="image.png"></p><p>最后打个广告，我新开了微信公众号（环境猫 er），坚持发布 python 环境业务解决方案，python 办公自动化，GIS 作图经验，学习笔记，办公技巧，工具分享等内容。<br>坚持 Bulid in public ，希望与你一起加油，一同成长。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405102028570.jpg" alt="qrcode_for_gh_b2ae4cd1414a_258.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知道做到 读书笔记</title>
    <link href="/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%9F%A5%E9%81%93%E5%81%9A%E5%88%B0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%9F%A5%E9%81%93%E5%81%9A%E5%88%B0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[[知道做到：跃迁式学习]]</p><h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 知道做到：跃迁式学习</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/54/3300017554/t7_3300017554.jpg" alt=" 知道做到：跃迁式学习|200"></li><li>书名： 知道做到：跃迁式学习</li><li>作者： 彼得•霍林斯</li><li>简介： 学习是改善你的生活环境、成为你想成为的人的关键。科学的方法能加速学习进程，让你事半功倍。技能、信息和能力永远不会突然降临，需要你自己去寻找它们，这本书将手把手教你如何以效的方式做到这一点：清晰明了的学习思路，切实可行的学习建议，让你更聪明地学习，而不是更努力地学习。在本书中你将学习到：a.学习的理论和原则以及我们做错了什么；b.你的期望比你的才能更重要；c.如何制定计划，战略性地解构和分析信息、技能；d.如何在少工作的同时获得更好的结果；e.如何利用身边人和环境制造惊人的结果；f.自我练习、调整和纠正的艺术；g.如何积累你的技能，使其成为独一无二的资源。一本书带你快速训练大脑、发展肌肉记忆，了解潜在的心理学和生物学。</li><li>出版时间 </li><li>ISBN： 9787504689542</li><li>分类： 经济理财-管理</li><li>出版社： </li><li>PC 地址： <a href="https://weread.qq.com/web/reader/37032360813ab6d5bg014fdd">https://weread.qq.com/web/reader/37032360813ab6d5bg014fdd</a></li></ul></blockquote><h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>这是一本讲如何学习的书，不厚，很多老生常谈的东西，但对我有用就是好书。<br>读的过程中，我认真梳理了关于如何学习的知识，特意做了学习风格测试（所罗门-费尔德学习方式和偏好指数法）和 16 型人格测试（MBTI 测试），让我更了解自己的优缺点。人是可以改变的，所以我希望通过学习学习方法，提高自己。希望过几年测试我的状态更好。</p><h2 id="学习需要思考的内容"><a href="#学习需要思考的内容" class="headerlink" title="学习需要思考的内容"></a>学习需要思考的内容</h2><ol><li>做这件事对我有什么价值</li><li>做这件事要花费什么成本<ol><li>时间成本</li><li>金钱</li><li>投入产出比</li></ol></li><li>你想在这个领域达到怎样的效果</li><li>你有哪些可以依赖的外部资源<ol><li>[[如何利用环境]]</li><li>你没有的资源是否可以创造和争取</li></ol></li><li>你是否有这方面的天赋（一般以上）</li><li>当前的生活状态是否支持你做这项工作</li></ol><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p>再次之前我做了 2 个测试学习风格测试（所罗门-费尔德学习方式和偏好指数法）和 16 型人格测试（MBTI 测试）。我的学习风格偏好 VEPS（视觉、活跃、综合、感觉），人格为表演者-ESFP，荣格认知功能偏好为：主导功能：外倾感觉，辅助功能：内倾情感，第三功能：外倾思考，劣势功能：内倾直觉。测试结果基本符合我的状态，更倾向于外倾感觉，做事流于表面，并不深究。这对我的成长来说并不是好事，因为我也不可能真的成为一个表演者或者销售。因此我要在现有优势的基础上，不断提高自己的理性思考能力。</p><p>以下学习方法主要从书中总结，学习方法远不止于下面这些，以后会不断增加学习方法。我本人是认可费曼学习法的。</p><h3 id="学习金字塔"><a href="#学习金字塔" class="headerlink" title="学习金字塔"></a>学习金字塔</h3><p>学习金字塔理论，由美国学者、著名的学习专家爱德加·戴尔（Edgar Dale）在 1946 年提出，是一种现代学习方式的理论。该理论通过数字形式形象显示了采用不同的学习方式，学习者在两周以后还能记住内容（平均学习保持率）的多少。学习金字塔模型的核心思想在于强调不同学习活动对信息保留效率的影响，并提倡更加互动和主动的学习方法来提高学习效率和记忆持久度。这个模型通过一个逐级展示不同学习方法效果的形象金字塔，揭示了从被动接收到主动参与的学习方式对增强记忆保持的重要性。</p><p>听讲 5%<br>阅读 10%<br>视听 20%<br>演示 30%<br>讨论 50%<br>实践 75%<br>教授给他人 90%</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404121601505.png" alt="image.png"></p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>实际可能并没有那么绝对，应该是多重方法结合，知识教授他人更难，你必须掌握才能教，所以留存更长，另外一个就是坚持，反复练习。</p><h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404121708139.png" alt="image.png"></p><p>1. 选择学习目标与概念理解（Concept）<br>2. 回顾与知识梳理（Review）<br>    回顾所学内容，尝试在没有参考资料的情况下，用自己的语言和理解重新阐述该概念。<br>3. 简化与知识重构（Simplify）<br>4. 教给他人（tech）</p><h2 id="布鲁姆分类法"><a href="#布鲁姆分类法" class="headerlink" title="布鲁姆分类法"></a>布鲁姆分类法</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404121720005.png" alt="image.png"><br>类似于费曼。</p><h2 id="学习的四个具体操作方式"><a href="#学习的四个具体操作方式" class="headerlink" title="学习的四个具体操作方式"></a>学习的四个具体操作方式</h2><h3 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h3><p><strong>专注力决定信息吸收率</strong><br>刻意练习关键在于认真、<strong>专注</strong>、<strong>耐心</strong>，学习慢一点，再慢一点。<br>反复练习而不用心，也没有用，<strong>熟悉不等于掌握</strong><br>学习时，不要被既有经验束缚，以为了解就不深入学习<br>这也适用于健身</p><h4 id="真正的掌握需要不停的练习"><a href="#真正的掌握需要不停的练习" class="headerlink" title="真正的掌握需要不停的练习"></a>真正的掌握需要不停的练习</h4><p>制定 [[每日时刻表]]<br>利用零散的时间进行练习<br>番茄工作法</p><h3 id="交替练习"><a href="#交替练习" class="headerlink" title="交替练习"></a>交替练习</h3><p>将相近的知识交替学习，但要避免打断思考</p><h3 id="间隔重复"><a href="#间隔重复" class="headerlink" title="间隔重复"></a>间隔重复</h3><p>周期学习就像健身一样，每天固定时间点学习</p><h3 id="问题导向式学习法"><a href="#问题导向式学习法" class="headerlink" title="问题导向式学习法"></a>问题导向式学习法</h3><p>问题导向式学习法（Problem-based Learning，简称 PBL）<br>以解题的思路学习，可以是做项目，或者做应用题，然后向上追溯知识点<br>具体步骤：</p><ol><li>明确你的问题。</li><li>明确你已知的信息。</li><li>明确你需要但未知的内容，以及获得这些信息的途径</li><li>列出可行的解决方案，并选择成功几率最大的解决方案。</li><li>将方案<strong>分解</strong>为一个个行动（列出具体的时间计划通常很有用）。</li></ol><h2 id="学习心态调整"><a href="#学习心态调整" class="headerlink" title="学习心态调整"></a>学习心态调整</h2><h3 id="合理自我定位"><a href="#合理自我定位" class="headerlink" title="合理自我定位"></a>合理自我定位</h3><p>认识学习并不是一件简单的事，需要精心设定目标，制定计划。<br><strong>所有的半途而废，都是因为心态错位</strong><br>要乐观，但不要过于乐观<br>战略上藐视敌人，战术上重视敌人<br>饱和式打击，不作无准备之仗<br><strong>保持谦逊</strong>，stay hungry stay foolish<br>养成一个习惯需要 66 天，学习一个技能至少要 25-30 小时</p><h3 id="好奇心"><a href="#好奇心" class="headerlink" title="好奇心"></a>好奇心</h3><p>好奇心不是学习的充分条件，但是可以作为发起学习和自律力耗尽的时候拉你一把。</p><h3 id="提高困惑忍耐力"><a href="#提高困惑忍耐力" class="headerlink" title="提高困惑忍耐力"></a>提高困惑忍耐力</h3><p>当你学习越深入，不知道的越多，要提高困惑忍耐力。试着抽离出来，用全局观，或者短时间沉浸在局部利益，或者调动自己的好奇心，或者给自己打气，或者借助于朋友的宽慰，及时走出困惑沮丧的心境，重新开始学习，切记不要因此放弃当前的学习。这是你突破瓶颈的方法。</p><h2 id="深入学习的方法"><a href="#深入学习的方法" class="headerlink" title="深入学习的方法"></a>深入学习的方法</h2><h3 id="精细提问"><a href="#精细提问" class="headerlink" title="精细提问"></a>精细提问</h3><p>也可以用于讨论<br>六要素提问：who、what、where、when、why、how</p><h2 id="如何利用环境"><a href="#如何利用环境" class="headerlink" title="如何利用环境"></a>如何利用环境</h2><p>我作为一个外倾感觉型的人，非常容易受到环境的影响。<br><strong>与其挑战天性，不如利用环境最高级的自律，是让环境帮你做出正确决策</strong><br>主要是两个方面社会环境和个人环境（大环境和小环境）</p><h3 id="个体环境"><a href="#个体环境" class="headerlink" title="个体环境"></a>个体环境</h3><p>五官感受到的环境，屋子是否整齐，资料夹是否按顺序摆放等等。<br>第一，把资源放在触手可及的地方。<br>第二，把干扰因素关进另一个房间。<br>启动耗能&#x2F;活化能<br>对于较难的工作，即使切换到工作状态都耗费极大的精力。<br>主动抵御沉迷分心事物的冲动，把注意力转移到需要学习或实践的任务上。<br>《心流》（Flow）认为，这种改变环境的方法其实是改变了特定活动的“活化能”。<br>一般来说，对于心生向往的事情，你要降低活化能；对于讨厌的事情，你则要增加活化能。<br>启动学习和练习所需的活化能越少越好。<br>这本书很难做到，我目前也没有到达，只有坚持练习，希望能更丝滑的切换到工作和学习。</p><h3 id="社会环境"><a href="#社会环境" class="headerlink" title="社会环境"></a>社会环境</h3><p>朋友、社会关系<br>积极向上的氛围，相互鼓励的环境。<br>消除不良的氛围，原理刻意贬低和质疑你的人。<br>榜样的力量，向榜样学习<br>向优秀的人和群体靠拢</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡片笔记写作法 精读笔记 01</title>
    <link href="/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/"/>
    <url>/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="熟悉不等于理解"><a href="#熟悉不等于理解" class="headerlink" title="熟悉不等于理解"></a>熟悉不等于理解</h2><p><em>单纯的重复阅读没有任何意义，无论是对理解还是对学习都是如此。甚至，我们能不能将其称为“学习”都还值得商榷。</em></p><p>#感悟 熟悉不等于掌握，看书、听书、看电影、看视频都一样，看再多都没有用，包括做项目也一样，不总结没有用，就想我之前准备考试一样，不重复做题，不可以联系，不从大脑里提取是学不会知识的，学习必须动笔，必须动手。 ^9c54ce</p><h2 id="笔记的分类"><a href="#笔记的分类" class="headerlink" title="笔记的分类"></a>笔记的分类</h2><p>分为闪念笔记文献笔记和永久笔记<br>Titles： 卡片笔记写作法 精读笔记 01</p><hr><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 卡片笔记写作法：如何实现从阅读到写作</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/15/YueWen_39136896/t7_YueWen_39136896.jpg" alt=" 卡片笔记写作法：如何实现从阅读到写作|200"></li><li>书名： 卡片笔记写作法：如何实现从阅读到写作</li><li>作者： 申克·阿伦斯</li><li>简介： 卢曼的“盒中笔记”通常很简短，因为这些只是他庞大繁杂研究中的索引，等需要时，他会借由这些线头进行延伸思考，然后不断链接知识要点，从而形成自己的知识树。你也可以试试。</li><li>出版时间 2021-06-01 00:00:00</li><li>ISBN： 9787115564672</li><li>分类： 文学-语言文字</li><li>出版社： 人民邮电出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/3d8326d072552e803d87c41">https://weread.qq.com/web/reader/3d8326d072552e803d87c41</a></li></ul></blockquote><p>2024 年认真读书，第 2 本卡片笔记写作法，这本书干货很多，要分成很多期，我会慢慢整理。</p><h2 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h2><h3 id="认知与元认知"><a href="#认知与元认知" class="headerlink" title="认知与元认知"></a>认知与元认知</h3><p>认知为我们学到的内容，看到的事物；元认知是意识到我们学到的内容，看到的事物。元认知是认知的认知，就想方法论是方法的方法，有点像二阶求导。<br>在认知上层再加工，再连接，就是卡片学习法。</p><h3 id="卡片笔记的作用"><a href="#卡片笔记的作用" class="headerlink" title="卡片笔记的作用"></a>卡片笔记的作用</h3><p>增加了学习知识的效率，引出<strong>必要难度</strong>理论。<br>必要难度，人的记忆有两种机制，存储强度与提取强度，存储与提取负相关，也就是说，存入记忆越容易，提取出来越困难；反之，如果你有些吃力地存入，知识提取会更方便，越容易越难以掌握。<br>建立索引是增加必要难度的途径。<br>建立索引的理性分为</p><ol><li>主题索引</li><li>前后关联</li><li>临近关联</li><li>笔记关联<br>通过对笔记的组合、对比形成新的文章，新的见解。</li></ol><p><strong>未来已至，只是分布得不均匀。</strong></p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>高智商与成就没有决定性关系，而自律才是起最大作用的。<br>（Self-Discipline Outdoes IQ in Predicting Academic Performance of Adolescents）</p><h3 id="如何做到自律"><a href="#如何做到自律" class="headerlink" title="如何做到自律"></a>如何做到自律</h3><p>依靠意志力形成自绝没那么容易，意志力是一种有限的资源，它消耗得很快，而且从长期来看，也没有那么多手段快速提升意志力。但我们可以通过改变环境，来减少意志力的消耗。当周围没有巧克力棒的时候，自然不需要靠意志力来拒绝美食的诱惑。<br>如果一个人特别想做某件事，他也用不着靠意力去完成。长期利益和短期利益之间不存在冲突，所以每项有趣、有意义、明确的任务都会被完成，而且这样的任务每次都能比靠意志力完成得好。如果做一件事不是因为你有意志力，而是根本不需要使用意志力，那就意味着你离成功不远了。而组织写作和记笔记就能发挥这样的作用<br>所以如何做到自律，那就是把任务当作自己的兴趣，减少或者不使用意志力驱动。</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="关于写作，你需要知道的"><a href="#关于写作，你需要知道的" class="headerlink" title="关于写作，你需要知道的"></a>关于写作，你需要知道的</h3><p>邓宁—克鲁格效应 (Kruger and Dunning, 1999）成绩差但意识不到自己的不足。<br>“冒牌货综合征”，优秀的学生时常感到自己不能胜任某项工作。<br>思考：给自己清晰的定位，保持谦逊，保持好奇，要敢于去尝试，感兴趣的事情就放手去学，去做。</p><h4 id="GTD-的要义"><a href="#GTD-的要义" class="headerlink" title="GTD 的要义"></a>GTD 的要义</h4><p>戴维·艾伦 (David Allen)在《搞定》(Getting Things Done, 2001) 提出“GTD”<br>将所有要做的事情罗列出来，按照<strong>既定的方法</strong>处理，并<strong>定期回顾</strong>。</p><h4 id="GTD-的作用"><a href="#GTD-的作用" class="headerlink" title="GTD 的作用"></a>GTD 的作用</h4><p>使任务不占用心智，达到心如止水，内心平静，专注当下。提供了一种解决问题的框架，因为大多数注意力分散的情况并不是源于我们的环境，而是来自我们纷乱的想法。<br>即所谓想的太多，而做的太少。GTD 就是把想法归想法，执行归执行，通过回顾来联系。<br>GTD 适用于做事，而不能简单的适用于写作，因为写作无法准确的分解下一步。需要一个新的系统-卡片笔记。</p><blockquote><p>卢曼语录：”我只做容易的事情，我只在马上知道要怎么写的时候才会写作。如果我有片刻的动摇，我就会把这件事放在一边，然后继续做别的事”</p></blockquote><p>思考: 这里的容易，并非真正的容易，而是只是否让自己处于心流状态的工作，跟随兴趣而出发，不同的时间，不同的状态，不断在不同的领域积累。</p><h4 id="卢曼笔记的工作原理"><a href="#卢曼笔记的工作原理" class="headerlink" title="卢曼笔记的工作原理"></a>卢曼笔记的工作原理</h4><ol><li>卡片分类管理，分为闪念笔记、文献笔记和永久笔记。</li><li>记录笔记时，不是照抄原文，而是加上自己的思考和转述，并表明出处。</li><li>思考与关联，与历史笔记的关联，通过建立大纲笔记、索引笔记串联笔记系统。</li><li>组合，相关笔记组合为新的笔记。</li><li>时常回顾，分析各个笔记之间的关联。</li></ol><h3 id="关于写作，你需要做的"><a href="#关于写作，你需要做的" class="headerlink" title="关于写作，你需要做的"></a>关于写作，你需要做的</h3><h4 id="写作的具体步骤"><a href="#写作的具体步骤" class="headerlink" title="写作的具体步骤"></a>写作的具体步骤</h4><ol><li>记闪念笔记。随时记录灵感，想法。想法来之不易，要珍惜，及时记录。及时整理回顾。建立自己的闪念笔记系统。</li><li>记录文献笔记。文献笔记要精读，要一遍记录一遍读，珍惜好作品的想法，用自己的语言进行阐述。语句简练，做好标记和来源。建立自己的文献管理系统。</li><li>记永久笔记。通过阅读闪联笔记和文献笔记，思考和兴趣所在的主题，将笔记进行组合和扩展，形成一篇主题项目的永久笔记。这种笔记上的思想不是为了收集，而是为了衍生想法、论点和讨论。及时清理闪念笔记，文献笔记及时归纳，不要让闪念笔记成为垃圾桶。</li><li>将永久笔记和文献笔记建立关联，建立双链笔记。</li><li>对笔记进行扩展，比如某个主题差什么环节，有什么新的进展。</li><li>一个主题足够丰富，对主题内的笔记进行整理排序，剔除，改进。</li><li>将主题整理一篇连贯的文章。</li><li>校对，审核，发表</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在excel中使用python 快速作图示例</title>
    <link href="/2024/05/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8python%20%E5%BF%AB%E9%80%9F%E4%BD%9C%E5%9B%BE%E7%A4%BA%E4%BE%8B/"/>
    <url>/2024/05/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8python%20%E5%BF%AB%E9%80%9F%E4%BD%9C%E5%9B%BE%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Excel 中可以使用 python 算是一个旧闻了，是 python 之父 Guido van Rossum 加入微软的重要产品。刚出来的第一时间我也尝鲜了，最近作图的时候，再次使用了这个功能，感觉非常方便，推荐大家也用一下。<br><strong>优点：</strong></p><ol><li>Python 在云端运行，无需部署环境。</li><li>可以编写脚本来自动化日常的 Excel 任务，如数据整理、图表生成等，提高工作效率。</li><li>快速响应，可视化选择数据，调整原始数据方便，所见即所得，比 jupyter notebook 更丝滑。<br><strong>缺点：</strong><br>云端运行的 python，对网速要求高，不方便加载除了标准库以外的第三方库。<br>好的，那我们就以日常工作中水质折线图为例，探究下 Excel 中使用 python 的魅力。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405170912976.png" alt="在excel中使用python.png"></li></ol><h2 id="基础条件"><a href="#基础条件" class="headerlink" title="基础条件"></a>基础条件</h2><p>支持 python 的 excel 版本。我是用的是 office 365。<br><em>Excel 中的 Python 目前为预览版，可能会根据反馈进行更改。若要使用此功能，请加入 <a href="https://insider.microsoft365.com/join/windows">Microsoft 365 会员计划</a>，并选择“<strong>Beta 版频道</strong>”预览体验成员级别。</em><br>Excel 中的 Python 包括 anaconda 提供的一些标准 Python 库，用于提高数据分析和数据可视化能力。包括 Matplotlib、NumPy、Pandas、Seaborn、Statsmodels 等。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161838543.png" alt="image.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一组在线水质检测数据，包括水质站点监测值和监测时间。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161843018.png" alt="image.png"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>一、选择一个空单元格，点击公式-插入 python<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161845518.png" alt="image.png"></p><p>二、数据结构预览<br>单元格输入以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df=xl(<span class="hljs-string">&quot;A1:G98&quot;</span>, headers=<span class="hljs-literal">True</span>)<br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><span class="hljs-comment"># 确保时间列是索引</span><br>df.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>df.describe()<br></code></pre></td></tr></table></figure><p>按快捷键 crtl+enter 得到数据集结果。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161847142.png" alt="image.png"><br>仔细看下 excel 界面:<br>1 为代码输入区，可以调整宽度，自带代码高亮和代码提示。<br>2 为选择输出类型切换，包括值和 python 对象。<br>3 为结果展示区域，包括图片或者其他信息，图片的话需要调整单元格宽度。<br>4 为诊断信息，就像 python 的命令结果窗口，会给出成功或者报错信息。<br>可以说是一个简单的 IDE，五脏俱全。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161853316.png" alt="image.png"><br>三、绘图<br>选择一个较大的区域，最好是合并单元格，点击公式-插入 python。<br>单元格输入以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>] = [<span class="hljs-string">&quot;Simhei&quot;</span>]  <br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>] = <span class="hljs-literal">False</span><br><span class="hljs-comment"># 将监测时间列转换为datetime类型</span><br>df=xl(<span class="hljs-string">&quot;A1:G98&quot;</span>, headers=<span class="hljs-literal">True</span>)<br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><span class="hljs-comment"># 确保时间列是索引</span><br>df.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 使用matplotlib绘制折线图</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># 设置图表大小</span><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> df.columns:<br>    plt.plot(df.index, df[column], label=column)  <span class="hljs-comment"># 绘制每列的折线图</span><br><span class="hljs-comment"># 添加标准值线（值为6），蓝色虚线</span><br>plt.axhline(<span class="hljs-number">6</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">&#x27;标准值&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;5月各站点高锰酸盐指数变化趋势图&#x27;</span>)  <span class="hljs-comment"># 设置图表标题</span><br><span class="hljs-comment"># plt.xlabel(&#x27;监测时间&#x27;)  # 设置x轴标签</span><br>plt.ylabel(<span class="hljs-string">&#x27;监测值：mg/L&#x27;</span>)  <span class="hljs-comment"># 设置y轴标签</span><br>plt.xticks(rotation=<span class="hljs-number">0</span>)  <br>plt.tight_layout()  <span class="hljs-comment"># 自动调整子图参数，使之填充整个图像区域</span><br><span class="hljs-comment"># 修改图例位置</span><br>plt.legend(loc=<span class="hljs-string">&#x27;lower left&#x27;</span>, bbox_to_anchor=(<span class="hljs-number">0</span>, -<span class="hljs-number">0.15</span>), ncol=<span class="hljs-built_in">len</span>(df.columns), frameon=<span class="hljs-literal">False</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>结果如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161903435.png" alt="image.png"><br>利用 python 的 matplotlib 库绘图，就是这么丝滑。如果下次需要再次绘图，那么就不需要重复设置了，直接修改数据就好了。发现数据存在异常，修改异常值也是快速更新结果，非常方便。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这只是 excel 中使用 python 的一个小小示例，相信它能做的还有更多。有点担心 vba 的地位了。<br>最后，如果这篇文章有帮助到你，记得点赞，关注哦。<br>也欢迎关注我的微信公众号：环境猫 er。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192215003.jpg" alt="qrcode_for_me.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>经验分享</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忍痛分享一个标签页插件</title>
    <link href="/2024/05/13/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%BF%8D%E7%97%9B%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
    <url>/2024/05/13/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%BF%8D%E7%97%9B%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>如果你想要一个自定义收藏页面的标签页插件，他没有广告，而且支持很多插件，如股票、时间、倒计时、备忘录，那么我必须推荐你一个插件了。</p><p>itab 标签页。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131938405.png" alt="微信截图_20240513193649.png"></p><p>标签页可以分组，可以自定义图标，很多都能自动识别 logo。这类产品很多，但是完成度最高的目前就是 itab，不是广告，纯粹自来水。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>浏览器插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prophet时间序列模型水质预测应用 02</title>
    <link href="/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8%2002/"/>
    <url>/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8%2002/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此前已经分析了，ARIMA 模型在水质预测中的应用，今天用 prophet 模型测试下再水质预测中的效果。</p><h2 id="Prophet-简介"><a href="#Prophet-简介" class="headerlink" title="Prophet 简介"></a>Prophet 简介</h2><p>Prophet 是 Facebook 于2017年开源的一个时间序列预测框架，特别适合于处理具有明显趋势性和季节性的数据。该模型设计初衷是为了让非专业的数据科学家也能轻松上手进行复杂的时间序列分析，同时也能满足专业人士对于模型灵活性和准确性的需求，总之，就很香。</p><h2 id="Prophet-模型特点"><a href="#Prophet-模型特点" class="headerlink" title="Prophet 模型特点"></a>Prophet 模型特点</h2><p><strong>易用性</strong>：Prophet 提供了一个高度封装的 API，用户只需要提供时间戳（ds，通常为日期）和观测值（y，即随时间变化的目标变量），就可以快速构建预测模型，而无需深入理解复杂的统计或机器学习理论。<br><strong>自动特征提取</strong>：模型自动识别并处理时间序列中的趋势（长期增长或下降）、季节性（如周、月、年等周期性模式）以及节假日效应。用户可以轻松地添加自定义的季节性模式和节假日信息。<br><strong>灵活性</strong>：模型允许用户调整多种参数来控制预测的行为，比如趋势的平滑程度、季节性模式的复杂度等，以适应不同数据的特点。<br><strong>异常值和缺失值处理</strong>：Prophet模型对于数据中的异常值和缺失值具有一定的鲁棒性，能够在不影响整体预测的情况下处理这些问题。<br><strong>changepoints</strong>：模型能够自动检测并适应时间序列中的变化点，即数据中的非平稳部分，这对于预测具有突然变化的时间序列尤为重要。<br><strong>可视化</strong>：Prophet还提供了丰富的可视化工具，帮助用户直观地理解模型的各个组成部分（如趋势、季节性）以及预测结果，便于模型诊断和结果解释。<br><strong>Python 和 R 支持</strong>：Prophet 在 Python 和 R 两种语言中都有实现，方便不同背景的用户使用。</p><p>从上面的特点看出，完美适配水质预测。</p><h2 id="Prophet-python-安装"><a href="#Prophet-python-安装" class="headerlink" title="Prophet python 安装"></a>Prophet python 安装</h2><p>在网上能看到很多奇奇怪怪的安装指令，比如 fbprophet 库，已经不能用了，以我为准哈，下面是最新可用的安装方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install prophet<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131841729.png" alt="image.png"></p><h2 id="Python-Prophet-实践"><a href="#Python-Prophet-实践" class="headerlink" title="Python Prophet 实践"></a>Python Prophet 实践</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <br><span class="hljs-keyword">from</span> prophet <span class="hljs-keyword">import</span> Prophet  <br><span class="hljs-keyword">from</span> prophet.plot <span class="hljs-keyword">import</span> add_changepoints_to_plot  <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>每个项目的数据准备不一样，可以是在线数据，也可以是本地数据，具体略过。<br>数据结构为时间和值，Prophet 格式形式为 ds 和 y。</p><h3 id="数据粒径和数据集尺寸"><a href="#数据粒径和数据集尺寸" class="headerlink" title="数据粒径和数据集尺寸"></a>数据粒径和数据集尺寸</h3><p>Prophet 非常适合做周期数据，也适应多种粒径，所以无需担心他无法识别小时或者日的尺度，<br>还有因为他适合做周期数据，因此给数据集时，应给他至少一个周期的数据，不然预测出来效果差很多。<br>比如同一个站点，同一个因子，给一个月的数据集和一年的数据集结果分别如下图所示：<br><strong>一个月的数据集预测结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131854796.png" alt="Figure_5.png"><br><strong>一年的数据结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131855235.png" alt="Figure_2.png"></p><p>由上面 2 个图可以看出，完全是天差地别，也能看出这个模型非常厉害，处理周期波动数据非常精准，在一年的尺度下准确的预测了 4 月后水质将继续升高，并没有被短期下降数据而干扰。</p><h2 id="原始数据集预览"><a href="#原始数据集预览" class="headerlink" title="原始数据集预览"></a>原始数据集预览</h2><p>综上，我们选择一年的数据集，开始预测。原始数据如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131858976.png"><br>可以看到数据集质量一般，这也是实际生成环境中的数据，但是 Prophet 能够识别异常值，不用担心他会报错。</p><h2 id="模型搭建预览结果"><a href="#模型搭建预览结果" class="headerlink" title="模型搭建预览结果"></a>模型搭建预览结果</h2><p>模型接口非常简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet()  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期  </span><br>future.tail()  <span class="hljs-comment"># 查看预测数据框的末尾几行以确认预测时间段  </span><br><span class="hljs-comment"># 进行预测  </span><br>forecast = model.predict(future)  <br><span class="hljs-comment"># 绘制预测结果  </span><br>fig1 = model.plot(forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 添加变化点到图表中（如果需要）  </span><br>fig2 = model.plot(forecast)  <br>ax = fig2.gca()  <br>add_changepoints_to_plot(ax, model, forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction with Changepoints&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 打印预测数据框查看预测详情  </span><br><span class="hljs-built_in">print</span>(forecast[[<span class="hljs-string">&#x27;ds&#x27;</span>, <span class="hljs-string">&#x27;yhat&#x27;</span>, <span class="hljs-string">&#x27;yhat_lower&#x27;</span>, <span class="hljs-string">&#x27;yhat_upper&#x27;</span>]])<br></code></pre></td></tr></table></figure><p>预测结果为图 2 所示，变化点如下图，模型将每次突变点都标记出来了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131902308.png" alt="Figure_3.png"></p><p>预测结果 forecast<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131913145.png" alt="image.png"></p><h3 id="plotly-交互式接口"><a href="#plotly-交互式接口" class="headerlink" title="plotly 交互式接口"></a>plotly 交互式接口</h3><p>模型也提供了plotly创建预测和组件的交互式图窗，需要独立安装您 plotly 4.0 或更高版本，及 <code>notebook</code> 和 <code>ipywidgets</code> 软件包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">plot1 = plot_plotly(model, forecast)  <br>plot1.update_xaxes(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;date&quot;</span>, tickformat=<span class="hljs-string">&quot;%m-%d %H&quot;</span>)  <br>plot1.update_layout(  <br>    title=<span class="hljs-string">&quot;水质预测趋势&quot;</span>,  <br>    xaxis_title=<span class="hljs-string">&quot;日期&quot;</span>,  <br>    yaxis_title=<span class="hljs-string">&quot;value&quot;</span>  <br>)  <br>plot2 = plot_components_plotly(model, forecast)  <br>  <br>st.write(plot1)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410141428581.png" alt="image.png"></p><h2 id="模型微调"><a href="#模型微调" class="headerlink" title="模型微调"></a>模型微调</h2><h3 id="限定预测范围和方向"><a href="#限定预测范围和方向" class="headerlink" title="限定预测范围和方向"></a>限定预测范围和方向</h3><p>模型通过使用’cap’和’floor’，限制模型的预测范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;cap&#x27;</span>] = <span class="hljs-number">10</span>  <br>df[<span class="hljs-string">&#x27;floor&#x27;</span>] = <span class="hljs-number">3</span>  <br>  <br><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet(growth=<span class="hljs-string">&#x27;logistic&#x27;</span>)  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期 </span><br>future[<span class="hljs-string">&#x27;cap&#x27;</span>] = <span class="hljs-number">10</span>  <br>future[<span class="hljs-string">&#x27;floor&#x27;</span>] = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410141515347.png" alt="image.png"><br>可以看到，模型预测结果被限制在 10-3 之间，影响了预测结果的走向。</p><h3 id="调整趋势灵活性"><a href="#调整趋势灵活性" class="headerlink" title="调整趋势灵活性"></a>调整趋势灵活性</h3><p>调整趋势的灵活性，可以理解为调整置信区间的范围，方法是changepoint.prior.scale，降低该值将使趋势变得不那么灵活（置信区间小），提高数字让趋势更加灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet(changepoint_prior_scale=<span class="hljs-number">0.001</span>)  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410141536665.png" alt="image.png"></p><p>使用这个限制后的预测效果反而不如默认。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>相比 arima，Prophet 更加简单易用，且成熟接口更多，出图预览更方便，本文还没有对添加节假日进行测试，但已经非常够用了。<br>对比 LSTM，预测时间少非常多，配置也更简单，真的很不错，如果有兴趣可以深入尝试。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><strong>官方 docs</strong><br><a href="https://facebook.github.io/prophet/docs/quick_start.html#python-api">Quick Start | Prophet (facebook.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>时间序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prophet时间序列模型水质预测应用</title>
    <link href="/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此前已经分析了，ARIMA 模型在水质预测中的应用，今天用 prophet 模型测试下再水质预测中的效果。</p><h2 id="Prophet-简介"><a href="#Prophet-简介" class="headerlink" title="Prophet 简介"></a>Prophet 简介</h2><p>Prophet 是 Facebook 于2017年开源的一个时间序列预测框架，特别适合于处理具有明显趋势性和季节性的数据。该模型设计初衷是为了让非专业的数据科学家也能轻松上手进行复杂的时间序列分析，同时也能满足专业人士对于模型灵活性和准确性的需求，总之，就很香。</p><h2 id="Prophet-模型特点"><a href="#Prophet-模型特点" class="headerlink" title="Prophet 模型特点"></a>Prophet 模型特点</h2><p><strong>易用性</strong>：Prophet 提供了一个高度封装的 API，用户只需要提供时间戳（ds，通常为日期）和观测值（y，即随时间变化的目标变量），就可以快速构建预测模型，而无需深入理解复杂的统计或机器学习理论。<br><strong>自动特征提取</strong>：模型自动识别并处理时间序列中的趋势（长期增长或下降）、季节性（如周、月、年等周期性模式）以及节假日效应。用户可以轻松地添加自定义的季节性模式和节假日信息。<br><strong>灵活性</strong>：模型允许用户调整多种参数来控制预测的行为，比如趋势的平滑程度、季节性模式的复杂度等，以适应不同数据的特点。<br><strong>异常值和缺失值处理</strong>：Prophet模型对于数据中的异常值和缺失值具有一定的鲁棒性，能够在不影响整体预测的情况下处理这些问题。<br><strong>changepoints</strong>：模型能够自动检测并适应时间序列中的变化点，即数据中的非平稳部分，这对于预测具有突然变化的时间序列尤为重要。<br><strong>可视化</strong>：Prophet还提供了丰富的可视化工具，帮助用户直观地理解模型的各个组成部分（如趋势、季节性）以及预测结果，便于模型诊断和结果解释。<br><strong>Python 和 R 支持</strong>：Prophet 在 Python 和 R 两种语言中都有实现，方便不同背景的用户使用。</p><p>从上面的特点看出，完美适配水质预测。</p><h2 id="Prophet-python-安装"><a href="#Prophet-python-安装" class="headerlink" title="Prophet python 安装"></a>Prophet python 安装</h2><p>在网上能看到很多奇奇怪怪的安装指令，比如 fbprophet 库，已经不能用了，以我为准哈，下面是最新可用的安装方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install prophet<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131841729.png" alt="image.png"></p><h2 id="Python-Prophet-实践"><a href="#Python-Prophet-实践" class="headerlink" title="Python Prophet 实践"></a>Python Prophet 实践</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <br><span class="hljs-keyword">from</span> prophet <span class="hljs-keyword">import</span> Prophet  <br><span class="hljs-keyword">from</span> prophet.plot <span class="hljs-keyword">import</span> add_changepoints_to_plot  <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>每个项目的数据准备不一样，可以是在线数据，也可以是本地数据，具体略过。<br>数据结构为时间和值，Prophet 格式形式为 ds 和 y。</p><h3 id="数据粒径和数据集尺寸"><a href="#数据粒径和数据集尺寸" class="headerlink" title="数据粒径和数据集尺寸"></a>数据粒径和数据集尺寸</h3><p>Prophet 非常适合做周期数据，也适应多种粒径，所以无需担心他无法识别小时或者日的尺度，<br>还有因为他适合做周期数据，因此给数据集时，应给他至少一个周期的数据，不然预测出来效果差很多。<br>比如同一个站点，同一个因子，给一个月的数据集和一年的数据集结果分别如下图所示：<br><strong>一个月的数据集预测结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131854796.png" alt="Figure_5.png"><br><strong>一年的数据结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131855235.png" alt="Figure_2.png"></p><p>由上面 2 个图可以看出，完全是天差地别，也能看出这个模型非常厉害，处理周期波动数据非常精准，在一年的尺度下准确的预测了 4 月后水质将继续升高，并没有被短期下降数据而干扰。</p><h2 id="原始数据集预览"><a href="#原始数据集预览" class="headerlink" title="原始数据集预览"></a>原始数据集预览</h2><p>综上，我们选择一年的数据集，开始预测。原始数据如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131858976.png"><br>可以看到数据集质量一般，这也是实际生成环境中的数据，但是 Prophet 能够识别异常值，不用担心他会报错。</p><h2 id="模型搭建预览结果"><a href="#模型搭建预览结果" class="headerlink" title="模型搭建预览结果"></a>模型搭建预览结果</h2><p>模型接口非常简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet()  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期  </span><br>future.tail()  <span class="hljs-comment"># 查看预测数据框的末尾几行以确认预测时间段  </span><br><span class="hljs-comment"># 进行预测  </span><br>forecast = model.predict(future)  <br><span class="hljs-comment"># 绘制预测结果  </span><br>fig1 = model.plot(forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 添加变化点到图表中（如果需要）  </span><br>fig2 = model.plot(forecast)  <br>ax = fig2.gca()  <br>add_changepoints_to_plot(ax, model, forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction with Changepoints&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 打印预测数据框查看预测详情  </span><br><span class="hljs-built_in">print</span>(forecast[[<span class="hljs-string">&#x27;ds&#x27;</span>, <span class="hljs-string">&#x27;yhat&#x27;</span>, <span class="hljs-string">&#x27;yhat_lower&#x27;</span>, <span class="hljs-string">&#x27;yhat_upper&#x27;</span>]])<br></code></pre></td></tr></table></figure><p>预测结果为图 2 所示，变化点如下图，模型将每次突变点都标记出来了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131902308.png" alt="Figure_3.png"></p><p>预测结果 forecast<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131913145.png" alt="image.png"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>相比 arima，Prophet 更加简单易用，且成熟接口更多，出图预览更方便，本文还没有对添加节假日进行测试，但已经非常够用了。<br>对比 LSTM，预测时间少非常多，配置也更简单，真的很不错，如果有兴趣可以深入尝试。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/" title="ARIMA时间序列模型水质预测应用">ARIMA时间序列模型水质预测应用</a><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131915810.jpg" alt="pexels-pixabay-50677.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>时间序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prophet时间序列模型 参数微调</title>
    <link href="/2024/05/13/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%20%E5%8F%82%E6%95%B0%E5%BE%AE%E8%B0%83/"/>
    <url>/2024/05/13/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%20%E5%8F%82%E6%95%B0%E5%BE%AE%E8%B0%83/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> <p>之前写过prophet时间序列模型的简单介绍，今天补充将参数调整部分。</p><h2 id="Prophet-简介"><a href="#Prophet-简介" class="headerlink" title="Prophet 简介"></a>Prophet 简介</h2><p>Prophet 是 Facebook 于2017年开源的一个时间序列预测框架，特别适合于处理具有明显趋势性和季节性的数据。该模型设计初衷是为了让非专业的数据科学家也能轻松上手进行复杂的时间序列分析，同时也能满足专业人士对于模型灵活性和准确性的需求，总之，就很香。</p><h2 id="Prophet-模型特点"><a href="#Prophet-模型特点" class="headerlink" title="Prophet 模型特点"></a>Prophet 模型特点</h2><p><strong>易用性</strong>：Prophet 提供了一个高度封装的 API，用户只需要提供时间戳（ds，通常为日期）和观测值（y，即随时间变化的目标变量），就可以快速构建预测模型，而无需深入理解复杂的统计或机器学习理论。<br><strong>自动特征提取</strong>：模型自动识别并处理时间序列中的趋势（长期增长或下降）、季节性（如周、月、年等周期性模式）以及节假日效应。用户可以轻松地添加自定义的季节性模式和节假日信息。<br><strong>灵活性</strong>：模型允许用户调整多种参数来控制预测的行为，比如趋势的平滑程度、季节性模式的复杂度等，以适应不同数据的特点。<br><strong>异常值和缺失值处理</strong>：Prophet模型对于数据中的异常值和缺失值具有一定的鲁棒性，能够在不影响整体预测的情况下处理这些问题。<br><strong>changepoints</strong>：模型能够自动检测并适应时间序列中的变化点，即数据中的非平稳部分，这对于预测具有突然变化的时间序列尤为重要。<br><strong>可视化</strong>：Prophet还提供了丰富的可视化工具，帮助用户直观地理解模型的各个组成部分（如趋势、季节性）以及预测结果，便于模型诊断和结果解释。<br><strong>Python 和 R 支持</strong>：Prophet 在 Python 和 R 两种语言中都有实现，方便不同背景的用户使用。</p><p>从上面的特点看出，完美适配水质预测。</p><h2 id="Prophet-python-安装"><a href="#Prophet-python-安装" class="headerlink" title="Prophet python 安装"></a>Prophet python 安装</h2><p>在网上能看到很多奇奇怪怪的安装指令，比如 fbprophet 库，已经不能用了，以我为准哈，下面是最新可用的安装方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install prophet<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131841729.png" alt="image.png"></p><h2 id="Python-Prophet-实践"><a href="#Python-Prophet-实践" class="headerlink" title="Python Prophet 实践"></a>Python Prophet 实践</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <br><span class="hljs-keyword">from</span> prophet <span class="hljs-keyword">import</span> Prophet  <br><span class="hljs-keyword">from</span> prophet.plot <span class="hljs-keyword">import</span> add_changepoints_to_plot  <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>每个项目的数据准备不一样，可以是在线数据，也可以是本地数据，具体略过。<br>数据结构为时间和值，Prophet 格式形式为 ds 和 y。</p><h3 id="数据粒径和数据集尺寸"><a href="#数据粒径和数据集尺寸" class="headerlink" title="数据粒径和数据集尺寸"></a>数据粒径和数据集尺寸</h3><p>Prophet 非常适合做周期数据，也适应多种粒径，所以无需担心他无法识别小时或者日的尺度，<br>还有因为他适合做周期数据，因此给数据集时，应给他至少一个周期的数据，不然预测出来效果差很多。<br>比如同一个站点，同一个因子，给一个月的数据集和一年的数据集结果分别如下图所示：<br><strong>一个月的数据集预测结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131854796.png" alt="Figure_5.png"><br><strong>一年的数据结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131855235.png" alt="Figure_2.png"></p><p>由上面 2 个图可以看出，完全是天差地别，也能看出这个模型非常厉害，处理周期波动数据非常精准，在一年的尺度下准确的预测了 4 月后水质将继续升高，并没有被短期下降数据而干扰。</p><h2 id="原始数据集预览"><a href="#原始数据集预览" class="headerlink" title="原始数据集预览"></a>原始数据集预览</h2><p>综上，我们选择一年的数据集，开始预测。原始数据如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131858976.png"><br>可以看到数据集质量一般，这也是实际生成环境中的数据，但是 Prophet 能够识别异常值，不用担心他会报错。</p><h2 id="模型搭建预览结果"><a href="#模型搭建预览结果" class="headerlink" title="模型搭建预览结果"></a>模型搭建预览结果</h2><p>模型接口非常简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet()  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期  </span><br>future.tail()  <span class="hljs-comment"># 查看预测数据框的末尾几行以确认预测时间段  </span><br><span class="hljs-comment"># 进行预测  </span><br>forecast = model.predict(future)  <br><span class="hljs-comment"># 绘制预测结果  </span><br>fig1 = model.plot(forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 添加变化点到图表中（如果需要）  </span><br>fig2 = model.plot(forecast)  <br>ax = fig2.gca()  <br>add_changepoints_to_plot(ax, model, forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction with Changepoints&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 打印预测数据框查看预测详情  </span><br><span class="hljs-built_in">print</span>(forecast[[<span class="hljs-string">&#x27;ds&#x27;</span>, <span class="hljs-string">&#x27;yhat&#x27;</span>, <span class="hljs-string">&#x27;yhat_lower&#x27;</span>, <span class="hljs-string">&#x27;yhat_upper&#x27;</span>]])<br></code></pre></td></tr></table></figure><p>预测结果为图 2 所示，变化点如下图，模型将每次突变点都标记出来了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131902308.png" alt="Figure_3.png"></p><p>预测结果 forecast<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131913145.png" alt="image.png"></p><h3 id="plotly-交互式接口"><a href="#plotly-交互式接口" class="headerlink" title="plotly 交互式接口"></a>plotly 交互式接口</h3><p>模型也提供了plotly创建预测和组件的交互式图窗，需要独立安装您 plotly 4.0 或更高版本，及 <code>notebook</code> 和 <code>ipywidgets</code> 软件包。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">plot1 = plot_plotly(model, forecast)  <br>plot1.update_xaxes(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;date&quot;</span>, tickformat=<span class="hljs-string">&quot;%m-%d %H&quot;</span>)  <br>plot1.update_layout(  <br>    title=<span class="hljs-string">&quot;水质预测趋势&quot;</span>,  <br>    xaxis_title=<span class="hljs-string">&quot;日期&quot;</span>,  <br>    yaxis_title=<span class="hljs-string">&quot;value&quot;</span>  <br>)  <br>plot2 = plot_components_plotly(model, forecast)  <br>  <br>st.write(plot1)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410141428581.png" alt="image.png"></p><h2 id="模型微调"><a href="#模型微调" class="headerlink" title="模型微调"></a>模型微调</h2><h3 id="限定预测范围和方向"><a href="#限定预测范围和方向" class="headerlink" title="限定预测范围和方向"></a>限定预测范围和方向</h3><p>模型通过使用’cap’和’floor’，限制模型的预测范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;cap&#x27;</span>] = <span class="hljs-number">10</span>  <br>df[<span class="hljs-string">&#x27;floor&#x27;</span>] = <span class="hljs-number">3</span>  <br>  <br><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet(growth=<span class="hljs-string">&#x27;logistic&#x27;</span>)  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期 </span><br>future[<span class="hljs-string">&#x27;cap&#x27;</span>] = <span class="hljs-number">10</span>  <br>future[<span class="hljs-string">&#x27;floor&#x27;</span>] = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410141515347.png" alt="image.png"><br>可以看到，模型预测结果被限制在 10-3 之间，影响了预测结果的走向。</p><h3 id="调整趋势灵活性"><a href="#调整趋势灵活性" class="headerlink" title="调整趋势灵活性"></a>调整趋势灵活性</h3><p>调整趋势的灵活性，可以理解为调整置信区间的范围，方法是changepoint.prior.scale，降低该值将使趋势变得不那么灵活（置信区间小），提高数字让趋势更加灵活。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet(changepoint_prior_scale=<span class="hljs-number">0.001</span>)  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202410141536665.png" alt="image.png"></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><strong>官方 docs</strong><br><a href="https://facebook.github.io/prophet/docs/quick_start.html#python-api">Quick Start | Prophet (facebook.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>时间序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集方法合集 第2期</title>
    <link href="/2024/05/12/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC2%E6%9C%9F/"/>
    <url>/2024/05/12/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC2%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好的，我们继续讲所有信息的收集方法，今天讲百度文库、淘豆网、豆丁网、道客巴巴、原创力文档及专利的获取，还包括搜索信息的注意事项。如果有帮助到你，非常荣幸，我会坚持分享我的学习、工作经验。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111825908.png" alt="image.png"></p><h2 id="其他文档"><a href="#其他文档" class="headerlink" title="其他文档"></a>其他文档</h2><p>这里泛指所有上传在百度文库、淘豆网、豆丁网、道客巴巴、原创力文档等网站上的文件，也是使用比较高频的一个方法，这里先叠个甲，我并非不尊重知识产权，只是这些网站的内容大多是在公开资料上爬取然后展示的内容，包括很多标准等等，在用于学习的情况下，下载下来无可厚非，如果以下方法，有侵害到平台权利，我就删掉这篇文章，相信信息只有流转才能产生价值。<br>好的我们继续。</p><p>打开浏览器应用商店，推荐 edge 、chrome浏览器，安装 tampermonkey 插件，点击插件获取新脚本，在 greasy fork 脚本商店中搜索文库下载器，一定要是 waahah 这个做这的脚本，其他也有一些下载脚本，但是我推荐这个是亲测可用的，当然也鼓励大家自己多尝试。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111426186.png" alt="image.png"></p><p>安装好后，打开想要下载的网站，当脚本检测到对应的网站后，会在左上角悬浮蓝色的工具栏，在非百度文库下，先点击自动展开，带文件全部展开后，然后点击导出 PDF。注意如果导出 pdf 效果不好，可以直接在浏览器点击打印, 用虚拟打印机保存为 pdf。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111431609.png" alt="image.png"></p><h2 id="专利"><a href="#专利" class="headerlink" title="专利"></a>专利</h2><p>专利之星只需要注册账号就可以查看公开专利内容，非常好用。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111415055.png" alt="image.png"></p><h2 id="常规搜索方法"><a href="#常规搜索方法" class="headerlink" title="常规搜索方法"></a>常规搜索方法</h2><p>比如在谷歌、百度上搜索，如果精确搜索的话，要想要关键词。比如制定文件格式可以用<br>filetype: pdf 关键词（pdf 可以替换 doc、ppt、jpg 等）<br>还有很多其他比较复杂的搜索关键词，其实用的频率并不高，这里我就不多赘述。<br>谷歌搜索注意用对地址，一般 vpn 的话会默认 vpn 代理地址，下面这个链接可以<br><a href="http://www.google.com/ncr">www.google.com/ncr</a><br>想要查询政府文件或者公开文件，应该熟悉他们的公文结构，了解固定的关键词。<br>比如查询环评原文则在某某报告后面加上”受理”、”公示”字样。</p><p>AI 搜索<br>推荐秘塔搜索，用做主体学习非常不错，可以选择学术、网页、播客三种类型，除了生成分析内容外，更重要的是将相关来源标出，让我们更准确的获取信息。如果<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122017540.png" alt="image.png"></p><p>我获取信息的方法就是这些了，新人一枚，如果有帮助到你，请点赞关注收藏，谢谢！</p><p>最后打个广告，我新开了微信公众号（环境猫 er），坚持发布 python 环境业务解决方案，python 办公自动化，GIS 作图经验，学习笔记，办公技巧，工具分享等内容。<br>坚持 Bulid in public ，希望与你一起加油，一同成长。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405102028570.jpg" alt="qrcode_for_gh_b2ae4cd1414a_258.jpg"></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC1%E6%9C%9F/" title="信息收集方法合集 第1期">信息收集方法合集 第1期</a>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>经验分享</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集方法合集 第1期</title>
    <link href="/2024/05/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC1%E6%9C%9F/"/>
    <url>/2024/05/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC1%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在工作中，经常被问到某个文件怎么下载，原文来自哪里。索性把我知道的所有信息收集方法全部整理一遍，希望对大家有用，如果有帮助到你，非常荣幸，我会坚持分享我的学习、工作经验。</p><p><strong>信息种类</strong>：包括法律法规、标准导则、中英文论文、书籍、专利、环评、验收报告以及其他公开的资料。<br>信息收集框架结构如下图，我会分两期介绍所有信息的获取方法，第一期讲法律法规标准导则、论文、书籍等资料的获取，第二期讲百度文库、淘豆网、豆丁网、道客巴巴、原创力文档及专利的获取，还包括搜索信息的注意事项。随后会持续出关于文献知识库管理的内容，欢迎关注哦。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111825908.png" alt="image.png"></p><h3 id="法律法规、标准导则"><a href="#法律法规、标准导则" class="headerlink" title="法律法规、标准导则"></a>法律法规、标准导则</h3><p>通常这些内容是公开的，在政府网站上可以查到，这里推荐在聚合的网站上去下载，比如环评云助手、国家标准全文公开系统、环保小智等，这些网站不光可以查文件，还可是查询是否有效。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111432139.png" alt="image.png"></p><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>论文也是我们获取高质量信息的来源，中文文献一般是知网、万方、维普等平台最多，但这些网站一旦出了大学获取就比较困难，这里推荐一个网站，书童图书馆，需要购买账号，可以很低价的方式获得一个长期的会员，可以下载所有的文献。<br>推荐之前先叠个甲，这部分属于灰色地带，但从学习的角度讲，文献公开是对学习研究环境非常有利的，不管政策怎么变，及时这个网址可能被 ban，也有千万个网站出来，就像是 Z-library 一样。</p><p>英文文献推荐 Sci-hub 和 Arxiv。英文文献的获取难度要低于中文，甚至很多文献可以找到代码和数据集，国内做的相对较差。<br>SCI-HUB<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111749350.png" alt="image.png"></p><p>Arxiv 是本是存放物理学、数学、计算机科学、生物学与数理经济学的论文预印本的网站，是没有被同行审议过的文章都先上传在上面，后面上传的论文越来越多人，影响越来越大，目前已经是非常重要的论文网站了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111759563.png" alt="image.png"></p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>获取电子书的方法也很多，首推 Z-library。经常被 ban，目前仍在坚强运营。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111802327.png" alt="image.png"></p><p> Z-library 经常变动网址，有时候需要魔法，嫌麻烦可以用鸠摩搜书先检索，一般书都有。<br>然后是 GitHub，有些开源项目的书会发布在 GitHub 上，比如鸢尾花系列，Python 工匠等。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111804169.png" alt="image.png"><br>最后强烈推荐微信读书，原因有：</p><ol><li>微信读书包含的出版书籍很多，且支持导入 PDF；</li><li>很多出版社做了真人朗读，听书非常方便，</li><li>读书送时长和书币让你基本不需要花钱，让你直接拥有一个图书馆。</li><li>读书笔记与 obsidian 等软件有联动，方便总结归纳，</li><li>多平台适配，书籍无需过多整理，减轻负担。<br>我已经成为微信读书的重度用户了，也欢迎喜欢微信读书的朋友，留言交流，一同进步。</li></ol><p>新人一枚，如果有帮助到你，请点赞关注，非常感谢。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/12/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC2%E6%9C%9F/" title="信息收集方法合集 第2期">信息收集方法合集 第2期</a>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>经验分享</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARIMA时间序列模型水质预测应用</title>
    <link href="/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="ARIMA-时间序列模型简介"><a href="#ARIMA-时间序列模型简介" class="headerlink" title="ARIMA 时间序列模型简介"></a>ARIMA 时间序列模型简介</h2><p>时间序列是研究数据随时间变化而变化的一种算法，是一种预测性分析算法。它的基本出发点就是事物发展都有连续性，按照它本身固有的规律进行。ARIMA(p,d,q)模型全称为差分自回归移动平均模型  (Autoregressive Integrated Moving Average Model,简记 ARIMA). 是比较成熟且简单的时间预测模型之一。其中 AR 为自回归, I 为差分, MA 为移动平均。<br>趋势参数：</p><ul><li>p：趋势自回归阶数。</li><li>d：趋势差分阶数。</li><li>q：趋势移动平均阶数。</li></ul><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分（difference）又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数f(x) 映射到f(x+a)-f(x+b) 。差分运算，相应于微分运算，是微积分中重要的一个概念。总而言之，差分对应离散，微分对应连续。差分又分为前向差分、向后差分及中心差分三种。<br>通常情况下我们用到的是前向差分公式如下：<br>xk&#x3D;x0+kh,(k&#x3D;0,1,…,n)<br>△f(xk)&#x3D;f(xk+1)−f(xk)<br>差分的阶<br>称为阶的差分，即前向阶差分 ，如果数学运用根据数学归纳法，有其中，为二项式系数。特别的，有前向差分有时候也称作数列的二项式变换</p><h2 id="在高锰酸盐指数序列预测可行性的说明"><a href="#在高锰酸盐指数序列预测可行性的说明" class="headerlink" title="在高锰酸盐指数序列预测可行性的说明"></a>在高锰酸盐指数序列预测可行性的说明</h2><p>通过观察水质变化趋势，高锰酸盐指数波动不剧烈，存在明显的中心波动规律。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658496447043-88b405af-1be8-4102-9e18-08920fc56b01.png"></p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> warnings<br><span class="hljs-keyword">import</span> pymysql<br><br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)  <br><span class="hljs-comment"># 忽略警告，不然一大堆警告，多是python及对应包升高导致，不影响使用</span><br><span class="hljs-keyword">from</span> IPython.core.interactiveshell <span class="hljs-keyword">import</span> InteractiveShell<br>InteractiveShell.ast_node_interactivity = <span class="hljs-string">&quot;all&quot;</span><br><span class="hljs-keyword">from</span> matplotlib.pylab <span class="hljs-keyword">import</span> style  <span class="hljs-comment"># 自定义图表风格</span><br>style.use(<span class="hljs-string">&#x27;ggplot&#x27;</span>)<br><br><span class="hljs-comment"># 解决中文乱码问题</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Simhei&#x27;</span>]<br><span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># pip install statsmodels</span><br><br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf, plot_pacf  <span class="hljs-comment"># 自相关图、偏自相关图</span><br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller <span class="hljs-keyword">as</span> ADF  <span class="hljs-comment"># 平稳性检验</span><br><span class="hljs-keyword">from</span> statsmodels.stats.diagnostic <span class="hljs-keyword">import</span> acorr_ljungbox  <span class="hljs-comment"># 白噪声检验</span><br><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm  <span class="hljs-comment"># D-W检验,一阶自相关检验</span><br><span class="hljs-keyword">from</span> statsmodels.graphics.api <span class="hljs-keyword">import</span> qqplot  <span class="hljs-comment"># 画QQ图,检验一组数据是否服从正态分布</span><br><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br></code></pre></td></tr></table></figure><h3 id="连接数据"><a href="#连接数据" class="headerlink" title="连接数据"></a>连接数据</h3><p>通过数据库，excel 都可以，列名为监测时间、设备名称、设备因子、监测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn_sql</span>():<br>    conn = pymysql.connect(host=<span class="hljs-string">&quot; &quot;</span>,<br>                   port= ,<br>                   user=<span class="hljs-string">&quot; &quot;</span>,<br>                   password=<span class="hljs-string">&quot; &quot;</span>,<br>                   db=<span class="hljs-string">&quot; &quot;</span>,<br>                   charset=<span class="hljs-string">&quot;utf8&quot;</span>)<br>    sql = <span class="hljs-string">&quot;&quot;</span><br>    read_sql = pd.read_sql(sql, conn)<br>    <span class="hljs-keyword">return</span> read_sql<br>read_sql=conn_sql()<br></code></pre></td></tr></table></figure><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nseri</span>(<span class="hljs-params">s,y </span>):<br>    aidunqiao = read_sql.loc[read_sql[<span class="hljs-string">&#x27;设备名称&#x27;</span>] == s, :]<br>    ai_cod = aidunqiao.loc[read_sql[<span class="hljs-string">&#x27;监测因子&#x27;</span>] == y, :]<br>    ai_cod_mn = ai_cod.loc[:, [<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&#x27;监测值&#x27;</span>]]<br>    baseline = ai_cod.loc[:, [<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&#x27;监测值&#x27;</span>]]<br><br>    ai_cod_mn.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    interp_cod_mn = ai_cod_mn[<span class="hljs-string">&quot;监测值&quot;</span>].interpolate()<br>    ai_cod_mn[<span class="hljs-string">&quot;cod&quot;</span>] = interp_cod_mn<br>    starttime = baseline.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    rows = baseline.shape[<span class="hljs-number">0</span>]<br>    endtime = baseline.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br>    year_month_day = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<span class="hljs-string">&quot;%Y%m%d%h%m%s&quot;</span>)<br>    a_ser = pd.DataFrame(&#123;<span class="hljs-string">&#x27;监测时间&#x27;</span>: year_month_day&#125;)<br>    a_ser.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df = pd.concat([a_ser, ai_cod_mn], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&quot;outer&quot;</span>)<br>    df = df.reset_index(drop=<span class="hljs-literal">False</span>)<br>    df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br>    df1 = df.drop_duplicates(subset=<span class="hljs-string">&quot;监测时间&quot;</span>, keep=<span class="hljs-string">&quot;last&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2 = df1.sort_values(by=<span class="hljs-string">&quot;监测时间&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2[<span class="hljs-string">&quot;cod&quot;</span>] = df2[<span class="hljs-string">&quot;监测值&quot;</span>].interpolate()<br>    df2.drop(columns=<span class="hljs-string">&quot;监测值&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> df2<br></code></pre></td></tr></table></figure><p>主要是 将数据生成无空连续的逐小时 时间序列数据 插值方法为线性插值</p><h3 id="数据解读"><a href="#数据解读" class="headerlink" title="数据解读"></a>数据解读</h3><h4 id="查看acf"><a href="#查看acf" class="headerlink" title="查看acf"></a>查看acf</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = df2.dropna()<br><span class="hljs-comment"># 解决有nan的问题</span><br>plot_acf(df2,lags=<span class="hljs-number">50</span>).show()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658496966248-a9f853f2-55b2-4728-8ae7-83c26ec56dd7.png"></p><p>解读 拖尾为p 。基本大于0.5 现在和未来有很强的相关性</p><h4 id="单位根检验"><a href="#单位根检验" class="headerlink" title="单位根检验"></a>单位根检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;原始序列的ADF检验结果为：&#x27;</span>,ADF(df2.cod))<br></code></pre></td></tr></table></figure><p>原始序列的ADF检验结果为： (-7.19465930048855, 2.452407467867345e-10, 37, 9199, {‘1%’: -3.431061069214289, ‘5%’: -2.8618542472812902, ‘10%’: -2.5669372687639176}, 11281.50483165621)</p><p>解读：P值小于显著性水平α（0.05），不接受原假设（非平稳序列），说明原始序列是平稳序列。</p><h4 id="白噪声检验"><a href="#白噪声检验" class="headerlink" title="白噪声检验"></a>白噪声检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一阶差分序列的白噪声检验结果为：&#x27;</span>,acorr_ljungbox(df2,lags=<span class="hljs-number">1</span>,return_df =<span class="hljs-built_in">bool</span>))<br></code></pre></td></tr></table></figure><p>一阶差分序列的白噪声检验结果为： lb_stat lb_pvalue 1 7467.631465 0.0</p><p>p值为0小于0.05，不是白噪声</p><p><strong>综上可以采用 arima 模型</strong></p><h4 id="定阶-人工识图"><a href="#定阶-人工识图" class="headerlink" title="定阶 人工识图"></a>定阶 人工识图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#一阶差分，我们不需要这么做，看下代码怎么写的。</span><br>df2_mn=df2.diff(periods=<span class="hljs-number">1</span>, axis=<span class="hljs-number">0</span>).dropna()<br><span class="hljs-comment">#自相关图</span><br>plot_acf(df2,lags=<span class="hljs-number">20</span>).show()<br><span class="hljs-comment">#解读：拖尾 有长期相关性 p 取1 </span><br><span class="hljs-comment">#偏自相关图 </span><br>plot_pacf(df2,lags=<span class="hljs-number">20</span>).show()<br><span class="hljs-comment">#偏自相关图</span><br>plot_pacf(df2,lags=<span class="hljs-number">50</span>).show()<br><span class="hljs-comment">#解读：自相关图，0阶拖尾；偏自相关图，截尾。则ARIMA(p,d,q)=ARIMA(1,0,n)</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497358538-342dc80a-d890-4386-bc8e-ca67ca811fef.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497368903-f3dccfbb-c6e0-4aa7-a86c-e78aab590f93.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497380496-184e826a-d4c3-40a3-aa69-f2413617af0a.png"></p><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><p>AIC调优</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br>aic_matrix=[]<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    tmp=[]<br>    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">try</span>:<br>            tmp.append(ARIMA(df2,order=(p,<span class="hljs-number">0</span>,q)).fit().aic)<br>        <span class="hljs-keyword">except</span>:<br>            tmp.append(<span class="hljs-literal">None</span>)<br>    aic_matrix.append(tmp)<br>aic_matrix<br><br><span class="hljs-comment"># p,q=aic_matrix.stack().idxmin() #最小值的索引</span><br><span class="hljs-comment"># 手动查找最小值 同样为1，0，4</span><br></code></pre></td></tr></table></figure><p>也可以用BIC调优 不再赘述</p><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = ARIMA(df2, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>result_arima = model.fit()<br></code></pre></td></tr></table></figure><h3 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h3><p>定义画图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pic1</span>(<span class="hljs-params">result_arima,df2</span>):<br>    t1 = <span class="hljs-string">&quot;2022/7/6 00:00:00&quot;</span><br>    t2 = <span class="hljs-string">&quot;2022/7/8 00:00:00&quot;</span><br>    predict_more=result_arima.predict(t1 ,t2 )<br>    t = pd.date_range(t1, t2 , freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<span class="hljs-string">&quot;%y%m%d%h%m%s&quot;</span>)<br>    new_ticks = pd.date_range(t1, t2 , freq=<span class="hljs-string">&quot;d&quot;</span>).strftime(<span class="hljs-string">&quot;%y%m%d%h%m%s&quot;</span>)<br>    axc.clear()<br>    axc.set_title(<span class="hljs-string">&quot;局部历史值与真实值对比&quot;</span>)<br>    axc.plot(t,df2[t1 :t2],linestyle = <span class="hljs-string">&quot;--&quot;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    axc.plot(t,predict_more,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>    axc.legend([<span class="hljs-string">&#x27;真实值&#x27;</span>,<span class="hljs-string">&#x27;预测值&#x27;</span>])<br>    axc.set_xticks(new_ticks)   <br><br>    <span class="hljs-comment"># 创建画布控件</span><br>    canvas = FigureCanvasTkAgg(fig1, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497922337-e1e6f543-0dbb-409b-ac68-05a72ef2423a.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fore_picture</span>(<span class="hljs-params">result_arima,df2</span>):<br>    df3 = df2.reset_index(drop=<span class="hljs-literal">False</span>)<br>    rows = df3.shape[<span class="hljs-number">0</span>]<br>    endtime = df3.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    forecast = pd.Series(result_arima.forecast(<span class="hljs-number">48</span>), index=pd.date_range(endtime, periods=<span class="hljs-number">48</span>, freq=<span class="hljs-string">&#x27;H&#x27;</span>))<br>    df_last = df2.iloc[-<span class="hljs-number">48</span>:]    <br>    data = pd.concat((df_last, forecast), axis=<span class="hljs-number">0</span>)<br>    data.columns = [<span class="hljs-string">&#x27;监测值浓度&#x27;</span>, <span class="hljs-string">&#x27;未来48小时&#x27;</span>]<br>    axc2.clear()<br>    axc2.set_title(<span class="hljs-string">&quot;未来48小时预测&quot;</span>)<br>    axc2.plot(data) <br>    <br>        <span class="hljs-comment"># 创建画布控件</span><br>    canvas = FigureCanvasTkAgg(fig2, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">600</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497941233-d0387b16-c1dd-4ec5-a2a4-4162e3be9eec.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare2</span>(<span class="hljs-params">result_arima,df2</span>):<br>    df3 = df2.reset_index(drop=<span class="hljs-literal">False</span>)<br>    rows = df3.shape[<span class="hljs-number">0</span>]<br>    endtime = df3.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    starttime = df3.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    predict=result_arima.predict(starttime , endtime)<br>    axc3.clear()<br>    axc3.set_title(<span class="hljs-string">&quot;全部预测值真实值对比&quot;</span>)<br>    axc3.plot(df2.index,df2[<span class="hljs-string">&#x27;cod&#x27;</span>],linestyle = <span class="hljs-string">&quot;--&quot;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    axc3.plot(df2.index,predict,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>    axc3.legend([<span class="hljs-string">&#x27;真实值&#x27;</span>,<span class="hljs-string">&#x27;预测值&#x27;</span>])<br>    canvas = FigureCanvasTkAgg(fig3, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">1200</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497956069-1c995a76-08cb-44b0-a0b2-9173af977365.png"></p><h3 id="模型可视化及GUI初探"><a href="#模型可视化及GUI初探" class="headerlink" title="模型可视化及GUI初探"></a>模型可视化及GUI初探</h3><p>用Tkinter 实现自动选择站点及因子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 副本</span><br><span class="hljs-keyword">from</span> tkinter.ttk <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span>  tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> matplotlib<br>matplotlib.use(<span class="hljs-string">&#x27;TkAgg&#x27;</span>)<br><span class="hljs-keyword">from</span> matplotlib.backends.backend_tkagg <span class="hljs-keyword">import</span> FigureCanvasTkAgg<br><span class="hljs-keyword">from</span> matplotlib.figure <span class="hljs-keyword">import</span> Figure<br><br>root = Tk()<br>root.title(<span class="hljs-string">&quot;ARIMA预测模型&quot;</span>)<br>root.geometry(<span class="hljs-string">&quot;1800x900+50+50&quot;</span>)  <span class="hljs-comment"># 长x宽+x*y</span><br>           <br>lb1 = Label(root,text=<span class="hljs-string">&#x27;站点选择&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br>lb2 = Label(root,text=<span class="hljs-string">&#x27;因子选择&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br>lb3 = Label(root,text=<span class="hljs-string">&#x27;预测结果（48h）&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br><span class="hljs-comment"># lb4 = Label(root,text=&#x27;历史预测对比&#x27;,fg=&#x27;black&#x27;, font=(&#x27;微软雅黑&#x27;,15),  height=2,  relief=FLAT)</span><br><br><span class="hljs-comment"># lb5 = Label(root,text=comb1.get(),fg=&#x27;black&#x27;, font=(&#x27;微软雅黑&#x27;,15),  height=2,  relief=FLAT)</span><br>lb1.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">20</span>)<br>lb2.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">20</span>)<br>lb3.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">110</span>)<br><span class="hljs-comment"># lb4.place(x=510,y=110)</span><br><span class="hljs-comment"># lb5.place(x=820,y=110)</span><br>var1 = StringVar()<br>comb1= Combobox(root,textvariable=var1,values = site)<br>comb1.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">80</span>)<br>var2 = StringVar()<br>comb2= Combobox(root,textvariable=var2,values=factor)<br>comb2.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_device</span>(<span class="hljs-params">event</span>):<br>    s = comb1.get()<br>    <span class="hljs-built_in">print</span>(s)<br>    <span class="hljs-keyword">return</span> s<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_factor</span> (event):<br>    y = comb2.get()<br>    <span class="hljs-built_in">print</span>(y)<br>    <span class="hljs-keyword">return</span> y<br><br>comb1.bind(<span class="hljs-string">&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;</span>, select_device)<br>comb2.bind(<span class="hljs-string">&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;</span>, select_factor)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">event</span>):<br>    s = comb1.get()<br>    y = comb2.get()<br>    df2 = nseri(s,y )<br>    model = ARIMA(df2, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>    result_arima = model.fit()<br>    <br>    fig1 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc = fig1.add_subplot(<span class="hljs-number">111</span>)<br>    axc.clear()<br>    pic1(result_arima,df2)<br><br>    fig2 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc2 = fig2.add_subplot(<span class="hljs-number">111</span>)<br>    axc2.clear()<br>    fore_picture(result_arima,df2)<br><br>    fig3 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc3 = fig3.add_subplot(<span class="hljs-number">111</span>)<br>    axc3.clear()<br>    compare2(result_arima,df2)    <br>    <br><br>but1 = Button(root, text=<span class="hljs-string">&#x27;计算&#x27;</span>,font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">1</span>)<br>but1.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">110</span>)  <br><br>but1.bind(<span class="hljs-string">&quot;&lt;Button-1&gt;&quot;</span>,click)<br><br>root.mainloop()<br></code></pre></td></tr></table></figure><p>结果预览<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405092131490.png" alt="111.png"></p><h3 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h3><p>模型评价方法： 浓度准确率， 等级准确率</p><p>浓度准确率</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498060055-471dd8e9-e287-4a75-b360-d508cdf45eea.png"></p><p>等级准确率：实测的类别与预测的类别相同时，则视为预测正确，预测正确的个数占预测的总个数的百分比，即为模型预测准确率。指标预测准确率的详细计算方法如下式：<img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405092145737.png" alt="image.png"></p><p>Pi为类别相对误差，T 为验证期内实测值的时间点数，t为实测值与预测值对应的时刻，pit为实测的类别与模拟的类别相比值，如果类别相同则为1，否则为0。</p><h3 id="结果提取"><a href="#结果提取" class="headerlink" title="结果提取"></a>结果提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">format1</span>(<span class="hljs-params">df2</span>):<br>    df7=pd.Series()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">180</span>) :<br>        df3= df2[:-<span class="hljs-number">4</span>*(<span class="hljs-number">1</span>+i)]        <br>        model = ARIMA(df3, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>        result_arima1 = model.fit()<br>        df4 = df3.reset_index(drop=<span class="hljs-literal">False</span>)<br>        rows = df4.shape[<span class="hljs-number">0</span>]<br>        endtime = df4.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        forecast = pd.Series(result_arima1.forecast(<span class="hljs-number">5</span>), index=pd.date_range(endtime, periods=<span class="hljs-number">5</span>, freq=<span class="hljs-string">&#x27;H&#x27;</span>))<br>        df8 = forecast.tail(<span class="hljs-number">1</span>)    <br>        df7 = pd.concat((df7,df8),axis=<span class="hljs-number">0</span>,join=<span class="hljs-string">&#x27;inner&#x27;</span>)<br>    <span class="hljs-keyword">return</span> df7 <br>f2 =format1(df2)<br>f2.to_excel(<span class="hljs-string">&quot;forceful.xls&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>时间原因用的excel 分析</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498412727-7339ba7d-dbd3-407b-ac06-2261972c967d.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498435576-efb265aa-9f0e-452f-84fa-e70509215452.png"></p><p>对比了6月21日~2022&#x2F;7&#x2F;15 高指真实值与预测值的结果，浓度预测准确率为84.61%，等级准确率40.74%，等级准确率偏低的原因为实际监测结果在6附近波动，为Ⅲ类水质标准。<br>预测对比时间窗口存在降雨，实际结果有一定波动，浓度预测准确率能到达84.6%，有一定的推广价值。</p><h3 id="ARIMA-summary-解读"><a href="#ARIMA-summary-解读" class="headerlink" title="ARIMA .summary() 解读"></a>ARIMA .summary() 解读</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1670242073687-2d564dde-6f19-4ae7-9283-b3341ec7dae9.png"></p><ol><li>左上 为模型基本信息，Dep. Variable（需要预测的变量）、Model（模型及其参数）、Date、Time、Sample（样本数据）、No. Observations（观测数据的数量）</li><li>右上 Log Likelihood（对数似然函数）标识最适合采样数据的分布。虽然它很有用，但AIC和BIC会惩罚模型的复杂性，这有助于使我们的ARIMA模型变得简洁。赤池的信息准则（AIC）有助于确定线性回归模型的强度。AIC 会惩罚添加参数的模型，因为添加更多参数将始终增加最大似然值。贝叶斯信息准则（BIC）与 AIC 一样，BIC 也会惩罚模型的复杂性，但它也包含数据中的行数。Hannan-Quinn信息标准（HQIC），与AIC和BIC一样是模型选择的另一个标准；但是它在实践中并不常用。AIC 、BIC 越小越好</li><li>中部 确保模型中的每个项在统计意义上是否显著。若p值大于0.05，则项不显著。</li><li>下部：Ljung-Box（modified Box-Pierce test）测试错误是白噪音 Ljung-Box (L1) (Q) 为Lag1的LBQ检验统计量，其Prob(Q)为 0.01，p值为0.94。由于p值高于0.05，因此我们不能拒绝零假设（误差是白噪音）</li></ol><h3 id="讨论与总结"><a href="#讨论与总结" class="headerlink" title="讨论与总结"></a>讨论与总结</h3><ol><li>ARIMA 模型在高锰酸盐指数上的预测效果超过80%,经过初步研究，适用于水质在线站点。</li><li>模型可用于单站点单因子预测，不需要其他参数，约束小，预测精度高。</li><li>模型对波动剧烈的因子，预测效果不好，不适用于所有因子，所有站点。</li><li>对于新的数据集需要做平稳性检验，白噪声检验。</li><li>需要采用数据人工识图+自动的方式实现定阶，选择最优的 p，d，q。</li><li>可以继续在 ARIMAX（多元时间序列模型）等方面深入研究。</li></ol><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/" title="prophet时间序列模型水质预测应用">prophet时间序列模型水质预测应用</a>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间序列</tag>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARIMA时间序列模型水质预测应用</title>
    <link href="/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A81/"/>
    <url>/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A81/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="ARIMA-时间序列模型简介"><a href="#ARIMA-时间序列模型简介" class="headerlink" title="ARIMA 时间序列模型简介"></a>ARIMA 时间序列模型简介</h2><p>时间序列是研究数据随时间变化而变化的一种算法，是一种预测性分析算法。它的基本出发点就是事物发展都有连续性，按照它本身固有的规律进行。ARIMA(p,d,q)模型全称为差分自回归移动平均模型  (Autoregressive Integrated Moving Average Model,简记 ARIMA). 是比较成熟且简单的时间预测模型之一。其中 AR 为自回归, I 为差分, MA 为移动平均。<br>趋势参数：</p><ul><li>p：趋势自回归阶数。</li><li>d：趋势差分阶数。</li><li>q：趋势移动平均阶数。</li></ul><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分（difference）又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数f(x) 映射到f(x+a)-f(x+b) 。差分运算，相应于微分运算，是微积分中重要的一个概念。总而言之，差分对应离散，微分对应连续。差分又分为前向差分、向后差分及中心差分三种。<br>通常情况下我们用到的是前向差分公式如下：<br>xk&#x3D;x0+kh,(k&#x3D;0,1,…,n)<br>△f(xk)&#x3D;f(xk+1)−f(xk)<br>差分的阶<br>称为阶的差分，即前向阶差分 ，如果数学运用根据数学归纳法，有其中，为二项式系数。特别的，有前向差分有时候也称作数列的二项式变换</p><h2 id="在高锰酸盐指数序列预测可行性的说明"><a href="#在高锰酸盐指数序列预测可行性的说明" class="headerlink" title="在高锰酸盐指数序列预测可行性的说明"></a>在高锰酸盐指数序列预测可行性的说明</h2><p>通过观察水质变化趋势，高锰酸盐指数波动不剧烈，存在明显的中心波动规律。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658496447043-88b405af-1be8-4102-9e18-08920fc56b01.png"></p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> warnings<br><span class="hljs-keyword">import</span> pymysql<br><br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)  <br><span class="hljs-comment"># 忽略警告，不然一大堆警告，多是python及对应包升高导致，不影响使用</span><br><span class="hljs-keyword">from</span> IPython.core.interactiveshell <span class="hljs-keyword">import</span> InteractiveShell<br>InteractiveShell.ast_node_interactivity = <span class="hljs-string">&quot;all&quot;</span><br><span class="hljs-keyword">from</span> matplotlib.pylab <span class="hljs-keyword">import</span> style  <span class="hljs-comment"># 自定义图表风格</span><br>style.use(<span class="hljs-string">&#x27;ggplot&#x27;</span>)<br><br><span class="hljs-comment"># 解决中文乱码问题</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Simhei&#x27;</span>]<br><span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># pip install statsmodels</span><br><br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf, plot_pacf  <span class="hljs-comment"># 自相关图、偏自相关图</span><br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller <span class="hljs-keyword">as</span> ADF  <span class="hljs-comment"># 平稳性检验</span><br><span class="hljs-keyword">from</span> statsmodels.stats.diagnostic <span class="hljs-keyword">import</span> acorr_ljungbox  <span class="hljs-comment"># 白噪声检验</span><br><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm  <span class="hljs-comment"># D-W检验,一阶自相关检验</span><br><span class="hljs-keyword">from</span> statsmodels.graphics.api <span class="hljs-keyword">import</span> qqplot  <span class="hljs-comment"># 画QQ图,检验一组数据是否服从正态分布</span><br><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br></code></pre></td></tr></table></figure><h3 id="连接数据"><a href="#连接数据" class="headerlink" title="连接数据"></a>连接数据</h3><p>通过数据库，excel 都可以，列名为监测时间、设备名称、设备因子、监测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn_sql</span>():<br>    conn = pymysql.connect(host=<span class="hljs-string">&quot; &quot;</span>,<br>                   port= ,<br>                   user=<span class="hljs-string">&quot; &quot;</span>,<br>                   password=<span class="hljs-string">&quot; &quot;</span>,<br>                   db=<span class="hljs-string">&quot; &quot;</span>,<br>                   charset=<span class="hljs-string">&quot;utf8&quot;</span>)<br>    sql = <span class="hljs-string">&quot;&quot;</span><br>    read_sql = pd.read_sql(sql, conn)<br>    <span class="hljs-keyword">return</span> read_sql<br>read_sql=conn_sql()<br></code></pre></td></tr></table></figure><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nseri</span>(<span class="hljs-params">s,y </span>):<br>    aidunqiao = read_sql.loc[read_sql[<span class="hljs-string">&#x27;设备名称&#x27;</span>] == s, :]<br>    ai_cod = aidunqiao.loc[read_sql[<span class="hljs-string">&#x27;监测因子&#x27;</span>] == y, :]<br>    ai_cod_mn = ai_cod.loc[:, [<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&#x27;监测值&#x27;</span>]]<br>    baseline = ai_cod.loc[:, [<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&#x27;监测值&#x27;</span>]]<br><br>    ai_cod_mn.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    interp_cod_mn = ai_cod_mn[<span class="hljs-string">&quot;监测值&quot;</span>].interpolate()<br>    ai_cod_mn[<span class="hljs-string">&quot;cod&quot;</span>] = interp_cod_mn<br>    starttime = baseline.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    rows = baseline.shape[<span class="hljs-number">0</span>]<br>    endtime = baseline.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br>    year_month_day = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<span class="hljs-string">&quot;%Y%m%d%h%m%s&quot;</span>)<br>    a_ser = pd.DataFrame(&#123;<span class="hljs-string">&#x27;监测时间&#x27;</span>: year_month_day&#125;)<br>    a_ser.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df = pd.concat([a_ser, ai_cod_mn], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&quot;outer&quot;</span>)<br>    df = df.reset_index(drop=<span class="hljs-literal">False</span>)<br>    df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br>    df1 = df.drop_duplicates(subset=<span class="hljs-string">&quot;监测时间&quot;</span>, keep=<span class="hljs-string">&quot;last&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2 = df1.sort_values(by=<span class="hljs-string">&quot;监测时间&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2[<span class="hljs-string">&quot;cod&quot;</span>] = df2[<span class="hljs-string">&quot;监测值&quot;</span>].interpolate()<br>    df2.drop(columns=<span class="hljs-string">&quot;监测值&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> df2<br></code></pre></td></tr></table></figure><p>主要是 将数据生成无空连续的逐小时 时间序列数据 插值方法为线性插值</p><h3 id="数据解读"><a href="#数据解读" class="headerlink" title="数据解读"></a>数据解读</h3><h4 id="查看acf"><a href="#查看acf" class="headerlink" title="查看acf"></a>查看acf</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = df2.dropna()<br><span class="hljs-comment"># 解决有nan的问题</span><br>plot_acf(df2,lags=<span class="hljs-number">50</span>).show()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658496966248-a9f853f2-55b2-4728-8ae7-83c26ec56dd7.png"></p><p>解读 拖尾为p 。基本大于0.5 现在和未来有很强的相关性</p><h4 id="单位根检验"><a href="#单位根检验" class="headerlink" title="单位根检验"></a>单位根检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;原始序列的ADF检验结果为：&#x27;</span>,ADF(df2.cod))<br></code></pre></td></tr></table></figure><p>原始序列的ADF检验结果为： (-7.19465930048855, 2.452407467867345e-10, 37, 9199, {‘1%’: -3.431061069214289, ‘5%’: -2.8618542472812902, ‘10%’: -2.5669372687639176}, 11281.50483165621)</p><p>解读：P值小于显著性水平α（0.05），不接受原假设（非平稳序列），说明原始序列是平稳序列。</p><h4 id="白噪声检验"><a href="#白噪声检验" class="headerlink" title="白噪声检验"></a>白噪声检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一阶差分序列的白噪声检验结果为：&#x27;</span>,acorr_ljungbox(df2,lags=<span class="hljs-number">1</span>,return_df =<span class="hljs-built_in">bool</span>))<br></code></pre></td></tr></table></figure><p>一阶差分序列的白噪声检验结果为： lb_stat lb_pvalue 1 7467.631465 0.0</p><p>p值为0小于0.05，不是白噪声</p><p><strong>综上可以采用 arima 模型</strong></p><h4 id="定阶-人工识图"><a href="#定阶-人工识图" class="headerlink" title="定阶 人工识图"></a>定阶 人工识图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#一阶差分，我们不需要这么做，看下代码怎么写的。</span><br>df2_mn=df2.diff(periods=<span class="hljs-number">1</span>, axis=<span class="hljs-number">0</span>).dropna()<br><span class="hljs-comment">#自相关图</span><br>plot_acf(df2,lags=<span class="hljs-number">20</span>).show()<br><span class="hljs-comment">#解读：拖尾 有长期相关性 p 取1 </span><br><span class="hljs-comment">#偏自相关图 </span><br>plot_pacf(df2,lags=<span class="hljs-number">20</span>).show()<br><span class="hljs-comment">#偏自相关图</span><br>plot_pacf(df2,lags=<span class="hljs-number">50</span>).show()<br><span class="hljs-comment">#解读：自相关图，0阶拖尾；偏自相关图，截尾。则ARIMA(p,d,q)=ARIMA(1,0,n)</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497358538-342dc80a-d890-4386-bc8e-ca67ca811fef.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497368903-f3dccfbb-c6e0-4aa7-a86c-e78aab590f93.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497380496-184e826a-d4c3-40a3-aa69-f2413617af0a.png"></p><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><p>AIC调优</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br>aic_matrix=[]<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    tmp=[]<br>    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">try</span>:<br>            tmp.append(ARIMA(df2,order=(p,<span class="hljs-number">0</span>,q)).fit().aic)<br>        <span class="hljs-keyword">except</span>:<br>            tmp.append(<span class="hljs-literal">None</span>)<br>    aic_matrix.append(tmp)<br>aic_matrix<br><br><span class="hljs-comment"># p,q=aic_matrix.stack().idxmin() #最小值的索引</span><br><span class="hljs-comment"># 手动查找最小值 同样为1，0，4</span><br></code></pre></td></tr></table></figure><p>也可以用BIC调优 不再赘述</p><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = ARIMA(df2, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>result_arima = model.fit()<br></code></pre></td></tr></table></figure><h3 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h3><p>定义画图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pic1</span>(<span class="hljs-params">result_arima,df2</span>):<br>    t1 = <span class="hljs-string">&quot;2022/7/6 00:00:00&quot;</span><br>    t2 = <span class="hljs-string">&quot;2022/7/8 00:00:00&quot;</span><br>    predict_more=result_arima.predict(t1 ,t2 )<br>    t = pd.date_range(t1, t2 , freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<span class="hljs-string">&quot;%y%m%d%h%m%s&quot;</span>)<br>    new_ticks = pd.date_range(t1, t2 , freq=<span class="hljs-string">&quot;d&quot;</span>).strftime(<span class="hljs-string">&quot;%y%m%d%h%m%s&quot;</span>)<br>    axc.clear()<br>    axc.set_title(<span class="hljs-string">&quot;局部历史值与真实值对比&quot;</span>)<br>    axc.plot(t,df2[t1 :t2],linestyle = <span class="hljs-string">&quot;--&quot;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    axc.plot(t,predict_more,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>    axc.legend([<span class="hljs-string">&#x27;真实值&#x27;</span>,<span class="hljs-string">&#x27;预测值&#x27;</span>])<br>    axc.set_xticks(new_ticks)   <br><br>    <span class="hljs-comment"># 创建画布控件</span><br>    canvas = FigureCanvasTkAgg(fig1, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497922337-e1e6f543-0dbb-409b-ac68-05a72ef2423a.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fore_picture</span>(<span class="hljs-params">result_arima,df2</span>):<br>    df3 = df2.reset_index(drop=<span class="hljs-literal">False</span>)<br>    rows = df3.shape[<span class="hljs-number">0</span>]<br>    endtime = df3.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    forecast = pd.Series(result_arima.forecast(<span class="hljs-number">48</span>), index=pd.date_range(endtime, periods=<span class="hljs-number">48</span>, freq=<span class="hljs-string">&#x27;H&#x27;</span>))<br>    df_last = df2.iloc[-<span class="hljs-number">48</span>:]    <br>    data = pd.concat((df_last, forecast), axis=<span class="hljs-number">0</span>)<br>    data.columns = [<span class="hljs-string">&#x27;监测值浓度&#x27;</span>, <span class="hljs-string">&#x27;未来48小时&#x27;</span>]<br>    axc2.clear()<br>    axc2.set_title(<span class="hljs-string">&quot;未来48小时预测&quot;</span>)<br>    axc2.plot(data) <br>    <br>        <span class="hljs-comment"># 创建画布控件</span><br>    canvas = FigureCanvasTkAgg(fig2, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">600</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497941233-d0387b16-c1dd-4ec5-a2a4-4162e3be9eec.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare2</span>(<span class="hljs-params">result_arima,df2</span>):<br>    df3 = df2.reset_index(drop=<span class="hljs-literal">False</span>)<br>    rows = df3.shape[<span class="hljs-number">0</span>]<br>    endtime = df3.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    starttime = df3.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    predict=result_arima.predict(starttime , endtime)<br>    axc3.clear()<br>    axc3.set_title(<span class="hljs-string">&quot;全部预测值真实值对比&quot;</span>)<br>    axc3.plot(df2.index,df2[<span class="hljs-string">&#x27;cod&#x27;</span>],linestyle = <span class="hljs-string">&quot;--&quot;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    axc3.plot(df2.index,predict,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>    axc3.legend([<span class="hljs-string">&#x27;真实值&#x27;</span>,<span class="hljs-string">&#x27;预测值&#x27;</span>])<br>    canvas = FigureCanvasTkAgg(fig3, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">1200</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497956069-1c995a76-08cb-44b0-a0b2-9173af977365.png"></p><h3 id="模型可视化及GUI初探"><a href="#模型可视化及GUI初探" class="headerlink" title="模型可视化及GUI初探"></a>模型可视化及GUI初探</h3><p>用Tkinter 实现自动选择站点及因子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 副本</span><br><span class="hljs-keyword">from</span> tkinter.ttk <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span>  tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> matplotlib<br>matplotlib.use(<span class="hljs-string">&#x27;TkAgg&#x27;</span>)<br><span class="hljs-keyword">from</span> matplotlib.backends.backend_tkagg <span class="hljs-keyword">import</span> FigureCanvasTkAgg<br><span class="hljs-keyword">from</span> matplotlib.figure <span class="hljs-keyword">import</span> Figure<br><br>root = Tk()<br>root.title(<span class="hljs-string">&quot;ARIMA预测模型&quot;</span>)<br>root.geometry(<span class="hljs-string">&quot;1800x900+50+50&quot;</span>)  <span class="hljs-comment"># 长x宽+x*y</span><br>           <br>lb1 = Label(root,text=<span class="hljs-string">&#x27;站点选择&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br>lb2 = Label(root,text=<span class="hljs-string">&#x27;因子选择&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br>lb3 = Label(root,text=<span class="hljs-string">&#x27;预测结果（48h）&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br><span class="hljs-comment"># lb4 = Label(root,text=&#x27;历史预测对比&#x27;,fg=&#x27;black&#x27;, font=(&#x27;微软雅黑&#x27;,15),  height=2,  relief=FLAT)</span><br><br><span class="hljs-comment"># lb5 = Label(root,text=comb1.get(),fg=&#x27;black&#x27;, font=(&#x27;微软雅黑&#x27;,15),  height=2,  relief=FLAT)</span><br>lb1.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">20</span>)<br>lb2.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">20</span>)<br>lb3.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">110</span>)<br><span class="hljs-comment"># lb4.place(x=510,y=110)</span><br><span class="hljs-comment"># lb5.place(x=820,y=110)</span><br>var1 = StringVar()<br>comb1= Combobox(root,textvariable=var1,values = site)<br>comb1.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">80</span>)<br>var2 = StringVar()<br>comb2= Combobox(root,textvariable=var2,values=factor)<br>comb2.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_device</span>(<span class="hljs-params">event</span>):<br>    s = comb1.get()<br>    <span class="hljs-built_in">print</span>(s)<br>    <span class="hljs-keyword">return</span> s<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_factor</span> (event):<br>    y = comb2.get()<br>    <span class="hljs-built_in">print</span>(y)<br>    <span class="hljs-keyword">return</span> y<br><br>comb1.bind(<span class="hljs-string">&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;</span>, select_device)<br>comb2.bind(<span class="hljs-string">&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;</span>, select_factor)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">event</span>):<br>    s = comb1.get()<br>    y = comb2.get()<br>    df2 = nseri(s,y )<br>    model = ARIMA(df2, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>    result_arima = model.fit()<br>    <br>    fig1 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc = fig1.add_subplot(<span class="hljs-number">111</span>)<br>    axc.clear()<br>    pic1(result_arima,df2)<br><br>    fig2 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc2 = fig2.add_subplot(<span class="hljs-number">111</span>)<br>    axc2.clear()<br>    fore_picture(result_arima,df2)<br><br>    fig3 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc3 = fig3.add_subplot(<span class="hljs-number">111</span>)<br>    axc3.clear()<br>    compare2(result_arima,df2)    <br>    <br><br>but1 = Button(root, text=<span class="hljs-string">&#x27;计算&#x27;</span>,font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">1</span>)<br>but1.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">110</span>)  <br><br>but1.bind(<span class="hljs-string">&quot;&lt;Button-1&gt;&quot;</span>,click)<br><br>root.mainloop()<br></code></pre></td></tr></table></figure><p>结果预览<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405092131490.png" alt="111.png"></p><h3 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h3><p>模型评价方法： 浓度准确率， 等级准确率</p><p>浓度准确率</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498060055-471dd8e9-e287-4a75-b360-d508cdf45eea.png"></p><p>等级准确率：实测的类别与预测的类别相同时，则视为预测正确，预测正确的个数占预测的总个数的百分比，即为模型预测准确率。指标预测准确率的详细计算方法如下式：<img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405092145737.png" alt="image.png"></p><p>Pi为类别相对误差，T 为验证期内实测值的时间点数，t为实测值与预测值对应的时刻，pit为实测的类别与模拟的类别相比值，如果类别相同则为1，否则为0。</p><h3 id="结果提取"><a href="#结果提取" class="headerlink" title="结果提取"></a>结果提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">format1</span>(<span class="hljs-params">df2</span>):<br>    df7=pd.Series()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">180</span>) :<br>        df3= df2[:-<span class="hljs-number">4</span>*(<span class="hljs-number">1</span>+i)]        <br>        model = ARIMA(df3, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>        result_arima1 = model.fit()<br>        df4 = df3.reset_index(drop=<span class="hljs-literal">False</span>)<br>        rows = df4.shape[<span class="hljs-number">0</span>]<br>        endtime = df4.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        forecast = pd.Series(result_arima1.forecast(<span class="hljs-number">5</span>), index=pd.date_range(endtime, periods=<span class="hljs-number">5</span>, freq=<span class="hljs-string">&#x27;H&#x27;</span>))<br>        df8 = forecast.tail(<span class="hljs-number">1</span>)    <br>        df7 = pd.concat((df7,df8),axis=<span class="hljs-number">0</span>,join=<span class="hljs-string">&#x27;inner&#x27;</span>)<br>    <span class="hljs-keyword">return</span> df7 <br>f2 =format1(df2)<br>f2.to_excel(<span class="hljs-string">&quot;forceful.xls&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>时间原因用的excel 分析</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498412727-7339ba7d-dbd3-407b-ac06-2261972c967d.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498435576-efb265aa-9f0e-452f-84fa-e70509215452.png"></p><p>对比了6月21日~2022&#x2F;7&#x2F;15 高指真实值与预测值的结果，浓度预测准确率为84.61%，等级准确率40.74%，等级准确率偏低的原因为实际监测结果在6附近波动，为Ⅲ类水质标准。<br>预测对比时间窗口存在降雨，实际结果有一定波动，浓度预测准确率能到达84.6%，有一定的推广价值。</p><h3 id="ARIMA-summary-解读"><a href="#ARIMA-summary-解读" class="headerlink" title="ARIMA .summary() 解读"></a>ARIMA .summary() 解读</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1670242073687-2d564dde-6f19-4ae7-9283-b3341ec7dae9.png"></p><ol><li>左上 为模型基本信息，Dep. Variable（需要预测的变量）、Model（模型及其参数）、Date、Time、Sample（样本数据）、No. Observations（观测数据的数量）</li><li>右上 Log Likelihood（对数似然函数）标识最适合采样数据的分布。虽然它很有用，但AIC和BIC会惩罚模型的复杂性，这有助于使我们的ARIMA模型变得简洁。赤池的信息准则（AIC）有助于确定线性回归模型的强度。AIC 会惩罚添加参数的模型，因为添加更多参数将始终增加最大似然值。贝叶斯信息准则（BIC）与 AIC 一样，BIC 也会惩罚模型的复杂性，但它也包含数据中的行数。Hannan-Quinn信息标准（HQIC），与AIC和BIC一样是模型选择的另一个标准；但是它在实践中并不常用。AIC 、BIC 越小越好</li><li>中部 确保模型中的每个项在统计意义上是否显著。若p值大于0.05，则项不显著。</li><li>下部：Ljung-Box（modified Box-Pierce test）测试错误是白噪音 Ljung-Box (L1) (Q) 为Lag1的LBQ检验统计量，其Prob(Q)为 0.01，p值为0.94。由于p值高于0.05，因此我们不能拒绝零假设（误差是白噪音）</li></ol><h3 id="讨论与总结"><a href="#讨论与总结" class="headerlink" title="讨论与总结"></a>讨论与总结</h3><ol><li>ARIMA 模型在高锰酸盐指数上的预测效果超过80%,经过初步研究，适用于水质在线站点。</li><li>模型可用于单站点单因子预测，不需要其他参数，约束小，预测精度高。</li><li>模型对波动剧烈的因子，预测效果不好，不适用于所有因子，所有站点。</li><li>对于新的数据集需要做平稳性检验，白噪声检验。</li><li>需要采用数据人工识图+自动的方式实现定阶，选择最优的 p，d，q。</li><li>可以继续在 ARIMAX（多元时间序列模型）等方面深入研究。</li></ol><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/" title="prophet时间序列模型水质预测应用">prophet时间序列模型水质预测应用</a>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间序列</tag>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian 图床配置  PicGo+ gitee 精简版</title>
    <link href="/2024/04/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE%20%20PicGo+%20gitee%20%E7%B2%BE%E7%AE%80%E7%89%88/"/>
    <url>/2024/04/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE%20%20PicGo+%20gitee%20%E7%B2%BE%E7%AE%80%E7%89%88/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="图床的作用"><a href="#图床的作用" class="headerlink" title="图床的作用"></a>图床的作用</h2><p>图床（Image Hosting Service）是一种在线服务，用于存储和托管用户上传的图片文件。用户可以将图片上传到图床服务器，并获得一个可访问的图片链接，然后可以在网页、博客、论坛等地方使用这个链接来展示图片。<br>通过 PicGo+ gitee 可以搭建免费属于自己的免费图床，当然这里有个风险就是他是开源的可能有资料泄密的风险。</p><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><p>Node. Js<br>Gitee<br>PicGo<br>Obsidian<br>Obsidian 插件 Image auto Upload<br>参考<br><a href="https://blog.csdn.net/m0_72598806/article/details/135693863">picGo+gitee搭建Obsidian(Typora)图床，实现高效写作_obsidian 坚果云 图床-CSDN博客</a><br>具体步骤：</p><h2 id="1-下载-Node-Js"><a href="#1-下载-Node-Js" class="headerlink" title="1. 下载 Node. Js"></a>1. 下载 Node. Js</h2><p>一直下一步即可，注意确保勾选环境变量，一般为默认。<br><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><h2 id="2-下载-PicGo"><a href="#2-下载-PicGo" class="headerlink" title="2. 下载  PicGo"></a>2. 下载  PicGo</h2><p>一直下一步。<br><a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn&#x2F;PicGo (github.com)</a><br>注意 win 下载 exe 版本</p><h2 id="3-配置gitee"><a href="#3-配置gitee" class="headerlink" title="3. 配置gitee"></a>3. 配置gitee</h2><p>新建仓库-配置开源<br>创建个人令牌</p><h2 id="4-配置-picgo"><a href="#4-配置-picgo" class="headerlink" title="4. 配置 picgo"></a>4. 配置 picgo</h2><p>建议设置好后，在上传区上传测试是否成功。<br>Picgo 设置开启开机启动，开启时间戳重命名。<br>一般设置 server 保持默认即可<br>安装插件 gitee 2.0.7</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/PicGo.exe_20250314_213856.png" alt="PicGo.exe_20250314_213856.png"></p><p>图床设置<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/PicGo.exe_20250314_214016.png" alt="PicGo.exe_20250314_214016.png"></p><p>owner: gitee project’s owner name ，具体项目名称<br>repo: gitee project repo， gitee 仓库地址名称<br>例如，在URL <code>https://gitee.com/ownerName/repoName</code>中，<code>ownerName</code>对应<code>owner</code>，而<code>repoName</code>对应<code>repo</code>。<br>Path 为图片文件夹<br>Token 在 gitee 仓库点击头像 -设置-个人令牌里。<br>最后设置好后点击 <code>设为默认图床</code>，否则不生效。<br>记得在上传区测试是否成功，不成功的原因可能是 owner、repo 设置不对。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408252013315.png" alt="image.png"></p><h2 id="5-配置-obsdian"><a href="#5-配置-obsdian" class="headerlink" title="5. 配置 obsdian"></a>5. 配置 obsdian</h2><p>下载安装插件 Image auto Upload<br>设置保持默认即可。</p><p>完成，你可以测试是否成功。</p><p>如果显示失败上传失败不要急。</p><ol><li>检查 picgo  直接上传是否正常</li><li>检查 picgo 设置路径是否正常 token 是否正确，不能有空格</li><li>检查个人仓库地址是否正常，可以测试完整路径或者后面的路径反复尝试。</li><li>重启 picgo 中的设置 server 先关闭后开启</li></ol><p>最后，祝你成功。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian 图床配置  PicGo+ gitee 精简版</title>
    <link href="/2024/04/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE%20%20PicGo+%20gitee%20%E7%B2%BE%E7%AE%80%E7%89%88_%E5%86%B2%E7%AA%81%E6%96%87%E4%BB%B6_chenw_20250619104814/"/>
    <url>/2024/04/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE%20%20PicGo+%20gitee%20%E7%B2%BE%E7%AE%80%E7%89%88_%E5%86%B2%E7%AA%81%E6%96%87%E4%BB%B6_chenw_20250619104814/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="图床的作用"><a href="#图床的作用" class="headerlink" title="图床的作用"></a>图床的作用</h2><p>图床（Image Hosting Service）是一种在线服务，用于存储和托管用户上传的图片文件。用户可以将图片上传到图床服务器，并获得一个可访问的图片链接，然后可以在网页、博客、论坛等地方使用这个链接来展示图片。<br>通过 PicGo+ gitee 可以搭建免费属于自己的免费图床，当然这里有个风险就是他是开源的可能有资料泄密的风险。</p><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><p>Node. Js<br>Gitee<br>PicGo<br>Obsidian<br>Obsidian 插件 Image auto Upload<br>参考<br><a href="https://blog.csdn.net/m0_72598806/article/details/135693863">picGo+gitee搭建Obsidian(Typora)图床，实现高效写作_obsidian 坚果云 图床-CSDN博客</a><br>具体步骤：</p><h2 id="1-下载-Node-Js"><a href="#1-下载-Node-Js" class="headerlink" title="1. 下载 Node. Js"></a>1. 下载 Node. Js</h2><p>一直下一步即可，注意确保勾选环境变量，一般为默认。<br><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><h2 id="2-下载-PicGo"><a href="#2-下载-PicGo" class="headerlink" title="2. 下载  PicGo"></a>2. 下载  PicGo</h2><p>一直下一步。<br><a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn&#x2F;PicGo (github.com)</a><br>注意 win 下载 exe 版本</p><h2 id="3-配置gitee"><a href="#3-配置gitee" class="headerlink" title="3. 配置gitee"></a>3. 配置gitee</h2><p>新建仓库-配置开源<br>创建个人令牌</p><h2 id="4-配置-picgo"><a href="#4-配置-picgo" class="headerlink" title="4. 配置 picgo"></a>4. 配置 picgo</h2><p>安装插件 gitee-uplodaer<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202403151107812.png" alt="image.png"></p><p>图床设置 - gitee<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202403151108050.png" alt="image.png"></p><p>Repo 输入 gitee 仓库地址<br>Path 为图片文件夹<br>Token 在 gitee 仓库点击头像 -设置-个人令牌里。<br>最后设置好后一定记得设置为默认，否则不生效。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202408252013315.png" alt="image.png"></p><p>建议设置好后，在上传区上传测试是否成功。<br>Picgo 设置开启开机启动，开启时间戳重命名。<br>一般设置 server 保持默认即可</p><h2 id="5-配置-obsdian"><a href="#5-配置-obsdian" class="headerlink" title="5. 配置 obsdian"></a>5. 配置 obsdian</h2><p>下载安装插件 Image auto Upload<br>设置保持默认即可。</p><p>完成，你可以测试是否成功。</p><p>如果显示失败上传失败不要急。</p><ol><li>检查 picgo  直接上传是否正常</li><li>检查 picgo 设置路径是否正常 token 是否正确，不能有空格</li><li>检查个人仓库地址是否正常，可以测试完整路径或者后面的路径反复尝试。</li><li>重启 picgo 中的设置 server 先关闭后开启</li></ol><p>最后，祝你成功。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian  微信读书 插件 weread 强烈推荐</title>
    <link href="/2024/04/09/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%20%E6%8F%92%E4%BB%B6%20weread%20%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/04/09/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%20%E6%8F%92%E4%BB%B6%20weread%20%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在用 obsidian，一入 ob 深似海，从此语雀是路人。<br>今天强烈推荐喜欢用微信读书的人，使用它，1+1＞2。两大神级软件助你起飞。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>第三方软件搜索 weread ，点击下载、启用。</p><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404100917769.png" alt="image.png"></p><ol><li>微信登录账号</li><li>设置保存位置</li><li>设置文件名模板</li><li>设置文件夹分类</li><li>可自定义文件模板，我并没有修改。</li><li>点击同步左侧书籍按钮即可同步。</li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>现将使用效果写在前面。</p><ol><li>一键简单设置，只需要登录即可同步所有微信读书阅读笔记。</li><li>书籍按照分类自动新建笔记和文件夹，体验知识积累的快感</li><li>鼓励做书摘，做卡片笔记。让知识更好的沉淀，而不是写过之后就忘了。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404100919162.png" alt="image.png"></p><p>看着自己阅读的书籍全部展示出来，成就感满满。</p><h2 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h2><p>在使用中也发现，不能直接修改同步的文字，因为一旦同步，写在本地的文字也会覆盖。<br>但我们可以通过在本地认真写好读书笔记后，在微信读书上发布，然后再同步，这样就可以两边都有了。</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 等声值线的绘制</title>
    <link href="/2024/04/03/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E7%AD%89%E5%A3%B0%E5%80%BC%E7%BA%BF%E7%9A%84%E7%BB%98%E5%88%B6/"/>
    <url>/2024/04/03/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/python%20%E7%AD%89%E5%A3%B0%E5%80%BC%E7%BA%BF%E7%9A%84%E7%BB%98%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要通过 python 实现风电风机点声源的等声值线绘制。</p><h3 id="风电噪声原理及背景"><a href="#风电噪声原理及背景" class="headerlink" title="风电噪声原理及背景"></a>风电噪声原理及背景</h3><p>风电项目噪声为一个面源，与普通点源不同， 风机噪声源主要包括：机舱内部零部件（齿轮箱和发电机等）运转过程中产生的噪 声、叶片旋转过程中的结构振动噪声和风轮叶片旋转时产生的空气动力学噪声（即气动 噪声）。目前风电机组机舱内部零件噪声和结构振动噪声已得到很好的控制，风电机组 的噪声影响主要来自叶片气动噪。叶片气动噪声是在入流扰动和塔架扰动下的非定常流场和叶片相互作用下，气流流 经叶片界面产生附着涡、分离涡和尾迹脱落涡等，这些非定常涡和叶片表面相互作用从 而引起的非稳定流动噪声。<br>翟国庆等利用美国航天航空局（NASA）研发的风电机组噪声预测模型，结合国内风机特点和风机噪声实际测量值对做出的模型修正提出了对 国内的风电机组噪声预测模型，但模型较复杂且需要的参数较多。根据其模型简化与实 测比对研究的结果，当噪声预测点距风电机组较近（水平距离 d≤2 倍风轮半）时， 噪声测量值不能用点声源模型进行较好预测；当噪声测点距离风电机组较远（水距离 d≥2 倍风轮半径）时，下风向噪声预测点的预测结果与实测值拟合系数明显，一般 可达到 0.95 以上，拟合效果较好。国外学者 Makarewicz 也用数学方法证明了预测点 距风电水平距离大于 2 倍叶片长度即 1 倍风轮直径时，风机叶片噪声符合自声场点声 源的特点；谷朝军等的实测研究结果也表明，在下风向 4 倍叶片长度距离，距离每增 加 1 倍风机噪声约衰减 6dB(A)，基本满足点声源的传播规律。</p><p>将风机噪声贡献简化为以下情况：<br>风机直径w&#x3D;120， d 为 预测点与噪声源的距离，m。<br>LA(d) 为预测点（距离 r）的噪声值，dB（A）；<br>LAW 为噪声源的声功率级，dB（A）赋值109<br>当d&lt;w&#x2F;π&#x2F;2时，LA几乎不变；<br>当d&lt;w&#x2F;π&gt;d&gt;w&#x2F;π&#x2F;2时 ,LA(d) &#x3D; LAW-10lgd<br>当d&gt;w&#x2F;π时，LA(d) &#x3D; LAW-20lgd-8</p><h2 id="Python-代码片段"><a href="#Python-代码片段" class="headerlink" title="Python 代码片段"></a>Python 代码片段</h2><p>根据以上要求可以使用 python 进行绘制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 设置中心点的坐标和地图范围</span><br>center_x = <span class="hljs-number">0</span><br>center_y = <span class="hljs-number">0</span><br>radius = <span class="hljs-number">500</span><br>w = <span class="hljs-number">120</span>  <span class="hljs-comment"># 风机直径</span><br><br><span class="hljs-comment"># 计算网格点的坐标</span><br>x = np.linspace(-radius, radius, <span class="hljs-number">1000</span>)<br>y = np.linspace(-radius, radius, <span class="hljs-number">1000</span>)<br>X, Y = np.meshgrid(x, y)<br><br><span class="hljs-comment"># 计算每个点的距离和噪声值</span><br>d = np.sqrt(X**<span class="hljs-number">2</span> + Y**<span class="hljs-number">2</span>)<br><br>LA = np.zeros_like(d)<br>LA[d &lt; w/(<span class="hljs-number">2</span>*np.pi)] = <span class="hljs-number">109</span><br>LA[(d &gt; w/(<span class="hljs-number">2</span>*np.pi)) &amp; (d &lt; w)] = <span class="hljs-number">109</span> - <span class="hljs-number">10</span> * np.log10(d[(d &gt; w/(<span class="hljs-number">2</span>*np.pi)) &amp; (d &lt; w)])<br>LA[d &gt; w] = <span class="hljs-number">109</span> - <span class="hljs-number">20</span> * np.log10(d[d &gt; w]) - <span class="hljs-number">8</span><br><br><span class="hljs-comment"># 背景噪声值</span><br>B = <span class="hljs-number">40</span><br><br><span class="hljs-comment"># 叠加背景噪声值</span><br>LA_total = <span class="hljs-number">10</span> * np.log10(<span class="hljs-number">10</span>**(<span class="hljs-number">0.1</span>*LA) + <span class="hljs-number">10</span>**(<span class="hljs-number">0.1</span>*B))<br><br><span class="hljs-comment"># 绘制等声值线图</span><br>plt.figure(figsize=(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), dpi=<span class="hljs-number">300</span>)<br>plt.contourf(X, Y, LA_total, levels=np.arange(<span class="hljs-number">40</span>, <span class="hljs-number">111</span>, <span class="hljs-number">10</span>), cmap=<span class="hljs-string">&#x27;RdYlGn_r&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>plt.colorbar(label=<span class="hljs-string">&#x27;Total Sound Level (dB)&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Total Sound Contour Map&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/681168/1700129676174-68d67753-a6bf-4be0-b2cf-117807acea3e.png"></p><h3 id="图片美化"><a href="#图片美化" class="headerlink" title="图片美化"></a>图片美化</h3><p>利用ps 将带比例尺的背景图与预测结果叠加即可。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/681168/1700129739686-72e0ac33-2dc9-41f4-a961-264f36f204b5.png"></p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>王跃华. 风电场噪声、光影环境防护距离的研究[D].东北大学,2011.</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客： <a href="https://maoyu92.github.io/">https://maoyu92.github.io/</a></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生态环境</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
