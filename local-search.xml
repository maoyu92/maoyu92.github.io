<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>edge 学习工具包推荐</title>
    <link href="/2024/07/11/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%95%B0%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%85%AC%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/07/11/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E6%95%B0%E5%AD%A6%E6%B1%82%E8%A7%A3%E5%85%AC%E5%BC%8F%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>推荐微软推出的学习工具包两项工具：数学求解器和 pdf 阅读器。<br>打开 edge 学习工具包的方法 ：右上角三点-更多工具-学习工具包。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110942207.png" alt="image.png"></p><h3 id="math-solver"><a href="#math-solver" class="headerlink" title="math solver"></a>math solver</h3><p> 除了基础的计算求解外，还用图标展示公式，清晰直观。<br>地址：<a href="https://mathsolver.microsoft.com/zh/solver">求解 | Microsoft Math Solver</a><br>示例 1<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110928751.png" alt="image.png"><br>示例 2<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110929108.png" alt="image.png"></p><h3 id="pdf-阅读器"><a href="#pdf-阅读器" class="headerlink" title="pdf 阅读器"></a>pdf 阅读器</h3><p>除了数学求解，edge 推出的学习工具包中的 pdf 查看器也非常有用。这个作为轻量阅读管理已经非常够用了，相信很多人已经在用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407110931115.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Streamlit 多页面应用设计指南：构建模块化数据分析平台</title>
    <link href="/2024/07/10/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/07/10/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%20%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在开发数据分析网页应用时，我们常常面临一个难题：如何在一个项目中优雅地管理多个子应用，同时保证代码的可读性与维护性。单一的长文件不仅难以管理，而且在IDE中操作时容易出现性能问题。<br>通过Streamlit库，能够实现快速搭建模块化的数据分析应用，以应对复杂的数据分析需求。</p><h2 id="困扰与需求"><a href="#困扰与需求" class="headerlink" title="困扰与需求"></a>困扰与需求</h2><p>在制作数据分析网页的过程中，我曾遇到以下困扰：</p><ul><li><strong>页面限制与逻辑关联</strong>：为了提高用户体验，我们需要将功能相关的部分组织在一起，形成逻辑清晰的多个页面。</li><li><strong>代码管理难题</strong>：将所有功能塞入一个文件会导致代码冗长，降低开发效率和代码质量。</li><li><strong>IDE性能问题</strong>：大型文件在VSCode等编辑器中加载和代码分析时，可能会遭遇卡顿问题。<br>基于以上困扰，我们的目标是：</li></ul><ol><li><strong>实现多应用展示</strong>：利用Streamlit构建具有多个界面的网页应用，每个界面专注于不同的数据分析任务。</li><li><strong>子应用独立开发</strong>：确保每个子应用的代码逻辑清晰，独立于其他应用，便于开发和后续维护。</li><li><strong>算法与框架分离</strong>：将算法实现和框架结构分开存储，以促进代码的复用和扩展性。</li></ol><h2 id="设计与实施策略"><a href="#设计与实施策略" class="headerlink" title="设计与实施策略"></a>设计与实施策略</h2><p>为了达成上述目标，我们可以采取以下设计策略：</p><h3 id="模块化编码"><a href="#模块化编码" class="headerlink" title="模块化编码"></a>模块化编码</h3><ul><li><strong>建立子应用模块</strong>：为每个子应用创建独立的<code>.py</code>文件，如<code>weather_city.py</code>和<code>weather_country.py</code>，每个文件专注于一个特定的分析任务。</li><li><strong>定义<code>app()</code>函数</strong>：在每个子应用模块中，定义一个<code>app()</code>函数，该函数封装了整个子应用的逻辑流程和Streamlit界面元素。</li></ul><h3 id="构建页面路由"><a href="#构建页面路由" class="headerlink" title="构建页面路由"></a>构建页面路由</h3><ul><li><strong>使用字典映射</strong>：创建一个字典<code>PAGES</code>，其键是页面名称，值是对应子应用模块的引用。</li><li><strong>实现页面选择</strong>：在主应用文件中，使用Streamlit的<code>sidebar</code>和<code>selectbox</code>组件，让用户选择要查看的页面。</li></ul><h3 id="分离算法与框架"><a href="#分离算法与框架" class="headerlink" title="分离算法与框架"></a>分离算法与框架</h3><ul><li><strong>算法与业务逻辑分离</strong>：将复杂的算法和数据处理逻辑封装在单独的模块或类中，与Streamlit的UI逻辑解耦。</li><li><strong>框架结构清晰</strong>：保持主应用文件简洁，仅负责页面路由和基本的布局设置，具体功能实现在子应用模块中。</li></ul><h3 id="应用框架"><a href="#应用框架" class="headerlink" title="应用框架"></a>应用框架</h3><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407101700103.png" alt="image.png"><br>框架包括一个主程序和很多子程序，子程序用__init__.py 作为一个包，让主程序能够很好的调用。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="mian-weathers"><a href="#mian-weathers" class="headerlink" title="mian_weathers"></a>mian_weathers</h3><p>主程序, 这里用的下拉框来选择，也可以用 radio 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">from</span> pages <span class="hljs-keyword">import</span> weather_city, weather_contry<br><span class="hljs-comment"># 创建一个字典来映射页面标题到页面函数</span><br>PAGES = &#123;<br>    <span class="hljs-string">&quot;公共雨量站&quot;</span>: weather_city,<br>    <span class="hljs-string">&quot;区内气象站&quot;</span>: weather_contry,<br>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    st.sidebar.title(<span class="hljs-string">&#x27;导航&#x27;</span>) <br>    selected_page = st.sidebar.selectbox(<span class="hljs-string">&quot;选择页面&quot;</span>, <span class="hljs-built_in">list</span>(PAGES.keys()))<br>    <span class="hljs-comment"># 根据用户选择的页面调用相应的函数</span><br>    page = PAGES[selected_page]  <br>    page.app() <br></code></pre></td></tr></table></figure><h3 id="weather-contry"><a href="#weather-contry" class="headerlink" title="weather_contry"></a>weather_contry</h3><p>相当于 page 1，注意子程序所在的 pages 文件夹需要有__init__.py 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pages/weather_contry.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>():<br>    st.title(<span class="hljs-string">&#x27;区内气象站&#x27;</span>)<br>    <span class="hljs-comment"># 页面的具体内容</span><br>    st.header(<span class="hljs-string">&#x27;这是页面2的内容&#x27;</span>)<br>    st.text(<span class="hljs-string">&#x27;这是页面2的示例文本。&#x27;</span>)<br>    st.checkbox(<span class="hljs-string">&#x27;这是一个复选框&#x27;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app()<br></code></pre></td></tr></table></figure><h3 id="weather-city"><a href="#weather-city" class="headerlink" title="weather_city"></a>weather_city</h3><p>相当于 page 2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pages/weather_city.py</span><br><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">app</span>():<br>    st.title(<span class="hljs-string">&#x27;公共雨量站&#x27;</span>)<br>    <span class="hljs-comment"># 页面的具体内容</span><br>    st.header(<span class="hljs-string">&#x27;这是页面1的内容&#x27;</span>)<br>    st.text(<span class="hljs-string">&#x27;这是一个示例文本，用于演示页面1的功能。&#x27;</span>)<br>    st.button(<span class="hljs-string">&#x27;点击我！&#x27;</span>)     <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    app()<br></code></pre></td></tr></table></figure><p>注意子程序所在的 pages 文件夹需要有__init__. Py 文件，让所有的子程序被视为一个包，这样主程序才能 import。该文件可以为空，也可以增加一些属性。示例如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">This is the package documentation string.</span><br><span class="hljs-string">It describes what the package does and how to use it.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>__author__ = <span class="hljs-string">&quot;Your Name&quot;</span><br>__version__ = <span class="hljs-string">&quot;1.0&quot;</span><br></code></pre></td></tr></table></figure><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>运行结果如下。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407101711871.png" alt="image.png"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过采用模块化的设计思路，我们可以有效地管理和扩展Streamlit应用，使其既能满足复杂的数据分析需求，又能保持代码的整洁与高效。这种策略不仅提升了开发体验，还为未来的功能迭代奠定了坚实的基础。</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>纯个人经验，如有帮助，请收藏点赞，如需转载，请注明出处。<br>微信公众号：环境猫 er<br>CSDN : 细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">wallflowers (maoyu92.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>生态环境</tag>
      
      <tag>数据分析</tag>
      
      <tag>streamlit</tag>
      
      <tag>数据可视化</tag>
      
      <tag>工作总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSTM水质预测模型实践</title>
    <link href="/2024/07/03/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/LSTM%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/07/03/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/LSTM%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="0-引言"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言</h2><p>随着水质自动站的普及，监测频次越来越高，自动监测越来越准确。<br>水质站点增多，连续的水质监测数据，给水质预测提供更多的训练基础。<br>长短时记忆网络(LSTM)适用于多变量、连续、自相关的数据预测。<br>人工神经网络模型特点为的非线性映射，是广泛应用的水质预测方法。  </p><h2 id="1-长短时记忆网络-LSTM-介绍"><a href="#1-长短时记忆网络-LSTM-介绍" class="headerlink" title="1.长短时记忆网络(LSTM)介绍"></a>1.长短时记忆网络(LSTM)介绍</h2><h3 id="1-1起源"><a href="#1-1起源" class="headerlink" title="1.1起源"></a>1.1起源</h3><p>1997年，Hochreiter等提出了长短时记忆网络(LSTM)，作为深度学习的一种，LSTM既考虑了多元变量间的非线性映射关系，又可以解决传统人工神经网络不能解决的时间序列长期依赖问题，应用场景包括：金融交易、交通预测、机器翻译、水质预测等。</p><h3 id="1-2原理"><a href="#1-2原理" class="headerlink" title="1.2原理"></a>1.2原理</h3><p>长短时记忆网络(LSTM)是在循环神经网络(ＲNN）的基础上改进而来。<br>循环神经网络(ＲNN)作为深度学习方法的一种，其主要用途是对序列数据处理。ＲNN具有自连接隐层，其t时刻隐层状态依靠t－1时刻隐层状态进行更新，因此能够解决时间序列长期依赖的问题。ＲNN理论上可以进行非线性时间序列的有效处理，但实际对较长时间序列进行建模应用中，存在梯度消失及梯度爆炸的问题。<br>LSTM是ＲNN的一种变体，与ＲNN一样，LSTM隐藏层具有随时间序列的重复节点。LSTM节点相较ＲNN更为复杂，它将ＲNN中隐含层中的神经元替换为记忆体，以此实现序列信息的保留与长期记忆。<br>一个标准的LSTM记忆体见图1。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663652672734-10851708-7675-40c3-80f4-0abab324b2c2.png#averageHue=%23efefef&clientId=ufe0eeb19-9d7f-4&from=paste&height=504&id=u21eaafa6&originHeight=504&originWidth=857&originalType=binary&ratio=1&rotation=0&showTitle=true&size=69788&status=done&style=none&taskId=u80d6d931-8107-43cd-9531-08bd4184918&title=%E5%9B%BE1%20LSTM%20%E8%AE%B0%E5%BF%86%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE&width=857" alt="图1 LSTM 记忆体示意图" title="图1 LSTM 记忆体示意图"><br>图 1 中，C 为 LSTM 记忆体的细胞状态，h 为节点的隐藏层状态。每个记忆体包含一到多个记忆细胞和 3 种“门”，LSTM 通过记忆细胞进行细胞状态信息存储，门结构负责细胞状态的更新与保持，3 种 “门”包括“遗忘门”“输入门”和“输出门”。“遗忘门”控制历史信息对当前细胞状态的影响。$f_t$ 决定了上一时刻细胞状态 $C_{t -1}$ 的通过程度。<br>$$f_t&#x3D;σ(w_f[h_{t-1},x_i]+bi)\tag{01}$$<br>$C_{t -1}$ 为t － 1 时刻细胞状态；ht － 1为t － 1 时刻隐藏层状态; σ 为sigmoid 激活函数; wf 为输入循环权重; Xt 为当前时刻节点的输入值；bf 为偏置项。“输入门”决定了进入记忆细胞的是哪些信息，“遗忘门”与“输入门”结合可以实现细胞状态Ct 的更新。    </p><p>  $$i_t&#x3D;σ(w_i[h_{t-1},x_i]+b_i)\tag{02}$$</p><p>$$C_t^‘&#x3D;Tanh(w_C[h_{t-1},x_i]+b_C)\tag{03}$$<br>$$C_t&#x3D;f_iC_{t-1}+i_tC_t^‘\tag{04}$$<br>式中it 为输入门向量值; C’t为新信息; Ct 为t 时刻，细胞状态; bi、bC 为偏置项; wC 为输入权重。<br>“输出门”控制细胞状态值的输出，用Tanh 激活函数处理细胞状态后，与记忆单元状态值相乘得到输出信息。<br>$$σ_t&#x3D;σ(w_o[h_{t-1},x_t]+b_o)\tag{05}$$<br>$$h_t&#x3D;o_t×Tanh(C_t)\tag{06}$$<br>式中 $h_t$ 为t 时刻隐藏层状态; $w_o$ 为输入权重; $o_t$ 为输出值; $b_o$ 为偏置项。<br>由上式可以看出，LSTM 节点通过门结构对细胞状态上的信息进行线性修改，从而保证在时间序列变长的情况下，依然能够保持时间相关性不会衰减。  </p><h2 id="2-算法流程及评价指标"><a href="#2-算法流程及评价指标" class="headerlink" title="2.算法流程及评价指标"></a>2.算法流程及评价指标</h2><h3 id="2-1-算法流程"><a href="#2-1-算法流程" class="headerlink" title="2.1 算法流程"></a>2.1 算法流程</h3><p>模型包括2个部分，分别为模型预处理与模型训练与评价。  </p><h4 id="2-1-1-数据预处理"><a href="#2-1-1-数据预处理" class="headerlink" title="2.1.1 数据预处理"></a>2.1.1 数据预处理</h4><p>数据预处理分为引入前处理及引入后处理。  </p><h5 id="引入前处理"><a href="#引入前处理" class="headerlink" title="引入前处理"></a>引入前处理</h5><p>引入前使用sql语句进行预处理，主要是去除0值、空值、异常值。这里异常值判断依据基于设备上下限、及经验。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span>  <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span><br>            <span class="hljs-keyword">CASE</span> device_id<br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;87d39a3c&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点D&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;2ab9a08e&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点C&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;17b96c2b&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点B&#x27;</span><br>             <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;e83005a1&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;站点A&#x27;</span><br>                       <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;device_name&#x27;</span> ,<br>                       data_time <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;data_time&#x27;</span>,<br>                       <span class="hljs-keyword">CASE</span> factor_code<br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01003-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;浊度&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w21003-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;氨氮&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01010-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;水温&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01014-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;电导率&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01019-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;高指&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01001-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;PH&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w21011-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;总磷&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w01009-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;溶解氧&#x27;</span><br>                       <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;w21001-Avg&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;总氮&#x27;</span><br>                     <span class="hljs-keyword">END</span> <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;fator_code&#x27;</span>,<br>                       <span class="hljs-keyword">value</span> <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;value&#x27;</span><br>                      <span class="hljs-keyword">FROM</span> iot_devices_detail<br>                      <span class="hljs-keyword">where</span> device_id <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;87d39a3c&#x27;</span>,<span class="hljs-string">&#x27;2ab9a08e&#x27;</span>,<span class="hljs-string">&#x27;17b96c2b&#x27;</span>,<span class="hljs-string">&#x27;e83005a1&#x27;</span>)<br>                      <span class="hljs-keyword">and</span> data_time <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2021-01-01 00:00:00&#x27;</span><br>                      <span class="hljs-keyword">and</span> factor_code <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;w21003-Avg&#x27;</span>,<span class="hljs-string">&#x27;w21011-Avg&#x27;</span>,<span class="hljs-string">&#x27;w01019-Avg&#x27;</span>)<br>                      <span class="hljs-keyword">and</span> frequency<span class="hljs-operator">=</span><span class="hljs-string">&#x27;h4&#x27;</span><br>                      <span class="hljs-keyword">and</span> <span class="hljs-keyword">value</span><span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br>                       <span class="hljs-keyword">AND</span> <span class="hljs-keyword">value</span>  <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span><br>                       <span class="hljs-keyword">and</span>  flag<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span><br>                       <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> data_time,factor_code,device_id<br>                       <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> device_id,factor_code) d<br>                       <span class="hljs-keyword">WHERE</span><br>                         d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;高指&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span><br>                        <span class="hljs-keyword">or</span>  d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;总磷&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1.5</span><br>                        <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;氨氮&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">150</span><br>                        <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;浊度&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4000</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;水温&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">60</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;电导率&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">2000</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;PH&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">14</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;溶解氧&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">20</span><br>                         <span class="hljs-keyword">or</span> d.fator_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;总氮&#x27;</span> <span class="hljs-keyword">and</span> d.value <span class="hljs-keyword">between</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>py引入可使用MySQL语句<br>其中sql为上面的代码，注意去掉换行符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn_sql</span>(<span class="hljs-params">sql</span>):<br><br>    conn = pymysql.connect(host=<span class="hljs-string">&quot;&quot;</span>,<br>                   port=<span class="hljs-number">3306</span>,<br>                   user=<span class="hljs-string">&quot;&quot;</span>,<br>                   password=<span class="hljs-string">&quot;&quot;</span>,<br>                   db=<span class="hljs-string">&quot;&quot;</span>,<br>                   charset=<span class="hljs-string">&quot;utf8&quot;</span>)<br>    sql = sql<br><br>    read_sql = pd.read_sql(sql, conn)<br><br>    <span class="hljs-keyword">return</span> read_sql<br><span class="hljs-comment"># read_sql=conn_sql()</span><br><span class="hljs-comment"># 定义链接数据库 </span><br>df = conn_sql(sql)<br></code></pre></td></tr></table></figure><h5 id="引入后处理"><a href="#引入后处理" class="headerlink" title="引入后处理"></a>引入后处理</h5><p>py数据处理内容为空值补全，补全方法为生成连续一小时时间序列index，数据拼接，数据线性插值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dataprocess_en</span>(<span class="hljs-params">df, s, y</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    df:DataFrame时间序列数据;</span><br><span class="hljs-string">    s:device_name</span><br><span class="hljs-string">    y:fator_code</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    aidunqiao = df.loc[df[<span class="hljs-string">&quot;device_name&quot;</span>] == s, :]<br>    ai_cod = aidunqiao.loc[df[<span class="hljs-string">&quot;fator_code&quot;</span>] == y, :]<br>    ai_cod_mn = ai_cod.loc[:, [<span class="hljs-string">&quot;data_time&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>]]<br>    baseline = ai_cod.loc[:, [<span class="hljs-string">&quot;data_time&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>]]<br><br>    ai_cod_mn.set_index(<span class="hljs-string">&quot;data_time&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    interp_cod_mn = ai_cod_mn[<span class="hljs-string">&quot;value&quot;</span>].interpolate()<br>    ai_cod_mn[<span class="hljs-string">&quot;value_2&quot;</span>] = interp_cod_mn<br>    starttime = baseline.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    rows = baseline.shape[<span class="hljs-number">0</span>]<br>    endtime = baseline.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br>    year_month_day = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<br>        <span class="hljs-string">&quot;%Y%m%d%h%m%s&quot;</span><br>    )<br>    a_ser = pd.DataFrame(&#123;<span class="hljs-string">&quot;data_time&quot;</span>: year_month_day&#125;)<br>    a_ser.set_index(<span class="hljs-string">&quot;data_time&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df = pd.concat([a_ser, ai_cod_mn], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&quot;outer&quot;</span>)<br>    df = df.reset_index(drop=<span class="hljs-literal">False</span>)<br>    df[<span class="hljs-string">&quot;data_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;data_time&quot;</span>])<br>    df1 = df.drop_duplicates(subset=<span class="hljs-string">&quot;data_time&quot;</span>, keep=<span class="hljs-string">&quot;last&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2 = df1.sort_values(by=<span class="hljs-string">&quot;data_time&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2[<span class="hljs-string">&quot;value_2&quot;</span>] = df2[<span class="hljs-string">&quot;value&quot;</span>].interpolate()<br>    df2.drop(columns=<span class="hljs-string">&quot;value&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.set_index(<span class="hljs-string">&quot;data_time&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.columns = [s]<br><br>    <span class="hljs-keyword">return</span> df2<br></code></pre></td></tr></table></figure><p>数据输出结果为，指定站点，制定因子的连续一小时监测结果。<br>引入数据后根据dataprocess_en，计算并拼接为最终预测基础数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">station = df[<span class="hljs-string">&quot;device_name&quot;</span>].unique()<br>factors = df[<span class="hljs-string">&quot;fator_code&quot;</span>].unique()<br>dfn= pd.DataFrame()<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(factors)):<br>    dfn= pd.DataFrame()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(station)):<br>        <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;df_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,j)] = data_process.dataprocess_en(df,station[i],factors[j])<br>        <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;dm&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(j)] = pd.concat([dfn, <span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;df_&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i,j)]],axis=<span class="hljs-number">1</span>)<br>        dfn=<span class="hljs-built_in">globals</span>()[<span class="hljs-string">&#x27;dm&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(j)]<br></code></pre></td></tr></table></figure><p>以上代码将输出dm0，dm1，dm2，不同因子的预测数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将需要预测的数据放在首列</span><br>pred_col= [<span class="hljs-string">&#x27;站点A&#x27;</span>]<br>all_cols = dm0.columns.values.tolist()<br>new_cols = pred_col + all_cols<br>new_cols = pd.Series(pred_col + all_cols).drop_duplicates()<br></code></pre></td></tr></table></figure><p>当然也可以用比较直接的方式拼接数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">yx =<span class="hljs-string">&quot;站点B&quot;</span><br>fh =<span class="hljs-string">&quot;站点C&quot;</span><br>bl =<span class="hljs-string">&quot;站点D&quot;</span><br>cb = <span class="hljs-string">&quot;站点A&quot;</span><br>cod =<span class="hljs-string">&quot;高指&quot;</span><br>tp =<span class="hljs-string">&quot;总磷&quot;</span><br>nh3 =<span class="hljs-string">&quot;氨氮&quot;</span><br>df_cb_tp  =data_process.dataprocess_en(df,cb,tp)<br>df_yx_tp  =data_process.dataprocess_en(df,yx,tp)<br>df_fh_tp  =data_process.dataprocess_en(df,fh,tp)<br>df_bl_tp  =data_process.dataprocess_en(df,bl,tp)<br>df2 = pd.concat([df_cb_tp ,df_yx_tp,df_fh_tp,df_bl_tp],axis=<span class="hljs-number">1</span>)<br>df2=df2[-<span class="hljs-number">3000</span>:] <span class="hljs-comment"># 取近3000个数据，保证运算速度和数据的更新程度</span><br><span class="hljs-comment"># df2=df2[::4] 可以取逐4小时值</span><br></code></pre></td></tr></table></figure><p>以上数据准备结束，总磷预测数据集示例如下，第一列站点A为预测因变量。data_time为index</p><table><thead><tr><th>data_time（index）</th><th>站点A</th><th>站点B</th><th>站点C</th><th>站点D</th></tr></thead><tbody><tr><td>2022-05-17 05:00:00</td><td>0.1955</td><td>0.250125</td><td>0.24355</td><td>0.247800</td></tr><tr><td>2022-05-17 06:00:00</td><td>0.1950</td><td>0.247950</td><td>0.24340</td><td>0.243100</td></tr><tr><td>2022-05-17 07:00:00</td><td>0.1945</td><td>0.245775</td><td>0.24325</td><td>0.238400</td></tr><tr><td>2022-05-17 08:00:00</td><td>0.1940</td><td>0.243600</td><td>0.24310</td><td>0.233700</td></tr><tr><td>2022-05-17 09:00:00</td><td>0.1885</td><td>0.240850</td><td>0.24290</td><td>0.230225</td></tr></tbody></table><h4 id="2-1-2-模型搭建与训练"><a href="#2-1-2-模型搭建与训练" class="headerlink" title="2.1.2 模型搭建与训练"></a>2.1.2 模型搭建与训练</h4><p>模型框架为<br>训练阶段 预测站点窗口滑动，<br>从结构示例图看，若样本窗口数量为30，样本列数（含预测站点）为n，则框中红点数据为预测数据，其余数据为训练因变量，通过模型建立非线性关系。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663663432052-55b1e6db-d4ec-4bd9-8631-b2d7b2199bea.png#averageHue=%23f6f3f0&clientId=ufe0eeb19-9d7f-4&from=paste&height=551&id=uc3d05be0&originHeight=551&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40481&status=done&style=none&taskId=ucec855ed-b6bf-4bdb-a80a-acedeb93734&title=&width=497" alt="image.png"><br>为了实现预测效果，采用滑动时间滑动技术，生成训练基础数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663663771478-e1661a14-bcac-41f6-a348-90954f4a7142.png#averageHue=%23f7f2f0&clientId=ufe0eeb19-9d7f-4&from=paste&height=626&id=u0a432b18&originHeight=626&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54023&status=done&style=none&taskId=uf5c4e634-8b83-4f7e-ad9c-c32ddc162a7&title=&width=960" alt="image.png"></p><p>本次模型搭建采用tensorflower框架，面向对象编程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入相关包</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Dense, LSTM, Dropout<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br><span class="hljs-keyword">from</span> tensorflow.keras.wrappers.scikit_learn <span class="hljs-keyword">import</span> KerasRegressor<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score<br><br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>] = [<span class="hljs-string">&quot;Simhei&quot;</span>]  <span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>] = <span class="hljs-literal">False</span><br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date, datetime, timedelta<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><br><span class="hljs-comment"># 训练模型，使用 girdsearchCV 进行参数调整以找到基础模型。</span><br></code></pre></td></tr></table></figure><p>定义本体，主要参数包括，预测数据集，预测时长，预测窗口数，预测步长<br>预测时间和预测窗口数最好一致，<br>预测数据集可为多参数，第一列为预测参数，<br>预测步长可以理解为逐小时，还是逐4小时，默认逐小时。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSTMTimePredictor</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, df, shift_n=<span class="hljs-number">30</span>, test_ratio=<span class="hljs-number">0.2</span>, n_past=<span class="hljs-number">30</span>,p_step=<span class="hljs-number">1</span> ,optimizer=<span class="hljs-string">&quot;adam&quot;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        df:DataFrame时间序列数据;</span><br><span class="hljs-string">        test_ratio:测试比率</span><br><span class="hljs-string">        n_past:预测的窗口数;</span><br><span class="hljs-string">        optimizer:优化器;</span><br><span class="hljs-string">        n_features:特征数;</span><br><span class="hljs-string">        feature_names:特征名称;</span><br><span class="hljs-string">        shirt_n:预测时长</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.df = df<br>        self.test_ratio = test_ratio<br>        self.n_past = n_past<br>        self.shift_n = shift_n<br>        self.optimizer = optimizer<br>        self.n_features = self.df.shape[<span class="hljs-number">1</span>]<br>        self.feature_names = self.df.columns<br>        self.p_step = p_step <br></code></pre></td></tr></table></figure><p>时间滑动生成新的数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">shift_date_new</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    时间滑动</span><br><span class="hljs-string">    下一段滑动函数 n 为移动参数，即为预测长度</span><br><span class="hljs-string">    df4都有的数据集用于训练和测试</span><br><span class="hljs-string">    df9向后预测的数据需要的未知数据集;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df1 = self.df<br>    n = self.shift_n<br>    bl_fh = df1.iloc[:, <span class="hljs-number">1</span>: self.n_features]<br>    cb = df1.iloc[:, <span class="hljs-number">0</span>]<br>    cb.to_frame<br>    df2 = cb.shift(periods=-n, axis=<span class="hljs-number">0</span>)<br>    df3 = pd.concat([df2, bl_fh], join=<span class="hljs-string">&quot;outer&quot;</span>, axis=<span class="hljs-number">1</span>)<br>    df9 = df3[-n:]<br>    df4 = df3[:-n]<br>    <span class="hljs-keyword">return</span> df4, df9<br></code></pre></td></tr></table></figure><p>数据集划分，归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_train_test_split</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    训练测试划分;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df = self.shift_date_new()[<span class="hljs-number">0</span>]<br>    test_split = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">len</span>(self.df) * self.test_ratio)  <span class="hljs-comment"># 计算测试集中的样本数量</span><br>    df_training = df[:-test_split]<br>    df_testing = df[-test_split:]<br>    <span class="hljs-comment"># 进行最小最大归一化</span><br>    scaler = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    df_training_scaled = scaler.fit_transform(df_training)<br>    df_testing_scaled = scaler.transform(df_testing)<br><br>    <span class="hljs-comment"># 获取训练集和测试集的样本数量</span><br>    self.train_length = <span class="hljs-built_in">len</span>(df_training_scaled)<br>    self.test_length = <span class="hljs-built_in">len</span>(df_testing_scaled)<br><br>    <span class="hljs-comment"># 获取归一化后的训练样本和测试样本</span><br>    self.scaler = scaler<br>    <span class="hljs-keyword">return</span> df_training_scaled, df_testing_scaled<br><br></code></pre></td></tr></table></figure><p>区分自变量，因变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">createXY</span>(<span class="hljs-params">self, datasets</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    生成用于LSTM输入的多元数据,例如时间窗口n_past=30,则一个样本的维度为(30,5)</span><br><span class="hljs-string">    30代表时间窗口,5代表特征数量</span><br><span class="hljs-string">    将数据分为x y</span><br><span class="hljs-string">    n_past 我们在预测下一个目标值时将在过去查看的步骤数 粒度</span><br><span class="hljs-string">    n_past使用30,意味着将使用过去的30个值</span><br><span class="hljs-string">    dataX 代表目标预测值dataY前所有因子,包括预测因子30个数据</span><br><span class="hljs-string">    若n_past越小,则预测的平滑度越低,越注重于短期预测,若n_past越大则越注重长期预测</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    dataX = []<br>    dataY = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_past, <span class="hljs-built_in">len</span>(datasets)):<br>        dataX.append(datasets[i - self.n_past : i, <span class="hljs-number">0</span> : datasets.shape[<span class="hljs-number">1</span>]])<br>        dataY.append(datasets[i, <span class="hljs-number">0</span>])<br>    <span class="hljs-keyword">return</span> np.array(dataX), np.array(dataY)<br></code></pre></td></tr></table></figure><p>建立模型，并查找最优参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">grid_search</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">    </span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        根据数据训练模型，并查找最优的参数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        df_training_scaled = self._train_test_split()[<span class="hljs-number">0</span>]<br>        df_testing_scaled = self._train_test_split()[<span class="hljs-number">1</span>]<br>        X_train, y_train = self.createXY(df_training_scaled)<br>        X_test, y_test = self.createXY(df_testing_scaled)<br><br>        grid_model = KerasRegressor(<br>            build_fn=self._build_model, verbose=<span class="hljs-number">1</span>, validation_data=(X_test, y_test)<br>        )<br>        parameters = &#123;<br>            <span class="hljs-string">&quot;batch_size&quot;</span>: [<span class="hljs-number">16</span>, <span class="hljs-number">20</span>],<br>            <span class="hljs-string">&quot;epochs&quot;</span>: [<span class="hljs-number">8</span>, <span class="hljs-number">10</span>],<br>            <span class="hljs-comment"># , &quot;Adadelta&quot;            &quot;optimizer&quot;: [&quot;adam&quot;],</span><br>        &#125;<br>        <span class="hljs-comment"># 这里前文设置了optimizer为adam </span><br>        grid_search = GridSearchCV(estimator=grid_model, param_grid=parameters, cv=<span class="hljs-number">2</span>)<br>        grid_search = grid_search.fit(<br>            X_train, y_train, validation_data=(X_test, y_test)<br>        )<br>        self.model = grid_search.best_estimator_.model<br><br></code></pre></td></tr></table></figure><p>至此模型建立。</p><h4 id="2-1-3-模型评价与模型预测"><a href="#2-1-3-模型评价与模型预测" class="headerlink" title="2.1.3 模型评价与模型预测"></a>2.1.3 模型评价与模型预测</h4><p>本次采用4 种方法评价模型精度，分别是MSE、MAE、R2、准确率。<br>测试集模型预测精度评价及绘图代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">self, plot=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    制图及模型评价</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df_testing_scaled = self._train_test_split()[<span class="hljs-number">1</span>]<br>    X_test, y_test = self.createXY(df_testing_scaled)<br>    <span class="hljs-comment"># 预测值</span><br>    prediction = self.model.predict(X_test)<br>    prediction_copy_array = np.repeat(prediction, self.n_features, axis=-<span class="hljs-number">1</span>)<br>    pred = self.scaler.inverse_transform(<br>        np.reshape(prediction_copy_array, (<span class="hljs-built_in">len</span>(prediction), self.n_features))<br>    )[:, <span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 实际值</span><br>    original_copies_array = np.repeat(y_test, self.n_features, axis=-<span class="hljs-number">1</span>)<br>    original = self.scaler.inverse_transform(<br>        np.reshape(original_copies_array, (<span class="hljs-built_in">len</span>(y_test), self.n_features))<br>    )[:, <span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 序号还原</span><br>    df = self.shift_date_new()[<span class="hljs-number">0</span>]<br>    test_split = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">len</span>(self.df) * self.test_ratio)  <span class="hljs-comment"># 计算测试集中的样本数量</span><br>    df_training = df[:-test_split]<br>    df_testing = df[-test_split:]<br>    index1 = df_testing.index<br>    starttime = index1[<span class="hljs-number">30</span>]<br>    delta = timedelta(hours=<span class="hljs-number">30</span>)  <span class="hljs-comment"># 时间序号还原</span><br>    starttime = starttime + delta<br>    starttime = starttime.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br>    endtime = index1[-<span class="hljs-number">1</span>]<br>    endtime = endtime + delta<br>    endtime = endtime.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<br>    time_nu = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<br>        <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span><br>    )<br>    time_nu = time_nu[::self.p_step]<br>    original_2 = pd.DataFrame(original)<br>    col_2 = [<span class="hljs-string">&quot;真实值&quot;</span>]<br>    original_2.columns = col_2<br>    original_3 = original_2.set_index(time_nu)<br>    pred_2 = pd.DataFrame(pred)<br>    col_1 = [<span class="hljs-string">&quot;预测值&quot;</span>]<br>    pred_2.columns = col_1<br>    pred_3 = pred_2.set_index(time_nu)<br>    <span class="hljs-keyword">if</span> plot:<br>        plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">6</span>))<br>        plt.plot(original_3, color=<span class="hljs-string">&quot;red&quot;</span>, label=<span class="hljs-string">&quot;真实值&quot;</span>)<br>        plt.plot(pred_3, color=<span class="hljs-string">&quot;blue&quot;</span>, label=<span class="hljs-string">&quot;预测值&quot;</span>)<br>        <span class="hljs-comment"># plt.title(&quot; 站点A氨氮预测&quot;)</span><br>        plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br>        plt.ylabel(<span class="hljs-string">&quot; 预测值&quot;</span>)<br>        plt.locator_params(axis=<span class="hljs-string">&quot;x&quot;</span>, nbins=<span class="hljs-number">10</span>)<br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(time_nu), <span class="hljs-number">48</span>), rotation=<span class="hljs-number">45</span>)  <span class="hljs-comment"># 刻度线显示优化</span><br>        plt.legend()<br>        plt.show()<br>    mae = mean_absolute_error(original, pred)<br>    mse = mean_squared_error(original, pred)<br>    mape = np.mean(np.<span class="hljs-built_in">abs</span>(original - pred) / original)<br>    r2 = r2_score(original, pred)<br>    acc = <span class="hljs-number">1</span> - <span class="hljs-built_in">abs</span>((pred - original) / original)<br>    acc = np.mean(acc)<br>    <span class="hljs-built_in">print</span>(<br>        <span class="hljs-string">&quot;MSE : &#123;&#125;,MAE : &#123;&#125;, MAPE : &#123;&#125;, r2 : &#123;&#125;, 准确率:&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>            mse, mae, mape, r2, acc<br>        )<br>    )<br>    <span class="hljs-keyword">return</span> pred<br></code></pre></td></tr></table></figure><p>数据集采用临江河站点A、站点B、站点C、站点D等4个站点，预测站点A高指、氨氮、总磷3个因子。数据范围为2022&#x2F;5&#x2F;19  5:00:00 至 2022&#x2F;9&#x2F;21  4:00:00。共3000个数据。测试集占比0.2。<br>测试集预测评价结果如下：MSE、MAE、R2均表现较好，总磷准确率、MAPE较差，与水质浓度波动大，关系密切，可以通过进一步优化数据清理减少数据波动。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663748742440-449f9585-7da7-4cb7-94b3-abd50057295a.png#averageHue=%23fbf9f9&clientId=u7a4f3748-f2cd-4&from=paste&height=775&id=u86202cc0&originHeight=775&originWidth=1495&originalType=binary&ratio=1&rotation=0&showTitle=true&size=180426&status=done&style=none&taskId=ucbe6b03a-dccc-4fc7-88ef-d7315592a3a&title=%E8%8C%A8%E5%9D%9D%E9%AB%98%E6%8C%87%E6%B5%8B%E8%AF%95%E9%9B%86%E9%A2%84%E6%B5%8B%E5%AF%B9%E6%AF%94&width=1495" alt="站点A高指测试集预测对比" title="站点A高指测试集预测对比"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663748769105-f0cd0097-09a1-4d51-8017-c00e7fa2954f.png#averageHue=%23fbf9f9&clientId=u7a4f3748-f2cd-4&from=paste&height=668&id=uc07496b7&originHeight=668&originWidth=1278&originalType=binary&ratio=1&rotation=0&showTitle=true&size=139917&status=done&style=none&taskId=u55750a39-849c-495c-869a-d9d796f0667&title=%E8%8C%A8%E5%9D%9D%E6%B0%A8%E6%B0%AE%E6%B5%8B%E8%AF%95%E9%9B%86%E9%A2%84%E6%B5%8B%E5%AF%B9%E6%AF%94&width=1278" alt="站点A氨氮测试集预测对比" title="站点A氨氮测试集预测对比"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663748800563-6bd58632-1cd4-4139-b64f-a79ff1e45b3d.png#averageHue=%23fbf9f9&clientId=u7a4f3748-f2cd-4&from=paste&height=684&id=u660ab49f&originHeight=684&originWidth=1293&originalType=binary&ratio=1&rotation=0&showTitle=true&size=122752&status=done&style=none&taskId=u0e9c73da-d000-46c4-95b8-04afcc7a735&title=%E8%8C%A8%E5%9D%9D%E6%80%BB%E7%A3%B7%E6%B5%8B%E8%AF%95%E9%9B%86%E9%A2%84%E6%B5%8B%E5%AF%B9%E6%AF%94&width=1293" alt="站点A总磷测试集预测对比" title="站点A总磷测试集预测对比"></p><table><thead><tr><th>因子</th><th>MSE</th><th>MAE</th><th>MAPE</th><th>r2</th><th>准确率</th></tr></thead><tbody><tr><td>高指</td><td>0.00004273</td><td>0.00521874</td><td>0.037992</td><td>0.968379</td><td>0.962008</td></tr><tr><td>氨氮</td><td>0.01103716</td><td>0.07946250</td><td>0.016475</td><td>0.959818</td><td>0.983525</td></tr><tr><td>总磷</td><td>0.00081064</td><td>0.01672249</td><td>0.698055</td><td>0.947509</td><td>0.301945</td></tr></tbody></table><h5 id="对未来的预测"><a href="#对未来的预测" class="headerlink" title="对未来的预测"></a>对未来的预测</h5><p>模型可以自定义模型预测时长，本次以72小时为例。运行预测评价模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lstm2 = LSTMTimePredictor(dm2,test_ratio=<span class="hljs-number">0.2</span>,n_past=<span class="hljs-number">72</span>,p_step=<span class="hljs-number">1</span> )<br>lstm2.grid_search()<br>lstm2.evaluate()<br>lstm2.fig_predict()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fig_predict</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    查看数据概览图;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    df = self.predict()<br>    plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">6</span>))<br>    plt.plot(df, color=<span class="hljs-string">&quot;red&quot;</span>, label=<span class="hljs-string">&quot;预测值&quot;</span>)<br>    plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br>    plt.ylabel(<span class="hljs-string">&quot; 预测值&quot;</span>)<br>    plt.title(<span class="hljs-string">&quot;水质预测&quot;</span>)<br>    plt.locator_params(axis=<span class="hljs-string">&quot;x&quot;</span>, nbins=<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># plt.xticks(range(1,len(time_nu),48),rotation=45) # 刻度线显示优化</span><br>    plt.legend()<br>    plt.show()<br></code></pre></td></tr></table></figure><p>预测结果分别为，整体呈下降趋势<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663750110262-e079044e-bf26-4ddb-afc5-2294ed2c7e34.png#averageHue=%23fcfbfb&clientId=u7a4f3748-f2cd-4&from=paste&height=692&id=u1651b8bc&originHeight=692&originWidth=1517&originalType=binary&ratio=1&rotation=0&showTitle=true&size=64780&status=done&style=none&taskId=u47331cb8-9abd-484c-a939-22e23994822&title=%E6%80%BB%E7%A3%B7%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&width=1517" alt="总磷预测结果" title="总磷预测结果"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663750136399-ca6af9e7-7c7d-48a4-aa17-05441f977fea.png#averageHue=%23fcfbfb&clientId=u7a4f3748-f2cd-4&from=paste&height=674&id=u7c3530d7&originHeight=674&originWidth=1440&originalType=binary&ratio=1&rotation=0&showTitle=true&size=58938&status=done&style=none&taskId=ub5e03c6e-36a6-4d63-aa04-ae31f2f94bd&title=%E9%AB%98%E6%8C%87%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&width=1440" alt="高指预测结果" title="高指预测结果"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1663750153213-46506788-4bb8-4d26-83af-9f7662d09818.png#averageHue=%23fcfbfb&clientId=u7a4f3748-f2cd-4&from=paste&height=576&id=uba2f3d8e&originHeight=576&originWidth=1237&originalType=binary&ratio=1&rotation=0&showTitle=true&size=50652&status=done&style=none&taskId=u09e53097-9ce9-475d-bb56-d1e9eb9e240&title=%E6%B0%A8%E6%B0%AE%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&width=1237" alt="氨氮预测结果" title="氨氮预测结果"></p><h2 id="3-应用场景及展望"><a href="#3-应用场景及展望" class="headerlink" title="3 应用场景及展望"></a>3 应用场景及展望</h2><p>LSTM作为成熟的神经网络模型，可以实现多因子，连续时间序列预测，可以应用在有一定连续水质检测数据的平台上，预测结果较准确。因子关联可根据实际情况选择，例如上下游关系，机理关系等。<br>shuju ，与ＲNN一样，LSTM隐藏层具有随时间序列的重复节点。LSTM节点相较ＲNN更<br>为复杂，它将ＲNN中隐含层中的神经元替换为记忆体，以此实现序列信息的保留与长期记忆。TM是ＲNN的一种变体，与ＲNN一样，LSTM隐藏层具有随时间序列的重复节点。LSTM节点相较ＲNN更为复杂，它将ＲNN中隐含层中的神经元替换为记忆体，以此实现序列信息的保留与长期记忆。<br>短的的多连续适用于时记忆网络(LSTM)应用</p><h2 id="BY"><a href="#BY" class="headerlink" title="BY"></a>BY</h2><p>如有帮助，请收藏点赞，如需引用转载请注明出处。<br>微信公众号：环境猫 er<br>CSDN：细节处有神明<br>个人博客：<a href="https://maoyu92.github.io/">wallflowers (maoyu92.github.io)</a></p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>时间序列模型</tag>
      
      <tag>生态环境</tag>
      
      <tag>BP神经网络</tag>
      
      <tag>水质模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锻炼 读书笔记 番外 身体激素及神经递质</title>
    <link href="/2024/07/02/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E7%95%AA%E5%A4%96%20%E8%BA%AB%E4%BD%93%E6%BF%80%E7%B4%A0%E5%8F%8A%E7%A5%9E%E7%BB%8F%E9%80%92%E8%B4%A8/"/>
    <url>/2024/07/02/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%20%E7%95%AA%E5%A4%96%20%E8%BA%AB%E4%BD%93%E6%BF%80%E7%B4%A0%E5%8F%8A%E7%A5%9E%E7%BB%8F%E9%80%92%E8%B4%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>最近在读《锻炼》的时候，对于各种激素很感兴趣，多巴胺、内啡肽、荷尔蒙、肾上腺素、褪黑素、皮质醇、糖化、氧化等等。索性认真梳理下它们是什么，思考当处于心流状态时，人体发生什么样的变化，分泌什么激素？在玩电子游戏时，主要分泌什么激素，为什么会出现沉迷现象？分析食物的糖化与糖化食物对人体的影响，分析人衰老的原因，以及对抗衰老的办法，并从中找到正确生活的方式。</p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>多巴胺 (Dopamine)</strong><br>多巴胺是一种神经递质，主要在大脑的奖赏中心、运动控制和认知功能中发挥作用。多巴胺的释放与愉悦感和期待感有关，当我们经历令人愉快的事情或者预期会得到奖励时，大脑中的多巴胺水平会升高，这与成瘾行为的形成密切相关。在基底神经节中调节运动，影响学习、记忆和注意力，对于维持精神警觉和决策能力至关重要。还抑制垂体前叶分泌催乳素，对生殖系统的调节有重要作用。<br><strong>内啡肽（Endorphins）</strong><br>内啡肽是大脑分泌的一类内源性物质，属于阿片肽的一种。它们主要作用于大脑中的疼痛调节系统，能够产生镇痛和愉悦感，有时被称作“自然的止痛剂”。运动、大笑、亲密接触等活动可以刺激内啡肽的释放，有助于缓解压力和提升心情。<br><strong>荷尔蒙（Hormones）</strong><br>荷尔蒙是指由内分泌腺或特定细胞合成并分泌到血液中，通过血液循环传递至靶器官或组织，对其产生特定生物学效应的化学信使分子。荷尔蒙在人体内扮演着调节各种生理功能的关键角色，包括生长发育、代谢速率、情绪状态、生殖功能等。<br><strong>皮质醇（Cortisol）</strong><br>皮质醇是一种由肾上腺皮质分泌的甾体激素，主要在应激反应中起关键作用。它能帮助身体应对压力，提高血糖水平，抑制免疫系统反应，并影响脂肪、蛋白质和碳水化合物的代谢。长期高水平的皮质醇与多种健康问题相关，如肥胖、高血压和抑郁等。<br><strong>褪黑素 (Melatonin)</strong><br>褪黑素是由松果体分泌的一种激素，主要与昼夜节律和睡眠周期有关。它的作用一是调节睡眠-觉醒周期：褪黑素的分泌随着一天中的光照条件而变化，夜晚分泌增加，帮助诱导睡眠，早晨分泌减少，促使醒来。二是抗氧化作用：褪黑素具有强大的抗氧化特性，能够清除自由基，保护细胞免受氧化应激的损害。三是免疫调节：褪黑素影响免疫系统的功能，可能在炎症和免疫反应中起到调节作用。<br><strong>肾上腺素 (Adrenaline)</strong><br>肾上腺素是一种由肾上腺髓质分泌的激素，也是神经系统中的神经递质。它在“战斗或逃跑”反应中起关键作用，主要作用包括：<br>心血管效应：肾上腺素增加心率、血压和心肌收缩力，确保身体在紧急情况下获得足够的氧气和能量。<br>代谢效应：它促进肝糖原分解为葡萄糖，增加血糖水平，提供即时能量来源。<br>呼吸效应：肾上腺素扩张呼吸道，增加肺部通气量，以应对紧急情况下的氧气需求。<br>神经效应：提高警觉性，增强注意力和反应速度。<br><strong>糖化（Glycation）</strong><br>糖化是指蛋白质、脂质或核酸等生物分子与糖类（如葡萄糖）非酶促结合的过程，形成糖基化终末产物（AGEs）。这一过程在正常生理条件下缓慢进行，但高血糖状态下会加速，导致蛋白质结构和功能改变，与糖尿病并发症、衰老和某些慢性疾病的发生有关。<br><strong>氧化（Oxidation）</strong><br>氧化是一个广泛的化学反应类型，涉及电子从一个物质（还原剂）向另一个物质（氧化剂）的转移。在生物体内，氧化反应通常发生在细胞呼吸过程中，将食物转化为能量。然而，过量的氧化反应会产生自由基，导致氧化应激，损伤细胞膜、DNA 和蛋白质，与衰老和疾病的发展相关联。</p><hr><h2 id="心流状态下，身体发生什么变化？"><a href="#心流状态下，身体发生什么变化？" class="headerlink" title="心流状态下，身体发生什么变化？"></a>心流状态下，身体发生什么变化？</h2><p>当个体处于心流状态（Flow State）时，这是一种高度专注、投入和享受的体验，通常在从事某项既具挑战性又与个人技能相匹配的活动中出现。<br>在心流状态下，人体经历了一系列生理变化，包括激素分泌的调整，以支持这种高度集中的精神状态。<br>在心流状态下分泌的激素和神经递质包括多巴胺、去甲肾上腺素、皮质醇、血清素、γ-氨基丁酸。<br>多巴胺让人愉悦；去甲肾上腺素让人清醒和专注、警觉、注意力提高；适量皮质醇让人保持能量应对挑战；血清素调节情绪；γ-氨基丁酸让人深度放松并集中注意力。<br>这些生理和神经化学的变化共同作用，使得心流状态成为一种高效和令人愉悦的体验，人们在这种状态下往往能发挥出最佳表现。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407021611293.jpg" alt="愉悦"></p><h2 id="玩电子游戏时，主要分泌什么激素，为什么会沉迷？"><a href="#玩电子游戏时，主要分泌什么激素，为什么会沉迷？" class="headerlink" title="玩电子游戏时，主要分泌什么激素，为什么会沉迷？"></a>玩电子游戏时，主要分泌什么激素，为什么会沉迷？</h2><p>当人类在玩电子游戏时，主要分泌的激素和神经递质包括多巴胺、肾上腺素、去甲肾上腺素，以及在某些情况下产生内啡肽。<br><strong>多巴胺</strong>，多巴胺是与奖励系统紧密相关的神经递质，当玩家在游戏中达成目标、获得成就或是经历刺激时，大脑会释放多巴胺，这会带来愉悦感和满足感。游戏设计往往包含奖励机制，如积分、升级、解锁新内容等，这些都能刺激多巴胺的释放，鼓励玩家持续参与。<br><strong>肾上腺素与去甲肾上腺素</strong>，在紧张刺激的游戏场景中，身体会释放肾上腺素和去甲肾上腺素，这是“战斗或逃跑”反应的一部分。这些激素会增加心率、血压和警觉性，让玩家更加集中注意力，体验到高度的兴奋和刺激。这类反应常见于竞技游戏或需要快速反应的游戏。<br><strong>内啡肽</strong>，在长时间或高强度的游戏后，身体可能会释放内啡肽，这是一种自然的止痛剂，能够产生放松和愉快的感觉，帮助缓解紧张和疲劳。虽然不是所有游戏都会引发内啡肽的大量释放，但在某些情况下，特别是当玩家经历成功或克服困难后，可能会有这种反应。</p><h2 id="多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？"><a href="#多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？" class="headerlink" title="多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？"></a>多巴胺、内啡肽、荷尔蒙有何关联，给人的愉悦感是否有无高低之分？</h2><p>多巴胺、内啡肽和荷尔蒙在人体内都有其特定的作用和相互关联，尤其是在影响情绪和愉悦感方面。</p><h3 id="多巴胺"><a href="#多巴胺" class="headerlink" title="多巴胺"></a>多巴胺</h3><p>多巴胺是一种神经递质，主要与奖赏系统、动机和欲望相关。当你经历令人愉快的事件，如吃美食、听喜欢的音乐或达到某个目标时，大脑中的多巴胺水平会升高，产生一种即时的快感和满足感。多巴胺还与成瘾行为有关，因为它强化了与奖赏相关的行为模式。</p><h3 id="内啡肽"><a href="#内啡肽" class="headerlink" title="内啡肽"></a>内啡肽</h3><p>内啡肽是一组内源性的肽类物质，它们与阿片受体结合，产生镇痛效果和愉悦感。内啡肽的释放通常与运动、笑、亲密接触或达到某种成就有关。它们带来的愉悦感往往伴随着身体的放松和幸福感觉，与多巴胺不同，内啡肽的快感更倾向于生理上的舒适和放松。在长时间的锻炼，克服困难、或者在心流状态更多分泌的是内啡肽。</p><h3 id="荷尔蒙"><a href="#荷尔蒙" class="headerlink" title="荷尔蒙"></a>荷尔蒙</h3><p>荷尔蒙是一类由内分泌腺分泌的化学信使，它们通过血液运输到全身，调节多种生理过程，包括生长、代谢、情绪和性行为等。有些荷尔蒙，如催产素（Oxytocin）和血清素（Serotonin），也与情感状态和社交行为有关，可以影响人的幸福感和社交连接。</p><h3 id="愉悦感的高低"><a href="#愉悦感的高低" class="headerlink" title="愉悦感的高低"></a>愉悦感的高低</h3><p>多巴胺和内啡肽带来的愉悦感在性质上有所不同，但很难绝对地说哪一个更高或更低，因为这取决于个人的体验和情境。多巴胺的快感往往更加直接和强烈，而内啡肽的快感则更持久且伴有放松感。荷尔蒙如催产素在社会互动和亲密关系中提供了一种深层次的情感连接和安全感，这也是另一种形式的愉悦。<br>例如，多巴胺的高峰可能在短暂的奖励行为中迅速出现，比如收到一条期待已久的短信；而内啡肽的释放则可能在长时间的运动或完成一项艰巨任务后慢慢累积，带来一种成就感和满足感。荷尔蒙的效应则可能贯穿于长期的社会和情感联系中，如亲情、友情和爱情。<br>因此，多巴胺、内啡肽和荷尔蒙在不同的情境下给人们带来的愉悦感是互补的，而不是简单的高低比较。它们共同构成了我们对生活中的快乐和满足感的多维度体验。</p><h2 id="食物的糖化与糖化食物对人体的影响"><a href="#食物的糖化与糖化食物对人体的影响" class="headerlink" title="食物的糖化与糖化食物对人体的影响"></a>食物的糖化与糖化食物对人体的影响</h2><p>食物的糖化以及摄入糖化食物对人体的影响是一个复杂但重要的营养学话题，主要涉及到美拉德反应（Maillard reaction）和糖基化终末产物（Advanced Glycation End products, AGEs）的概念。</p><h3 id="食物的糖化"><a href="#食物的糖化" class="headerlink" title="食物的糖化"></a>食物的糖化</h3><p>在烹饪过程中，尤其是当食物加热至较高温度时（如煎、烤、炸），蛋白质和碳水化合物之间会发生一系列复杂的化学反应，称为美拉德反应。这一过程不仅改变了食物的颜色和风味，还产生了新的化合物，其中一些就是糖基化终末产物（AGEs）。这些 AGEs 在食物中天然存在，但在高温处理下其含量显著增加。</p><h3 id="糖化食物对人体的影响"><a href="#糖化食物对人体的影响" class="headerlink" title="糖化食物对人体的影响"></a>糖化食物对人体的影响</h3><p>摄入富含 AGEs 的食物可能对人体健康产生不利影响，主要表现在以下几个方面：</p><ol><li><strong>炎症反应增强</strong>：AGEs 能够激活体内的炎症途径，促进炎症因子的释放，长期而言，这可能加剧慢性炎症状态，与心血管疾病、糖尿病、肾病等多种慢性疾病的风险增加有关。    </li><li><strong>氧化应激增加</strong>：AGEs 可引发氧化应激，即自由基的产生超过抗氧化防御机制的能力，损害细胞和组织，加速老化过程，并可能促进疾病的发展。    </li><li><strong>胰岛素抵抗和糖尿病风险</strong>：有研究表明，高 AGEs 饮食可能加重胰岛素抵抗，这是 2 型糖尿病的一个关键特征。此外，AGEs 还可能直接损害胰岛β细胞的功能。    </li><li><strong>血管功能受损</strong>：AGEs 与血管内皮细胞上的受体结合后，可导致血管功能障碍，如血管硬化和血流减少，增加心血管疾病的风险。<br>为了减少糖化食物对健康的潜在负面影响，建议采取以下措施：</li></ol><ul><li><strong>选择烹饪方法</strong>：尽量采用低温烹饪方法，如蒸、煮或炖，避免长时间高温烹饪。</li><li><strong>多样化饮食</strong>：均衡饮食，多吃新鲜水果、蔬菜和全谷物，这些食物中 AGEs 含量较低。</li><li><strong>控制糖分摄入</strong>：减少加工食品和含糖饮料的摄入，因为它们往往含有较高的 AGEs。</li><li><strong>适量运动</strong>：定期的身体活动可以帮助改善代谢，减少 AGEs 的积累。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407021606928.jpg"></p><h2 id="人体衰老的原因及抵抗衰老的方法"><a href="#人体衰老的原因及抵抗衰老的方法" class="headerlink" title="人体衰老的原因及抵抗衰老的方法"></a>人体衰老的原因及抵抗衰老的方法</h2><p>从生物学的角度看，人体衰老是一个涉及多个层面的复杂过程，包括遗传、分子、细胞、组织、器官乃至整个系统的退化。衰老的原因可以分为内在因素和外在因素，其中一些是可干预的，而另一些则不是。以下是衰老的生物学原因以及抵抗衰老的策略，特别强调了身体产生的激素和神经递质的角色：</p><h3 id="衰老的生物学原因"><a href="#衰老的生物学原因" class="headerlink" title="衰老的生物学原因"></a>衰老的生物学原因</h3><ol><li><strong>遗传因素</strong>    <ul><li><strong>端粒缩短</strong>：每次细胞分裂，染色体末端的端粒会缩短，最终导致细胞失去复制能力。</li><li><strong>基因突变</strong>：随时间积累的基因突变影响蛋白质功能，导致细胞功能障碍。</li></ul></li><li><strong>分子损伤</strong>    <ul><li><strong>氧化应激</strong>：自由基和其他活性氧物种（ROS）的积累导致DNA、蛋白质和脂质氧化损伤。</li><li><strong>糖化</strong>：糖基化终末产物（AGEs）的形成，影响蛋白质结构和功能。</li></ul></li><li><strong>细胞衰老</strong>    <ul><li><strong>细胞凋亡和自噬减少</strong>：细胞清理受损分子和结构的能力下降。</li><li><strong>干细胞功能下降</strong>：组织修复和再生能力减弱。</li></ul></li><li><strong>激素失衡</strong>    <ul><li><strong>性激素下降</strong>：如雌激素和睾酮水平随年龄下降，影响骨密度、肌肉质量和心血管健康。</li><li><strong>生长激素和IGF-1减少</strong>：影响代谢和组织修复。</li></ul></li><li><strong>神经递质变化</strong>    <ul><li><strong>多巴胺和血清素减少</strong>：影响情绪、认知和运动功能。</li><li><strong>乙酰胆碱减少</strong>：与记忆力和学习能力下降有关。</li></ul></li><li><strong>免疫功能衰退</strong>    <ul><li><strong>慢性炎症</strong>：低度持续的炎症状态加速组织损伤。</li></ul></li></ol><h3 id="可干预的抵抗衰老方法"><a href="#可干预的抵抗衰老方法" class="headerlink" title="可干预的抵抗衰老方法"></a>可干预的抵抗衰老方法</h3><ol><li><strong>生活方式改变</strong>    <ul><li><strong>健康饮食</strong>：富含抗氧化剂的食物，如蓝莓、绿茶、坚果，有助于减少氧化应激。</li><li><strong>规律运动</strong>：增强肌肉和骨骼健康，促进神经生长因子（NGF）和脑源性神经营养因子（BDNF）的分泌，维护大脑健康。</li><li><strong>充足睡眠</strong>：有助于激素平衡和细胞修复。</li></ul></li><li><strong>心理和社交活动</strong>    <ul><li><strong>压力管理</strong>：减少皮质醇水平，避免慢性压力对身体的负面影响。具体方式包括读书、冥想、规律运动等方式可以缓解压力。</li><li><strong>社交互动</strong>：维护神经递质平衡，如增加内啡肽和催产素的水平。</li></ul></li></ol><h3 id="不可干预的因素"><a href="#不可干预的因素" class="headerlink" title="不可干预的因素"></a>不可干预的因素</h3><ul><li><strong>遗传倾向</strong>：个体的遗传背景在很大程度上决定了衰老的速度和方式。</li><li><strong>既往伤害</strong>：过去的疾病、伤害和环境暴露可能留下不可逆的影响。<br>抵抗衰老的关键在于优化可控因素，如生活方式选择和医疗干预，同时适应和管理不可控因素，如遗传和年龄本身。通过综合方法，可以显著提高健康寿命，即在较长的生命中保持较高的健康和功能状态。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202407021605394.jpg" alt="规律运动"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian中用check list 打造待办清单</title>
    <link href="/2024/06/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/check%20list%20%E6%89%93%E9%80%A0%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/"/>
    <url>/2024/06/22/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/check%20list%20%E6%89%93%E9%80%A0%E5%BE%85%E5%8A%9E%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在快节奏的现代生活中，有效管理个人时间和任务成为提升生活与工作效率的关键。<br>Obsidian，作为一款强大的知识管理和笔记应用，通过其丰富的插件生态，为我们提供了高度自定义的任务管理解决方案。本文旨在详细介绍如何在Obsidian中集成待办事项管理功能到日常日记记录中，帮助您轻松规划每日任务，保障工作的有序进行。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p> <strong>Check list</strong><br>Checklist插件通过识别文件中的特定标签（如 <code>#todo</code>）和格式Markdown checklist语法），自动生成一个整洁的侧边栏任务列表。这不仅使任务一目了然，还实现了任务与日记内容的无缝衔接，便于追踪和回顾。<br><strong>Editing toolbar</strong><br>此插件扩展了Obsidian的编辑器工具栏，加入了一个直观的待办事项切换按钮。用户无需记忆Markdown语法，一键即可在文本中插入或转换待办事项格式，大大提升了录入效率。<br><strong>日记</strong><br>自带插件：日记的元数据中添加 todo 标签，日记中所有代办事项均会在侧边栏显示。</p><h2 id="清单原则"><a href="#清单原则" class="headerlink" title="清单原则"></a>清单原则</h2><ol><li>每天需要完成的清单不能太多，堆满屏幕会让人崩溃。</li><li>整理回顾清单，长时间未完成的及时划掉重新开始，好过长期霸占清单栏。</li><li>明确核心任务，根据任务重要新自上而下罗列。</li><li>简洁明了，减少分析清单的精力消耗。</li></ol><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>具体工作流如下</p><ol><li>新增日记（点击日历视图或者按钮）</li><li>写待办事项</li><li>全选事项点击编辑栏待办按钮</li><li>结束</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406221431476.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件推荐 caj2pdf</title>
    <link href="/2024/06/18/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%20caj2pdf/"/>
    <url>/2024/06/18/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%20caj2pdf/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="推荐内容"><a href="#推荐内容" class="headerlink" title="推荐内容"></a>推荐内容</h2><p>用 zotero 管理文献时，不能处理知网 caj 格式，有大佬做了相应的工作并开源。<br>今天推荐两个 GitHub 项目</p><ol><li><a href="https://github.com/caj2pdf/caj2pdf">https://github.com/caj2pdf/caj2pdf</a></li><li><a href="https://github.com/ElonH/caj2pdf_gui">https://github.com/ElonH/caj2pdf_gui</a></li></ol><p>一是 python 做的 caj 2 pdf 源码，二是结合caj 2pdf 和QT5 做的应用。<br>其中二的软件在 Releases 里可以直接下载。</p><p>感谢大佬们的贡献。</p><h2 id="软件界面"><a href="#软件界面" class="headerlink" title="软件界面"></a>软件界面</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406181400793.png" alt="image.png"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>输入 caj 格式文件</li><li>点击 show 可插件 caj 文件信息</li><li>点击 convert 生成 pdf</li><li>输入生成后的 pdf，点击 outlines 添加目录信息到 pdf</li></ol><h2 id="结果预览"><a href="#结果预览" class="headerlink" title="结果预览"></a>结果预览</h2><p>成功转换后，文字排版，目录等都很好的保留了，效果和好。<br>再次感谢大佬的无私奉献。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406181413552.png" alt="转换后预览对比"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zotero</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>streamlit快速搭建芝加哥雨型应用</title>
    <link href="/2024/06/16/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E5%9E%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2024/06/16/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/streamlit%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E5%9E%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过streamlit快速搭建芝加哥雨型应用，该应用实现以下功能：</p><ul><li>内置重庆各区县的暴雨强度计算公式，</li><li>支持自定义城市的暴雨公式参数，</li><li>支持雨型生成，输出图片和文字</li><li>提供降雨历时、汇水面积、径流系数输入，支持径流量计算</li><li>在线部署，网页使用。</li></ul><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>用 obsidian excalidraw 简单绘制原型。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162135564.png" alt="image.png"></p><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><ul><li>《关于发布重庆市暴雨强度修订公式及设计暴雨雨型的通知》（渝建〔2017〕443 号）</li><li><a href="https://www.vivifree.com/rain-model-chicago-formula.html">芝加哥合成暴雨过程线的公式推导 (vivifree.com)</a></li></ul><h2 id="主要功能实现"><a href="#主要功能实现" class="headerlink" title="主要功能实现"></a>主要功能实现</h2><h3 id="雨强计算"><a href="#雨强计算" class="headerlink" title="雨强计算"></a>雨强计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">intensity</span>(<span class="hljs-params">A, B, C, N, t, P</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    雨强计算。</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    - a,b,c,n: 参数。</span><br><span class="hljs-string">    - p (float): 设计重现期（单位：年）。</span><br><span class="hljs-string">    - t (np.ndarray): 分钟数组</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    - its: 雨强（单位：mm/min）。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a = A * <span class="hljs-number">0.4</span> * (<span class="hljs-number">1</span> + C * math.log10(P))<br>    its = a * ((<span class="hljs-number">1</span> - N) * t + B) / np.power(t + B, N + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> its<br>    <br>q = (A * (<span class="hljs-number">1</span> + C * math.log10(P))) / ((duration_minutes + B) ** N)<br></code></pre></td></tr></table></figure><h3 id="雨强分布计算"><a href="#雨强分布计算" class="headerlink" title="雨强分布计算"></a>雨强分布计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rainCalc_single_period</span>(<span class="hljs-params">A, B, C, N, T: <span class="hljs-built_in">int</span>, p: <span class="hljs-built_in">float</span>, peak_ratio: <span class="hljs-built_in">float</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算单一时段内的降雨强度分布。</span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    - T (int): 降雨持续时间（单位：分钟）。</span><br><span class="hljs-string">    - p (float): 设计重现期（单位：年）。</span><br><span class="hljs-string">    - peak_ratio (float): 雨强峰值所在时间占总降雨历时的比例。</span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    - np.ndarray: 随时间变化的降雨强度数组（单位：mm/min）。</span><br><span class="hljs-string">    内部参数:</span><br><span class="hljs-string">    - t (np.ndarray): 分钟数组</span><br><span class="hljs-string">    - peak_time (float): 峰值时间</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># ...函数实现代码...</span><br>    t = np.arange(<span class="hljs-number">0</span>, T)<br>    peak_time = T * peak_ratio<br>    itAr = np.zeros(<span class="hljs-built_in">len</span>(t))<br>    <span class="hljs-comment"># 计算雨强</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(t)):<br>        <span class="hljs-keyword">if</span> t[i] &lt; peak_time:<br>            itAr[i] = intensity(A, B, C, N, (peak_time - t[i]) / peak_ratio, p) / <span class="hljs-number">60</span><br>        <span class="hljs-keyword">else</span>:<br>            itAr[i] = intensity(A, B, C, N, (t[i] - peak_time) / peak_ratio, p) / <span class="hljs-number">60</span><br>    <span class="hljs-keyword">return</span> itAr<br></code></pre></td></tr></table></figure><p>其余功能实现均较为简单，项目所有代码均开源在 GitHub，有兴趣的可以去参观，点个 star 最好了，仓库如下：<br><a href="https://github.com/maoyu92/Chicago_rain_pattern">maoyu92&#x2F;Chicago_rain_pattern (github.com)</a><br>如果发现代码有不对的地方，也留言提醒我一下。</p><h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><p>Streamlit 是非常好用的一个应用框架，支持免费部署一个应用，非常方便。</p><h3 id="部署-GitHub"><a href="#部署-GitHub" class="headerlink" title="部署 GitHub"></a>部署 GitHub</h3><p>应用部署在 GitHub。通过 git 将本地仓库部署在 GitHub 上，具体方法可参考：<br><a href="https://blog.csdn.net/weixin_42984235/article/details/136906942">在vscode中使用git-新手向_新手vscode git-CSDN博客</a><br>这里跳过。</p><h3 id="Streamlit-应用发布"><a href="#Streamlit-应用发布" class="headerlink" title="Streamlit 应用发布"></a>Streamlit 应用发布</h3><p>登录 Streamlit，登录后点击右上角 create app。<br>选择 I have an app。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162151546.png" alt="image.png"></p><p>在连接上自己的 GitHub 后，依次选择仓库地址，分支，主文件，定义 url 名称，点击 depoly。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162152131.png" alt="image.png"></p><p>稍等片刻，如果一切顺利就成功了，非常丝滑~</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>仓库文件需要包括 requirement.txt，为项目运行需要的环境。</li><li>注意代码引用文件需要用相对应用的方式，不要绝对引用。</li></ol><h3 id="成果预览"><a href="#成果预览" class="headerlink" title="成果预览"></a>成果预览</h3><p>网址：<a href="https://chicagorainpattern.streamlit.app/">Streamlit (chicagorainpattern.streamlit.app)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406162156332.png" alt="image.png"></p><h2 id="制作-exe-发布"><a href="#制作-exe-发布" class="headerlink" title="制作 exe 发布"></a>制作 exe 发布</h2><h3 id="nativefier"><a href="#nativefier" class="headerlink" title="nativefier"></a>nativefier</h3><p>安装nativefier<br>如果安装不快或者安装不成功，可以试下先换为阿里源。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npmjs.org/</span><br>npm install -g nativefier<br></code></pre></td></tr></table></figure><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">nativefier</span> <span class="hljs-built_in">--name</span> <span class="hljs-string">&#x27;&lt;app.exe name&gt;&#x27;</span> <span class="hljs-string">&#x27;&lt;streamlit sharing website url&gt;&#x27;</span> <span class="hljs-built_in">--platform</span> &lt;<span class="hljs-string">&#x27;windows&#x27;</span> <span class="hljs-string">or</span> <span class="hljs-string">&#x27;mac&#x27;</span> <span class="hljs-string">or</span> <span class="hljs-string">&#x27;linux&#x27;</span>&gt;<br><br><span class="hljs-string">nativefier</span> <span class="hljs-built_in">--name</span> <span class="hljs-string">&quot;rainmaker&quot;</span> <span class="hljs-string">&quot;https://chicagorainpattern.streamlit.app/&quot;</span> <span class="hljs-built_in">--platform</span> <span class="hljs-string">windows</span><br></code></pre></td></tr></table></figure><p>完成后会在执行命令的目录下生成一个可执行文件。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182057691.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182057740.png" alt="image.png"></p><p>点击就可以直接运行<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182058701.png" alt="image.png"></p><p>这种方法感觉像是内置了一个浏览器，缺点也很明显，只能根据网址生成，如果取消已生成的 web 应用，则无法生效。可能也是防止可以随便生成应用吧。还有就是文件比较大，分享比较麻烦，还不如直接发网址。</p><h4 id="PyInstaller"><a href="#PyInstaller" class="headerlink" title="PyInstaller"></a>PyInstaller</h4><p>包装 PyInstaller包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pyinstaller<br></code></pre></td></tr></table></figure><p>检查是否安装</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">pip <span class="hljs-keyword">show</span> pyinstaller<br></code></pre></td></tr></table></figure><p>将 pyinstaller. exe 路径放入系统变量<br>通常在 C:\ProgramData\anaconda 3\Scripts 这个下面。</p><p>创建一个.spec文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">pyinstaller <span class="hljs-attr">--name</span> rainmaker <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><p>遇到问题<br>pathlib与 pyinstaller 不兼容</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pip uninstall pathlib</span><br></code></pre></td></tr></table></figure><p>继续执行创建. Spec 文件<br>运行了半天，结束后出现好几个文件<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406182139227.png" alt="image.png"></p><p>修改. Spec 文件<br>主要修改内容</p><ol><li>Pathex 路径正确</li><li>Datas 都包括所有信息和位置关系</li><li>Hookspath 指定自定义 hook 路径</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># -*- mode: python ; coding: utf-8 -*-</span><br><br>block_cipher = None<br><br>a = Analysis(<br>    [<span class="hljs-string">&#x27;main.py&#x27;</span>],<br>    pathex=[<span class="hljs-string">&#x27;D:\\BaiduSyncdisk\\pythonprograms\\rainmaker&#x27;</span>],  # 确保路径正确<br>    binaries=[],<br>    datas=[(<span class="hljs-string">&#x27;raincode.xlsx&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>), (<span class="hljs-string">&#x27;hook/hook-streamlit.py&#x27;</span>, <span class="hljs-string">&#x27;hook&#x27;</span>)],<br>    hiddenimports=[],  # 根据需要添加隐藏导入<br>    hookspath=[<span class="hljs-string">&#x27;./hooks&#x27;</span>],  # 指定自定义hook路径<br>    hooksconfig=&#123;&#125;,<br>    runtime_hooks=[],<br>    excludes=[],<br>    <span class="hljs-attribute">noarchive</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">optimize</span>=0,  # 根据需求调整<br>)<br>pyz = PYZ(a.pure)<br><br>exe = EXE(<br>    pyz,<br>    a.scripts,<br>    [],<br>    <span class="hljs-attribute">exclude_binaries</span>=<span class="hljs-literal">True</span>,<br>    <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rainmaker&#x27;</span>,<br>    <span class="hljs-attribute">debug</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">bootloader_ignore_signals</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">strip</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">upx</span>=<span class="hljs-literal">True</span>,<br>    <span class="hljs-attribute">console</span>=<span class="hljs-literal">True</span>,  # 或<span class="hljs-literal">False</span>，根据应用类型<br>    <span class="hljs-attribute">disable_windowed_traceback</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">argv_emulation</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">target_arch</span>=None,<br>    <span class="hljs-attribute">codesign_identity</span>=None,<br>    <span class="hljs-attribute">entitlements_file</span>=None,<br>)<br>coll = COLLECT(<br>    exe,<br>    a.binaries,<br>    a.datas,<br>    <span class="hljs-attribute">strip</span>=<span class="hljs-literal">False</span>,<br>    <span class="hljs-attribute">upx</span>=<span class="hljs-literal">True</span>,<br>    upx_exclude=[],<br>    <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;rainmaker&#x27;</span>,<br>)<br></code></pre></td></tr></table></figure><p>使用. Spec 文件打包</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">pyinstaller rainmaker.<span class="hljs-keyword">spec</span><br></code></pre></td></tr></table></figure><p>失败，感觉打包还是有点难度。后面有空继续</p><p>打包完成后，在 <code>dist/ </code>（Windows上可能是 <code>dist/YourAppName.exe</code>）找到可执行文件，并运行它来测试打包是否成功。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pyinstaller <span class="hljs-attr">--onefile</span> <span class="hljs-attr">--additional-hooks-dir</span>=./hooks run<span class="hljs-selector-class">.py</span> <span class="hljs-attr">--clean</span><br>pyinstaller <span class="hljs-attr">--onefile</span> <span class="hljs-attr">--additional-hooks-dir</span>=./hooks <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.py</span> <span class="hljs-attr">--clean</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>生态环境</tag>
      
      <tag>水文分析</tag>
      
      <tag>streamlit</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>芝加哥雨量计算径流量</title>
    <link href="/2024/06/14/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E9%87%8F%E8%AE%A1%E7%AE%97%E5%BE%84%E6%B5%81%E9%87%8F/"/>
    <url>/2024/06/14/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E8%8A%9D%E5%8A%A0%E5%93%A5%E9%9B%A8%E9%87%8F%E8%AE%A1%E7%AE%97%E5%BE%84%E6%B5%81%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>降雨量数据与市政给排水设计、初期污染源控制关系密切，本文以重庆永川某小流域为例，记录暴雨径流产生量的计算过程及芝加哥雨型的生成。<br>下一期介绍用 streamlit 制作暴雨径流及雨型生成器的制作。</p><p>本文提到的所有工具及资料均用云盘分享，大家可以直接下载使用。</p><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>计算重庆永川某小流域，暴雨径流产生量及雨型。</p><h2 id="暴雨强度"><a href="#暴雨强度" class="headerlink" title="暴雨强度"></a>暴雨强度</h2><p>根据《关于发布重庆市暴雨强度修订公式及设计暴雨雨型的通知》（渝建〔2017〕443 号）可知，<br>重庆永川暴雨流量计算公式：</p><p>$$<br>q&#x3D;\frac{1312(1+0.971 \lg P)}{(t+7.739)^{0.631}}<br>$$</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141147630.png" alt="image.png"><br>式中：<br>P—设计降雨重现期，<br>T—降雨历时 min<br>Q—设计暴雨强度（L&#x2F;s·hm 2）<br>综上，重现期 10 年, 降雨历时 60 分钟, 暴雨强度 180.87 L&#x2F;s·hm 2。</p><h4 id="雨水重现期"><a href="#雨水重现期" class="headerlink" title="雨水重现期"></a>雨水重现期</h4><p>设计雨水重现期按照 4.1.3 规定，项目为农村地区取 10 年。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141610046.png" alt="image.png"></p><h4 id="降雨历时"><a href="#降雨历时" class="headerlink" title="降雨历时"></a>降雨历时</h4><p>降雨历时取值范围为 1~1440 min，本文取60 min。</p><h2 id="初期雨量计算"><a href="#初期雨量计算" class="headerlink" title="初期雨量计算"></a>初期雨量计算</h2><h3 id="雨水量计算公式"><a href="#雨水量计算公式" class="headerlink" title="雨水量计算公式"></a>雨水量计算公式</h3><p>根据《室外排水设计标准》（GB 50014-2021），初期雨水量计算公式如下 ：<br>$$<br>Q &#x3D; q \times \psi \times F<br>$$<br>Q&#x3D;q×ψ×F<br>    式中：Q─雨水设计流量 （L&#x2F;s）；<br>    ψ─径流系数，取ψ&#x3D;0.45；<br>    F─汇水面积（hm2），为 hm2。<br>    q—暴雨强度（ L&#x2F;s•hm2）  </p><h4 id="径流系数"><a href="#径流系数" class="headerlink" title="径流系数"></a>径流系数</h4><p>室外排水设计标准中径流系数规定如下，并没有以耕地、水田为主的农业区域的径流系数信息。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141610951.png" alt="image.png"></p><p>在等雨量条件下 ,覆盖度在 95 %以上的耕地 ,径流系数为 0. 23 ,而覆盖度为 15 %的农地径流系数为0. 59<sup>[1]</sup>，根据《重庆市永川区水利发展“十三五”规划》，径流系数为 0.45，综合考虑，本次计算取 0.45。</p><p>综上，重现期10年,降雨历时60分钟, 暴雨强度180.87 L&#x2F;s·hm<sup>2</sup>,流域面积2000.0公顷，径流系数为0.45，流量为 162780.99 L&#x2F;s,累计汇水量586011.58 m³</p><h4 id="芝加哥雨型"><a href="#芝加哥雨型" class="headerlink" title="芝加哥雨型"></a>芝加哥雨型</h4><p>芝加哥雨型是一种用于城市雨洪设施设计的短历时设计雨型，由Keifer和Chu在1957年提出，主要用于模拟短时间内高强度的降雨过程，以评估和设计排水系统的能力。芝加哥雨型通过暴雨强度公式（IDF，Intensity-Duration-Frequency relationship）推导得出，并通过特定的处理方法来表达降雨过程中的峰值和衰减特性。<br>芝加哥雨型的特色在于它将暴雨分为峰前和峰后的两个阶段，通过一个系数 𝑟（介于0到1之间）来确定雨峰的位置，使得降雨过程更符合实际中雨强先增后减的变化规律。<br>一般情况下雨峰系数可取 0.35 。</p><p>通过芝加哥雨型计算可以相对较好的模拟降雨过程，计算累计雨量。<br>直接用芝加哥雨型生成器制作。计算结果可放入 swmm 模型中。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141340955.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406161744651.png" alt="image.png"></p><p>经过计算，重现期 10 年，降雨历时 60 分钟，累计雨量为 65 毫米。</p><p>下一期将介绍如何用 streamlit 制作暴雨径流及雨型生成器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>重庆市水土流失的影响因素及防治对策<br>《室外排水设计标准》（GB 50014-2021）<br>《重庆市永川区水利发展“十三五”规划》<br>《关于发布重庆市暴雨强度修订公式及设计暴雨雨型的通知》（渝建〔2017〕443 号）</p><p><a href="https://www.vivifree.com/rain-model-chicago-formula.html">芝加哥合成暴雨过程线的公式推导 (vivifree.com)</a><br><a href="https://weather.sz.gov.cn/qixiangfuwu/qihoufuwu/qihouguanceyupinggu/baoyuqiangdugongshi/mindex.html">暴雨强度公式-深圳市气象局（台） (sz.gov.cn)</a><br><a href="https://blog.csdn.net/weixin_43012724/article/details/129505354">【水文模型】11 芝加哥雨型生成器-CSDN博客</a></p><h2 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h2><p>链接： <a href="https://pan.baidu.com/s/1qERiyC-kXL0uZoRfErQ63A">https://pan.baidu.com/s/1qERiyC-kXL0uZoRfErQ63A</a><br>提取码：uokm </p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水文分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锻炼 精读笔记 01</title>
    <link href="/2024/06/05/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/"/>
    <url>/2024/06/05/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%94%BB%E7%82%BC%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 锻炼</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/80/cpPlatform_3tKaC95Z1mL61tPJbbGW2F/t7_cpPlatform_3tKaC95Z1mL61tPJbbGW2F.jpg" alt=" 锻炼|200"></li><li>书名： 锻炼</li><li>作者： 丹尼尔·利伯曼</li><li>简介： 我们是为休息而生，还是为跑而生？<br>跑步会毁了你的膝盖吗?<br>哪种运动项目蕞适合我？<br>懒惰是不正常的行为吗？<br>每晚都需要睡够 8 个小时吗？<br>我们可以跑得又快又远吗？<br>体育等于锻炼吗？<br>在不算太遥远的过去，我们那些狩猎采集者、农耕者祖先，为了获得足够的食物，每天需要进行数小时的身体活动，偶尔也会为了娱乐或者社交而做游戏或者跳舞，但没人会为了健康而奔跑或者行走几千米。锻炼只是人类进化过程中近期才出现的现象。哈佛大学进化生物学家丹尼尔·利伯曼凭借自己多年在世界各地的研究与经验，向我们讲述为什么我们从未进化出锻炼的本能。<br>在这本打破神话的书中，利伯曼告诉我们，锻炼，并不是人类的本能。利伯曼从人类学和进化学的角度探讨了我们的身体，破解了关于锻炼的 12 个谬误，教我们可以正确地对待自己的身体并进行正确的身体活动，帮助那些对锻炼感到焦虑、困惑和纠结的人们把锻炼重新放到正确的位置上。</li><li>出版时间 2022-06-01 00:00:00</li><li>ISBN： 9787574202009</li><li>分类： 生活百科-体育</li><li>出版社： 天津科学技术出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/f2432ab0813ab6e75g012b2d">https://weread.qq.com/web/reader/f2432ab0813ab6e75g012b2d</a></li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们可能从很多地方了解到，久坐影响身体健康，啤酒肚对身体不好，压力影响健康，但不了解其中的原因，甚至不知道这些说法对不对，这本书的意义是用详实的科学研究证明一些看似简单的道理。<br>读这本书的像是初读丹尼尔•卡尼曼的《思考快与慢》，以及《人类简史》。一方面惊叹作者对研究的认真态度，一方面书中阐述的知识，感觉像是打开了一扇窗，有种醍醐灌顶的融通感，而且本书的观点还可以指导养成良好的生活习惯，做一些简单的身体活动就起到健身的作用。</p><h2 id="我们从未进化出锻炼的本能"><a href="#我们从未进化出锻炼的本能" class="headerlink" title="我们从未进化出锻炼的本能"></a>我们从未进化出锻炼的本能</h2><p>锻炼的定义——为了改善健康、提高身体机能或运动技能而进行的有计划、成体系的身体活动，锻炼行为是人类独有的。<br>锻炼是最近才兴起的运动，对于早期的人类设置我的爷爷奶奶一辈，都是没有锻炼这个说法的，是在人类创造了足够的物质后，随着身体活动越来越少，而逐渐开始的活动。<br>而锻炼本身是枯燥而乏味，耗费时间，甚至痛苦的，我们往往因为没有锻炼而懊恼，同时有无法坚持锻炼。</p><h2 id="每天运动-1-小时"><a href="#每天运动-1-小时" class="headerlink" title="每天运动 1 小时"></a>每天运动 1 小时</h2><p>狩猎采集部落的人类工作时间为每天 7 小时，其中绝大部分时间用于完成轻体力劳动，而用于完成重体力劳动的时间最多为 1 小时。<br>“身体活动水平”（Physical Activity Level，PAL）是联合国粮食及农业组织用来衡量人体能量消耗标准的方法。PAL 的计算方法是：用一个人正常工作和生活 24 小时消耗的能量除以完全不离开床的情况下所消耗的能量。<br>办公室白领的 PAL 为 1.4-1.6，建筑工人为 1.7-2.0，狩猎采集者男性为 1.9，女性为 1.8。典型狩猎采集者的身体活动量与每天健身一小时的欧美人相当。<br>还有一种意想不到的数据解读方式，如果你是极少锻炼的普通人，那么你每天只需步行一两小时，便可以达到与狩猎采集者相当的身体活动水平。但即使是这样，现在的欧美人也极少能达到这样的活动水平。现代社会中成年工业化人口的平均 PAL 值是 1.67，而久坐人群的数据比这个值还要低。<br>如果每天不运动，虽然看起来少消耗的卡路里不多（100 卡），一年下来，至少能少消耗 2.6 万卡路里，足够跑 10 场马拉松了，这就是减少运动后肥胖的成因之一。</p><p>静止时身体的消耗<br>82 kg 的美国成年男性 24 小时静止不动消耗的能量为 1700 大卡。正常情况下，静息新城代谢消耗的能量占全部消耗能量的 63%。<br>由于脂肪是一种相对惰性的组织，对新陈代谢影响不大，哈扎男性的平均体重为 53.1 千克，基础代谢率为 1 300 大卡；哈扎女性的平均体重为 46.7 千克，基础代谢率为 1 060 大卡。</p><p>从明尼苏达大学的一位研究人员安塞尔·基斯博士（Dr. Ancel Keys）在二战后做的实验得出，</p><ol><li>极度饥饿会让人无精打采、情绪低落、欲望降低、抑郁、暴躁易怒、器官减小、体温降低。</li><li>脂肪是身体为了预防可能出现的食物匮乏情况，而形成的能量储备库。</li><li>饥饿状态下，身体会进入保护状态，调低基础代谢率，降低各种欲望，消耗脂肪，减少高耗能行文，仅维持基本的身体需要。</li><li>人体的基础代谢率是可变的。</li></ol><p>实际上，身体的能量只能用在身体生长、生命维持（静息代谢）、能量存储、身体活动、繁衍等五个方面。漫长的进化，使得人类选择尽可能能保持静态，为了让有限的能量用在有意义的事情上。你的身体在这 5 项功能之间所做的分配取决于你的年龄和你所处的能量环境。例如，如果你尚且年幼，处于成长期，你的生殖系统应该不会得到太多的能量，这也就是为什么动物通常会在停止生长之后才开始生育后代。如果你今天要去爬山，你在生命维持、储存脂肪或许还有繁衍方面分配到的能量会减少。如果你正在节食，你在身体活动和繁衍方面的能量会被削减。但是，请记住，从自然选择的角度看，不是所有权衡都是公平的。就像简·奥斯丁那样理智冷静的小说家一样，自然选择根本就不会在乎我们是否快乐、善良或者富有，它只偏爱那些有利于繁衍后代的可遗传性状，而权衡也是一种可遗传的性状。</p><p>生而懒惰，避免非必要的身体活动是人类的正常选择。</p><p>未完待续~<br>后面更精彩。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>锻炼</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python 离群值检验算法对比实战</title>
    <link href="/2024/06/05/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/python%20%E7%A6%BB%E7%BE%A4%E5%80%BC%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%AE%9E%E6%88%98/"/>
    <url>/2024/06/05/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/python%20%E7%A6%BB%E7%BE%A4%E5%80%BC%E6%A3%80%E9%AA%8C%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离群数据统计检验是数据分析中的一个重要环节，用于识别和处理那些与主体数据集显著不同的数据点。在水质在线数据分析过程中往往会遇到各种异常值，需要我们进行识别。</p><p>本文尝试通过对比不同的离群值检验方法，探究适合本地水质在线数据的检验方法。</p><p>常用的离群数据统计检验方法有四分位法、Z-Score 方法、孤立森林法、3σ原则等 4 种方法。<br>经过对比分析，Z-Score 与 3σ原则方法是最适合水质在线数据离群值检验的方法。具有离群值检验准确，原理清晰易懂，实现简单，配置参数少等优点。</p><h2 id="示例数据集概览"><a href="#示例数据集概览" class="headerlink" title="示例数据集概览"></a>示例数据集概览</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051158386.png" alt="fig1. 数据集折线图"></p><p>上图是一个实际环境中运行的水质变化曲线，可见存在明显的离群值，如果不去除异常值，则是对后续分析是不利的。</p><h2 id="不同离群值检验方法实现"><a href="#不同离群值检验方法实现" class="headerlink" title="不同离群值检验方法实现"></a>不同离群值检验方法实现</h2><h3 id="IQR-法（四分位距）方法"><a href="#IQR-法（四分位距）方法" class="headerlink" title="IQR 法（四分位距）方法"></a>IQR 法（四分位距）方法</h3><p>IQR 方法是识别极端值的非参数方法，不需要数据遵循正态分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd <span class="hljs-comment"># Load the uploaded CSV file </span><br>file_path = <span class="hljs-string">&#x27;/mnt/data/2024-06-05T03-18_export.csv&#x27;</span> <br>data = pd.read_csv(file_path)<br><span class="hljs-comment"># Convert &#x27;监测时间&#x27; to datetime format for better plotting</span><br>data[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(data[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><span class="hljs-comment"># Sort the data by &#x27;监测时间&#x27; for better visualization in the plot</span><br>data_sorted = data.sort_values(by=<span class="hljs-string">&#x27;监测时间&#x27;</span>)<br><span class="hljs-comment"># Create a boxplot for the &#x27;双河口&#x27; column</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>plt.boxplot(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>], vert=<span class="hljs-literal">False</span>)<br>plt.title(<span class="hljs-string">&#x27;Box Plot of 双河口&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.show()<br><br><span class="hljs-comment"># Calculate IQR</span><br>Q1 = data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>].quantile(<span class="hljs-number">0.25</span>)<br>Q3 = data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>].quantile(<span class="hljs-number">0.75</span>)<br>IQR = Q3 - Q1<br><span class="hljs-comment"># Define the boundaries for outliers</span><br>lower_bound = Q1 - <span class="hljs-number">1.5</span> * IQR<br>upper_bound = Q3 + <span class="hljs-number">1.5</span> * IQR<br><span class="hljs-comment"># Filter out the outliers</span><br>outliers = data_sorted[(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>] &lt; lower_bound) | (data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>] &gt; upper_bound)]<br><span class="hljs-comment"># Display the outliers</span><br>outliers<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051343400.png" alt="fig2.箱线图"></p><h2 id="Z-Score-方法"><a href="#Z-Score-方法" class="headerlink" title="Z-Score 方法"></a>Z-Score 方法</h2><p>Z-Score 方法，也称为标准分数，是一种用于评估数据点相对于数据集平均值的标准偏差的统计方法。这种方法通过计算每个数据点与数据集平均值的偏差，然后除以数据集的标准差，来衡量每个数据点的异常程度。具体来说，Z-Score 的计算公式如下：<br>$$<br>Z &#x3D; \frac{(X - \mu)}{\sigma}<br>$$<br>其中：</p><ul><li>𝑍是标准分数。</li><li>𝑋 是数据点的值。</li><li>𝜇是数据集的平均值。</li><li>𝜎 是数据集的标准差。</li></ul><p>Z-Score 的值可以用于判断数据点是否为离群值。一般来说，如果一个数据点的 Z-Score 大于 3 或小于-3，那么它就被认为是离群值。这是因为，根据正态分布的性质，大约 99.7%的数据点（在正态分布中）的 Z-Score 将落在-3 到 3 之间。因此，Z-Score 大于 3 或小于-3 的数据点可以被认为是异常值。</p><p>总之，Z-Score 方法是一种简单而强大的离群值检测方法，它通过计算数据点与数据集平均值的标准偏差来衡量每个数据点的异常程度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<br><span class="hljs-comment"># Calculate Z-Scores for the &#x27;双河口&#x27; column</span><br>data_sorted[<span class="hljs-string">&#x27;z_score&#x27;</span>] = stats.zscore(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>])<br><span class="hljs-comment"># Define the threshold for outliers based on Z-Score</span><br>z_threshold = <span class="hljs-number">3</span><br>outliers_z_score = data_sorted[(data_sorted[<span class="hljs-string">&#x27;z_score&#x27;</span>] &gt; z_threshold) | (data_sorted[<span class="hljs-string">&#x27;z_score&#x27;</span>] &lt; -z_threshold)]<br><span class="hljs-comment"># Display the outliers based on Z-Score</span><br>outliers_z_score[[<span class="hljs-string">&#x27;监测时间&#x27;</span>, <span class="hljs-string">&#x27;双河口&#x27;</span>, <span class="hljs-string">&#x27;z_score&#x27;</span>]]<br><br></code></pre></td></tr></table></figure><p>使用 Z-Score 方法检测到的离群值及其对应的监测时间如下：</p><ul><li>2024-04-25 00 时，值为 0.744，Z-Score 为 10.098</li><li>2024-05-03 16 时，值为 0.665，Z-Score 为 8.908</li><li>2024-05-03 20 时，值为 0.694，Z-Score 为 9.345</li><li>2024-05-04 00 时，值为 0.650，Z-Score 为 8.682</li><li>2024-05-04 04 时，值为 0.608，Z-Score 为 8.049</li><li>2024-05-04 08 时，值为 0.717，Z-Score 为 9.691</li><li>2024-05-04 20 时，值为 0.685，Z-Score 为 9.209</li><li>2024-05-07 12 时，值为 0.685，Z-Score 为 9.209</li></ul><p>使用折线图来展示整个时间序列，并使用红圈标出 Z-Score 方法识别出的离群值。这样可以直观地看到这些离群值在整个时间序列中的分布情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))<br>plt.plot(data_sorted[<span class="hljs-string">&#x27;监测时间&#x27;</span>], data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>], label=<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>outliers_z_score.plot(x=<span class="hljs-string">&#x27;监测时间&#x27;</span>, y=<span class="hljs-string">&#x27;双河口&#x27;</span>, kind=<span class="hljs-string">&#x27;scatter&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, ax=plt.gca(), label=<span class="hljs-string">&#x27;Outliers&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;双河口 Time Series with Outliers Highlighted&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Monitoring Time&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>plt.legend()<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.xticks(rotation=<span class="hljs-number">45</span>)  <br>plt.tight_layout()  <br>plt.show()<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051147385.png" alt="fig3. Z-Score 方法离群值可视化"></p><h3 id="3σ原则"><a href="#3σ原则" class="headerlink" title="3σ原则"></a>3σ原则</h3><p>3σ原则（3 倍标准差原则）是一种用于检测数据集中离群值的经典方法。根据这个原则，如果一个数据点的值大于 𝜇+3𝜎或小于 𝜇−3𝜎（其中 𝜇是数据的平均值，𝜎 是标准差），那么这个数据点就可以被认为是离群值。可以看到 3σ原则与 Z-Score 方法 z_threshold 取 3 意义是一样的，<br>两者的异同点如下：</p><ul><li><strong>相同点：</strong> 两者都依赖于数据的均值 (𝜇) 和标准差 (𝜎)，并且都是用来识别数据中的极端值或离群点。</li><li><strong>不同点：</strong> Z-Score 提供了每个数据点相对于分布中心位置的标准化度量，适用于更广泛的分析场景，包括但不限于离群值检测；而 3σ原则是一个更具体的规则，直接用来界定离群值的界限，且主要基于正态分布的特性。</li><li><strong>适用性：</strong> Z-Score 方法更为灵活，可以用于理解数据点的相对位置，而 3σ原则则是一个快速且直观的筛选工具，尤其适合正态分布数据集的初步离群值识别。</li></ul><p>Python 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载CSV文件 </span><br>file_path = <span class="hljs-string">&#x27;/mnt/data/2024-06-05T03-18_export.csv&#x27;</span> <br>df = pd.read_csv(file_path)<br><span class="hljs-comment"># 使用双河口列的数据</span><br>data_column = <span class="hljs-string">&#x27;双河口&#x27;</span><br><span class="hljs-comment"># 计算 mean 和 std</span><br>mean = df[data_column].mean()<br>std = df[data_column].std()<br><br><span class="hljs-comment"># 应用3σ法则来检测离群值</span><br>outliers = <span class="hljs-built_in">abs</span>(df[data_column] - mean) &gt; <span class="hljs-number">3</span> * std<br><span class="hljs-comment"># 将监测时间列转换为日期时间格式</span><br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><br><span class="hljs-comment"># 重新绘制时间序列和离群值</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>plt.plot(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>], df[data_column], label=<span class="hljs-string">&quot;时间序列&quot;</span>)<br>plt.plot(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>][outliers], df[data_column][outliers], <span class="hljs-string">&#x27;ro&#x27;</span>, label=<span class="hljs-string">&quot;离群值&quot;</span>)  <span class="hljs-comment"># 离群值用红色圆圈标记</span><br>plt.axhline(mean + <span class="hljs-number">3</span> * std, color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">&quot;上界&quot;</span>)<br>plt.axhline(mean - <span class="hljs-number">3</span> * std, color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">&quot;下界&quot;</span>)<br>plt.legend()<br>plt.title(<span class="hljs-string">&quot;时间序列离群值检测&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;监测时间&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;双河口值&quot;</span>)<br>plt.tight_layout()  <span class="hljs-comment"># 调整布局</span><br>plt.show()<br><span class="hljs-comment"># 计算有多少异常值 </span><br>outliers.<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051703178.png" alt="fig4. 3σ原则离群值可视化"></p><p>途中可以看出异常值的分布情况，共检测到了 8 个离群值。与 Z-Score 方法更接近。</p><h3 id="孤立森林法"><a href="#孤立森林法" class="headerlink" title="孤立森林法"></a>孤立森林法</h3><p>孤立森林（Isolation Forest）是一种用于检测离群值的机器学习方法，它适用于高维数据集，并且是一种无监督学习方法，不需要标签数据。但是缺点也很明显，就是配置参数较多，使用不方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> IsolationForest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">detect_outliers_isolation_forest</span>(<span class="hljs-params">data_series</span>):<br>    iso_forest = IsolationForest(n_estimators=<span class="hljs-number">100</span>, random_state=<span class="hljs-number">42</span>)<br>    outliers = iso_forest.fit_predict(data_series.values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">return</span> data_series[outliers == -<span class="hljs-number">1</span>]<br><span class="hljs-comment"># Apply the Isolation Forest method to detect outliers in the &#x27;双河口&#x27; column</span><br>outliers_isolation_forest = detect_outliers_isolation_forest(data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>])<br><span class="hljs-comment"># Create a boolean mask for the outliers for plotting</span><br>outliers_mask = data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>].isin(outliers_isolation_forest)<br><span class="hljs-comment"># Plot the time series with outliers highlighted using Isolation Forest</span><br>plt.figure(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))<br>plt.plot(data_sorted[<span class="hljs-string">&#x27;监测时间&#x27;</span>], data_sorted[<span class="hljs-string">&#x27;双河口&#x27;</span>], label=<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br><span class="hljs-comment"># Highlight the outliers with red circles</span><br>plt.scatter(data_sorted[outliers_mask][<span class="hljs-string">&#x27;监测时间&#x27;</span>], <br>            data_sorted[outliers_mask][<span class="hljs-string">&#x27;双河口&#x27;</span>], <br>            color=<span class="hljs-string">&#x27;red&#x27;</span>, <br>            label=<span class="hljs-string">&#x27;Outliers&#x27;</span>)<br><br>plt.title(<span class="hljs-string">&#x27;双河口 Time Series with Outliers Highlighted by Isolation Forest&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Monitoring Time&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;双河口 Value&#x27;</span>)<br>plt.legend()<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.xticks(rotation=<span class="hljs-number">45</span>)  <span class="hljs-comment"># Rotate x-axis labels for better readability</span><br>plt.tight_layout()  <span class="hljs-comment"># Adjust layout to ensure all labels are displayed</span><br><span class="hljs-comment"># Show the plot</span><br>plt.show()<br><span class="hljs-comment"># Display the outliers detected by Isolation Forest</span><br>outliers_isolation_forest<br><br></code></pre></td></tr></table></figure><p>结果。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406051233465.png" alt="fig5. 孤立森林法离群值可视化"></p><p>监测到离群值的数量太多，即使修改参数也很难达到想要的效果。<br>以下是 <code>IsolationForest</code> 算法中一些重要参数的介绍：</p><ol><li><code>n_estimators</code>:    <ul><li>表示决策树的数量。</li><li>增加 <code>n_estimators</code> 的值可以提高模型的稳定性，但同时可能会增加计算成本。</li><li>减少 <code>n_estimators</code> 的值可能会使模型对离群值的检测更加“宽容”，从而减少检测到的离群值数量。</li></ul></li><li><code>max_samples</code>:    <ul><li>表示从数据集中抽取用于训练每棵决策树的最大样本数。</li><li>减少 <code>max_samples</code> 的值可能会使模型对离群值的检测更加“宽容”，因为它限制了每棵树看到的数据点的数量。</li><li>默认值是‘auto’，表示每个节点都会从所有样本中随机抽取一个子样本。</li></ul></li><li><code>contamination</code>:    <ul><li>表示数据集中离群值的比例。</li><li>默认为 0.1，意味着模型会假设数据集中大约 10% 的数据是离群值。</li><li>如果设置为‘auto’，模型会自动估计数据集中的离群值比例。</li></ul></li><li><code>random_state</code>:    <ul><li>表示随机数生成器的种子，用于确保结果的可重复性。</li><li>设置 <code>random_state</code> 为一个固定的值（例如 42），可以确保每次运行模型时，生成的随机数序列是相同的。<br>在使用 <code>IsolationForest</code> 算法时，通常需要根据具体的数据集和应用场景来调整这些参数。在实际应用中，可能需要多次尝试不同的参数设置，以找到最适合特定数据集的配置。</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Z-Score 方法和 3σ原则确实是离群值检验中广泛应用且效果显著的方法，尤其在处理水质在线监测数据时展现出其独特的优势。这两种方法之所以成为优选，原因可归纳为以下几点：</p><ol><li><strong>离群值检验准确</strong>：Z-Score 通过将每个数据点转化为标准分数，能够准确反映其相对于数据集平均值的偏离程度，而 3σ原则利用正态分布的特性，能有效识别出极少数的极端值，确保了检验结果的准确性。    </li><li><strong>原理一致且易于理解</strong>：二者均基于正态分布的统计理论，原理相通，易于解释。Z-Score 通过标准化处理使数据间的比较标准化，而 3σ原则直接依据正态分布的性质设定离群值边界，逻辑简洁明了。    </li><li><strong>实现简便，配置参数少</strong>：这两种方法的计算过程相对直接，仅需均值 (𝜇μ) 和标准差 (𝜎σ) 两个基本统计量即可实施，无需复杂的模型训练或调整大量参数，降低了实际操作的技术门槛。    </li><li><strong>适应水质数据特性</strong>：一个重要前提是水质在线数据往往倾向于呈现正态或近似正态分布，这与自然环境因素的随机波动、监测设备的稳定性能等因素有关。因此，基于正态分布假设的 Z-Score 和 3σ原则能够较好地匹配水质数据的特点，有效识别出因设备故障、污染事件或其他异常情况引起的离群值。</li></ol><p>综上所述，Z-Score 方法和 3σ原则凭借其检验准确度高、原理直观、实现便捷以及对水质在线数据特性的良好匹配性，成为了这类数据离群值检验的理想选择，特别是在追求高效实时监控和数据分析的水质管理领域。</p><p>感谢看完，如果对你有用请点赞关注哦。</p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>算法</tag>
      
      <tag>数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian zotero 联动方案 配置记录</title>
    <link href="/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20zotero%20%E8%81%94%E5%8A%A8%E6%96%B9%E6%A1%88%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20zotero%20%E8%81%94%E5%8A%A8%E6%96%B9%E6%A1%88%20%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Obsidian 和 zotero 都是非常好用的开源软件，两个软件能做到无缝联动也是很多人的想法，文献笔记可以丝滑的放进 obsidian 中，那多好，网上有很多教程，但能够一步到位讲清楚的很少。我也踩了很多坑才完成部署，希望本文能帮你少走弯路。<br>搭建 zotero 与 Obsidian 联动部署的目的是让我们更加专注做笔记，从来回折腾笔记中抽离出来，让我们更加沉浸的阅读和总结。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405311730349.png"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>Obsidian 插件（插件市场搜索下载）</p><ul><li>Zotlit<br>Zotero 插件</li><li>Obsidian Note for Zotero </li><li><strong>Zotero style</strong></li></ul><p>GitHub 搜索 zotero style 或者Obsidian Note for Zotero<br>点击 Releases 选择最新版本 xpi 下载。</p><h3 id="Note-for-Zotero配置"><a href="#Note-for-Zotero配置" class="headerlink" title="Note for Zotero配置"></a>Note for Zotero配置</h3><p>Obsidian Note for Zotero  启动 enable</p><h3 id="Zotero-style-配置"><a href="#Zotero-style-配置" class="headerlink" title="Zotero style 配置"></a>Zotero style 配置</h3><p>Zotero style 功能非常强大，作者在 B 站也做了很详细的讲解，包括自定义文件属性列，修改标签格式，修改标记格式等等，这里不展开讲，主要讲怎么设置标注的颜色和注释。<br>安装后，enable。<br>Shfit+P, 点击或者输入标注<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301428862.png" alt="image.png"></p><p>点开后默认有 8 种颜色，是以颜色命名的。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301641250.png" alt="image.png"><br>鼠标移动到颜色标记的位置，长按鼠标左键，进入配置界面，如果点按右键则是删除配置。可以点击下方的加号，再新增。<br>长按后根据自己喜好设置颜色及名称。这是我的设置，其实一般也记不住那么多标记，默认有 8 种分类，太多，根本用不完。设置四种颜色完全够用了，红、蓝、黄、绿，背景色调整低一点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301637938.png" alt="image.png"></p><p>安装好 Zotero style 插件后，会对标注进行美化。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301646817.png" alt="image.png"><br>类似这样，会比之前好看很多。这也大致是导入 obsidian 后的样子。</p><h3 id="Zotlit-设置"><a href="#Zotlit-设置" class="headerlink" title="Zotlit 设置"></a>Zotlit 设置</h3><p>设置各种文件存储、读取位置</p><h4 id="文献笔记位置"><a href="#文献笔记位置" class="headerlink" title="文献笔记位置"></a>文献笔记位置</h4><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301648497.png" alt="image.png"></p><h4 id="Zotero-数据库位置"><a href="#Zotero-数据库位置" class="headerlink" title="Zotero 数据库位置"></a>Zotero 数据库位置</h4><p>点击 启用服务器enable<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301649040.png" alt="image.png"></p><h4 id="笔记模板文件位置"><a href="#笔记模板文件位置" class="headerlink" title="笔记模板文件位置"></a>笔记模板文件位置</h4><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301649890.png" alt="image.png"></p><h4 id="修改模板配置文件"><a href="#修改模板配置文件" class="headerlink" title="修改模板配置文件"></a>修改模板配置文件</h4><p>修改文件名配置代码，用标题就好了<br>修改模板，代码看不懂没关系，可以用已经设置好的。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">&lt;%= it.<span class="hljs-built_in">title</span>%&gt;.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301652660.png" alt="image.png"></p><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><p>将ZtTemplates 对应文件进行修改。</p><h5 id="Zt-annot-Eta"><a href="#Zt-annot-Eta" class="headerlink" title="Zt-annot. Eta"></a>Zt-annot. Eta</h5><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs livescript">&lt;%<br><span class="hljs-keyword">var</span> colorToLabelMap = &#123;<br>    <span class="hljs-string">&quot; <span class="hljs-subst">#ffd400</span>&quot;</span>: <span class="hljs-string">&quot;重要方法&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#ff6666</span>&quot;</span>: <span class="hljs-string">&quot;重要概念&quot;</span>,<br>    <span class="hljs-string">&quot;#5fb236&quot;</span>: <span class="hljs-string">&quot;重要结论&quot;</span>,<br>    <span class="hljs-string">&quot;#2ea8e5&quot;</span>: <span class="hljs-string">&quot;研究背景&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#a28ae5</span>&quot;</span>: <span class="hljs-string">&quot;硏究路线&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#e56eee</span>&quot;</span>: <span class="hljs-string">&quot;文章素材&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#f19837</span>&quot;</span>: <span class="hljs-string">&quot;优秀配图&quot;</span>,<br>    <span class="hljs-string">&quot;<span class="hljs-subst">#aaaaaa</span>&quot;</span>: <span class="hljs-string">&quot;其他&quot;</span>,<br>    <span class="hljs-string">&quot;default&quot;</span>: <span class="hljs-string">&quot;暂时未分类 &quot;</span> <br>&#125;;<br><span class="hljs-keyword">var</span> labelToShow = colorToLabelMap[<span class="hljs-literal">it</span>.color] || colorToLabelMap[<span class="hljs-string">&quot;default&quot;</span>];<br>%&gt;<br><br>[!note] &lt;span style=<span class="hljs-string">&quot; background:&lt;%= it.color %&gt;&quot;</span>&gt;&lt;%= labelToShow %&gt;&lt;/span&gt;<br><br>&lt;font color=<span class="hljs-string">&quot;#000000&quot;</span>&gt;&lt;%= <span class="hljs-literal">it</span>.imgEmbed %&gt;&lt;%= <span class="hljs-literal">it</span>.text %&gt;&lt;/font&gt;<br></code></pre></td></tr></table></figure><h5 id="zt-annots-eta"><a href="#zt-annots-eta" class="headerlink" title="zt-annots.eta"></a>zt-annots.eta</h5><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal">&lt;% <span class="hljs-keyword">for</span> (const <span class="hljs-keyword">annotation</span> <span class="hljs-title">of</span> <span class="hljs-title">it</span>) &#123; %&gt;<br>&lt;%~ <span class="hljs-keyword">include</span>(<span class="hljs-string">&quot;annotation&quot;</span>, <span class="hljs-keyword">annotation</span>) %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><h5 id="Zt-field-Eta"><a href="#Zt-field-Eta" class="headerlink" title="Zt-field. Eta"></a>Zt-field. Eta</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&lt;%= it.title %&gt;&quot;</span><br><span class="hljs-symbol">citekey:</span> <span class="hljs-string">&quot;&lt;%= it.citekey %&gt;&quot;</span><br><span class="hljs-symbol">itemType:</span> <span class="hljs-string">&quot;&lt;%= it.itemType %&gt;&quot;</span><br>标题翻译: <span class="hljs-string">&quot;&lt;%= it.shortTitle %&gt;&quot;</span><br><span class="hljs-symbol">tags:</span> <span class="hljs-string">&quot;&lt;%= it.tags %&gt;&quot;</span><br>影响因子: <span class="hljs-string">&quot;&lt;%= it.libraryCatalog %&gt;&quot;</span><br><br>出版期刊: <span class="hljs-string">&quot;&lt;%= it.publicationTitle %&gt;&quot;</span><br>出版年份: <span class="hljs-string">&quot;&lt;%= it.date %&gt;&quot;</span><br>修改日期: <span class="hljs-string">&quot;&lt;%= it.dateModified %&gt;&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Zt-note-Eta"><a href="#Zt-note-Eta" class="headerlink" title="Zt-note. Eta"></a>Zt-note. Eta</h5><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># &lt;%= it.title %&gt;</span><br><span class="hljs-comment">## 基础信息</span><br><br>|<span class="hljs-string"> 属性           </span>|<span class="hljs-string"> 信息                                 </span>|<br>|<span class="hljs-string"> ------------ </span>|<span class="hljs-string"> ---------------------------------- </span>|<br>|<span class="hljs-string"> **标题翻译**     </span>|<span class="hljs-string"> &lt;%= it.shortTitle %&gt;               </span>|<br>|<span class="hljs-string"> **作者**       </span>|<span class="hljs-string"> &lt;%= it.creators %&gt;                 </span>|<br>|<span class="hljs-string"> **出版年份**     </span>|<span class="hljs-string"> &lt;%= it.date %&gt;                     </span>|<br>|<span class="hljs-string"> **期刊**       </span>|<span class="hljs-string"> &lt;%= it.publicationTitle %&gt;         </span>|<br>|<span class="hljs-string"> **期刊等级**     </span>|<span class="hljs-string"> &lt;%= it.libraryCatalog %&gt;           </span>|<br>|<span class="hljs-string"> **标签**       </span>|<span class="hljs-string"> &lt;%= it.tags %&gt;                     </span>|<br>|<span class="hljs-string"> **附件链接**     </span>|<span class="hljs-string"> &lt;%= it.fileLink %&gt;                 </span>|<br>|<span class="hljs-string"> **zotero跳转** </span>|<span class="hljs-string"> [点这里跳回zotero哈](&lt;%= it.backlink %&gt;) </span>|<br><br>&gt; [!note]- 论文摘要<br>&gt; <span class="hljs-variable">&lt;%= it.abstractNote[[0]].replace(/\n/g, &#x27;&#x27;)   %&gt;</span><br>&gt; <br><br><span class="hljs-comment">## 论文注释</span><br><br><span class="hljs-variable">&lt;%~ include(&quot;annots&quot;, it.annotations) %&gt;</span><br></code></pre></td></tr></table></figure><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>笔记流程<br>Zotero 做标注笔记，切换到列表视图，右键 obsidian Actions-Create notes。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405301700082.png" alt="image.png"></p><p>Obsidian 中就新建了一条笔记。这个笔记会带有完善的元数据，方便检索。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405311715137.png" alt="image.png"><br>以下是笔记正文：</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406010905743.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>经验分享</tag>
      
      <tag>Zotero</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian 文本生成流程图 Excalidraw Mermaid</title>
    <link href="/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE%20%E6%B3%B0%E9%85%B7%E5%95%A6%20Excalidraw%20Mermaid%20Syntax/"/>
    <url>/2024/05/29/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B%E5%9B%BE%20%E6%B3%B0%E9%85%B7%E5%95%A6%20Excalidraw%20Mermaid%20Syntax/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>介绍一个很酷的工具，<strong>Excalidraw Mermaid</strong> 。作用是用代码生成流程图。<br><strong>Mermaid</strong>  是一款强大的、轻量级的文本到图表的转换工具，它允许用户使用简单的Markdown风格的语法编写文本描述，然后通过JavaScript引擎将其转换成美观的图表。Mermaid的设计初衷是为了简化图表的创建过程，让用户能够更专注于内容本身而非复杂的图形界面操作。<br>Obsidian Excalidraw 可以直接用这个作图，而且部分类型图还可以编辑，简直完美。<br>再结合<strong>大预言模型</strong>，我们可以快速做出好看的流程图，还不来看下 QAQ。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>打开 Obsidian Excalidraw 点击工具栏最右侧工具图标，选择 <strong>Mermaid to Excalidraw</strong> </p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291421743.png" alt="image.png"><br>具体语法在 Mermaid 官网有，我们不需要了解的很深。因为可以借助大预言模型直接抄作业。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291424197.png" alt="image.png"></p><p>把文本代码微调下，<font color="#ffc000">就可以了</font>。</p><pre><code class=" Mermaid">graph TDStart((开始)) --&gt; QCCheck(质控判断)QCCheck --&gt;|合格| DataAnalysis(数据分析)QCCheck --&gt;|异常| InvalidData(无效数据)DataAnalysis --&gt;|正常| PollutionAnalysis(污染原因分析)DataAnalysis --&gt;|异常| 无效数据PollutionAnalysis --&gt;|污染指标同时上升| 上下游污染传递PollutionAnalysis --&gt;|pH等指标相关性| 藻类影响PollutionAnalysis --&gt;|雨量相关性| 雨污混流</code></pre><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291424058.png" alt="image.png"><br>然后插入 Excalidraw 中优化下就可以了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291428899.png" alt="image.png"><br>不到 3 分钟完成流程图绘制，而且是可以复制的，是不是很方便。</p><p>这个功能远远不止流程图这么简单，还可以绘制，饼图、序列图、甘特图、思维导图、折线图、雷达图，简直是个宝藏功能。其中流程图（Flowchart）、时序图（Sequence Diagram）和类图（Class Diagram）是支持在 Obsidian Excalidraw 中编辑的，其他的只能作为图片插入。当然作为图片插入也很好看~</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405291449838.png" alt="image.png"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>如果觉得有用，别忘了点赞、收藏、关注、留言、分享哦。</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水质预测模型精度评估实例</title>
    <link href="/2024/05/27/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%B2%BE%E5%BA%A6%E8%AF%84%E4%BC%B0/"/>
    <url>/2024/05/27/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%B2%BE%E5%BA%A6%E8%AF%84%E4%BC%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>随着水资源管理需求的日益增长，水质预测模型的精准度成为了评估其有效性的关键因素。本文旨在通过实证研究，探讨自建水质预测模型的实际应用效能，通过与真实监测数据的比对，揭示模型预测精度的真实情况。</p><h2 id="数据基础情况"><a href="#数据基础情况" class="headerlink" title="数据基础情况"></a>数据基础情况</h2><p>数据来源：自研水质模型预测结果<br>时间范围：2023 年全年<br>指标：高锰酸盐指数、总磷、氨氮、氟化物</p><h2 id="模型简介"><a href="#模型简介" class="headerlink" title="模型简介"></a>模型简介</h2><p>本研究采用基于一维水质的机理模型，通过实时监测数据动态调整降解系数与污染物迁移速度，实现了单次对高锰酸盐指数、总磷、氨氮、氟化物长达20天以上的高适应性预测，尤其擅长捕捉水质突变事件。</p><h3 id="当前预测界面"><a href="#当前预测界面" class="headerlink" title="当前预测界面"></a>当前预测界面</h3><p>曲线图展示当前最新的预测结果。下部展示预测结果是否超标，峰值及超标时间范围，预测月均值与实际累计月均值。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405280926129.png" alt="Fig.1 模型可视化页面"></p><h3 id="模型评价界面"><a href="#模型评价界面" class="headerlink" title="模型评价界面"></a>模型评价界面</h3><p>可以查询历史预测区间的预测结果对比。下部为模型评价，通过多元统计指标（如MAPE、RMSE）深入剖析模型性能，特别是通过准确率区间分布图，多维度验证了模型的稳定性和可靠性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405280928978.png" alt="Fig.2 模型评价界面"></p><h2 id="模型精度评价方法"><a href="#模型精度评价方法" class="headerlink" title="模型精度评价方法"></a>模型精度评价方法</h2><p>为了评估模型的准确率，本文采用比较直观的“预测误差率”来表达，用于评估预测值与真实值之间的接近程度。<br>$$<br>\text{A} &#x3D; 1 - \frac{|Y - \hat{Y}|}{Y}<br>$$<br>A 表示相对准确性，𝑌 是观测到的真实值（或准确值），而 Y^ 是模型预测的值。这个公式量化了预测误差相对于真实值的比例，其逆值给出了预测相对于实际观察值的接近程度，可以视为一种衡量预测准确性的度量，这种表达通常被称为相对误差的倒数或者归一化绝对误差。</p><p>理论情况下，模型每天至少运行一次，预测因子包括高锰酸盐指数、总磷、氨氮、氟化物，每次预测不少于 7 天，模型评价方法是每个因子，每次所有预测结果，依次与监测指标进行比对，单个指标每次每个值得预测准确率计为 A。<br>$$ \bar &#x3D; \frac{1}{N} \sum_{i&#x3D;1}^{N} A_i $$<br>这段公式表示求所有单次单个因子所有预测值的算术平均，其中 N 是预测值的数量。<br>用这种方法观察一年每次预测准确率的变化。</p><h3 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h3><p>创建了一个 <code>WaterQualityPredictor</code> 类，该类封装与数据库交互、数据处理、预测数据获取、监测数据获取、准确率计算以及绘图等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaterQualityPredictor</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, db_config</span>):<br>        self.db_config = db_config<br>        self.conn = self._connect_db() <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_connect_db</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;连接数据库&quot;&quot;&quot;</span><br>        conn = pymysql.connect(**self.db_config)<br>        <span class="hljs-keyword">return</span> conn<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_model_data</span>(<span class="hljs-params">self, sql</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;从数据库获取模型数据&quot;&quot;&quot;</span><br>        df = pd.read_sql(sql, self.conn)<br>        <span class="hljs-keyword">return</span> self._process_data(df) <br>    @<span class="hljs-built_in">staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_process_data</span>(<span class="hljs-params">df</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;处理数据，包括时间格式转换和数值处理&quot;&quot;&quot;</span><br>        df[<span class="hljs-string">&quot;create_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;create_time&quot;</span>])<br>        df[<span class="hljs-string">&quot;start_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;start_time&quot;</span>])<br>        df[<span class="hljs-string">&quot;date_time&quot;</span>] = pd.to_datetime(df[<span class="hljs-string">&quot;date_time&quot;</span>])<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;CODmn&quot;</span>, <span class="hljs-string">&quot;NH3&quot;</span>, <span class="hljs-string">&quot;TP&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>]:<br>            df[col] = df[col].astype(<span class="hljs-built_in">float</span>).<span class="hljs-built_in">round</span>(<span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">return</span> df<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_prediction_dataset</span>(<span class="hljs-params">self, factor, create_time, prediction_days=<span class="hljs-number">7</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据因子和创建时间获取预测数据集&quot;&quot;&quot;</span><br>        subset = self.model_data[(self.model_data[<span class="hljs-string">&quot;create_time&quot;</span>] == create_time) &amp; (self.model_data[factor].notnull())].iloc[:<span class="hljs-number">6</span>*prediction_days]<br>        subset = subset[[<span class="hljs-string">&quot;date_time&quot;</span>, factor]].set_index(<span class="hljs-string">&quot;date_time&quot;</span>).reset_index()<br>        <span class="hljs-keyword">return</span> subset<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_monitor_data</span>(<span class="hljs-params">self, begin_time, end_time, station, period</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;获取监测数据&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 这里省略具体的请求逻辑，</span><br>        <span class="hljs-keyword">pass</span> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_accuracy</span>(<span class="hljs-params">self, prediction_df, monitor_df, factor</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;计算准确率&quot;&quot;&quot;</span><br>        concatenated_data = pd.merge(prediction_df, monitor_df, on=<span class="hljs-string">&quot;date_time&quot;</span>, suffixes=(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;_y&#x27;</span>))<br>        concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>] = <span class="hljs-number">1</span> - (<span class="hljs-built_in">abs</span>(concatenated_data[factor] - concatenated_data[factor+<span class="hljs-string">&#x27;_y&#x27;</span>]) / concatenated_data[factor])<br>        concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>] = concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>] * <span class="hljs-number">100</span><br>        average_accuracy = concatenated_data[<span class="hljs-string">&#x27;Accuracy&#x27;</span>].mean()<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">round</span>(average_accuracy, <span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_comparison</span>(<span class="hljs-params">self, concatenated_data, factor</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;绘制预测值与监测值对比图&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> concatenated_data[<span class="hljs-string">&#x27;date_time&#x27;</span>].equals(concatenated_data[<span class="hljs-string">&#x27;date_time_y&#x27;</span>]):<br>            plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>            plt.plot(concatenated_data[<span class="hljs-string">&#x27;date_time&#x27;</span>], concatenated_data[factor], label=<span class="hljs-string">&#x27;Prediction&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>            plt.plot(concatenated_data[<span class="hljs-string">&#x27;date_time_y&#x27;</span>], concatenated_data[factor+<span class="hljs-string">&#x27;_y&#x27;</span>], label=<span class="hljs-string">&#x27;Monitor&#x27;</span>, marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>            plt.xlabel(<span class="hljs-string">&#x27;Date Time&#x27;</span>)<br>            plt.ylabel(factor + <span class="hljs-string">&#x27; Value&#x27;</span>)<br>            plt.title(<span class="hljs-string">f&#x27;Comparison of <span class="hljs-subst">&#123;factor&#125;</span> Prediction and Monitor Values&#x27;</span>)<br>            plt.xticks(rotation=<span class="hljs-number">45</span>)<br>            plt.legend()<br>            plt.show()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;date_time and date_time_y are not aligned&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_analysis</span>(<span class="hljs-params">self, factor, create_time, station, period, prediction_days=<span class="hljs-number">7</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;执行整个分析流程&quot;&quot;&quot;</span><br>        self.model_data = self.fetch_model_data(<span class="hljs-string">&quot;SELECT * FROM mechanism&quot;</span>)<br>        prediction_df = self.get_prediction_dataset(factor, create_time, prediction_days)<br>        monitor_df = self.fetch_monitor_data(prediction_df[<span class="hljs-string">&quot;date_time&quot;</span>].<span class="hljs-built_in">min</span>(), prediction_df[<span class="hljs-string">&quot;date_time&quot;</span>].<span class="hljs-built_in">max</span>(), station, period)<br>        accuracy = self.calculate_accuracy(prediction_df, monitor_df, factor)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Average Accuracy: <span class="hljs-subst">&#123;accuracy&#125;</span>%&quot;</span>)<br>        self.plot_comparison(pd.concat([prediction_df, monitor_df], axis=<span class="hljs-number">1</span>), factor) <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    db_config = &#123;<br>        <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;port&quot;</span>: ,<br>        <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;db&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;charset&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>    predictor = WaterQualityPredictor(db_config)<br>    predictor.run_analysis(<span class="hljs-string">&quot;factor&quot;</span>, datetime.now() - timedelta(days=<span class="hljs-number">7</span>), <span class="hljs-string">&quot;station&quot;</span>, <span class="hljs-string">&quot;h4&quot;</span>)<br></code></pre></td></tr></table></figure><p>实现任意预测时间的单词预测结果对比。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405280951942.png" alt="Fig.3单次预测高指预测对比"></p><h3 id="折线图分析准确率变化"><a href="#折线图分析准确率变化" class="headerlink" title="折线图分析准确率变化"></a>折线图分析准确率变化</h3><p>循环计算单词预测结果，取 2023 年整个时间段，四个指标准确率变化分别绘图。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405281034254.png" alt="Fig.4 预测精度折线图"><br><em>注：部分预测异常时段，存在站点运行问题，为展示真实预测情况，未对齐进行剔除。从预测异常的频次看出，异常频率并不高。</em></p><h3 id="饼图分析准确率占比"><a href="#饼图分析准确率占比" class="headerlink" title="饼图分析准确率占比"></a>饼图分析准确率占比</h3><p>为了更直观的分析预测准确率的分布，对四个因子准确率的分布划分为（小于40, 40<del>60, 60</del>80, 80~100）四个区间，分别作图如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_data_for_piechart</span>(<span class="hljs-params">df, column</span>):<br>    bins = [-np.inf, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">80</span>, <span class="hljs-number">100</span>]<br>    labels = [<span class="hljs-string">&#x27;&lt;40%&#x27;</span>, <span class="hljs-string">&#x27;40%-60%&#x27;</span>, <span class="hljs-string">&#x27;60%-80%&#x27;</span>, <span class="hljs-string">&#x27;80%-100%&#x27;</span>]<br>    <span class="hljs-comment"># 使用cut函数将数据切分为区间，并计算每个区间内数据点的数量</span><br>    intervals = pd.cut(df[column], bins=bins, labels=labels, include_lowest=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 计算每个区间的频率</span><br>    frequencies = intervals.value_counts(normalize=<span class="hljs-literal">True</span>) * <span class="hljs-number">100</span><br>    <span class="hljs-keyword">return</span> frequencies<br>columns_to_analyze = df_2023.columns.tolist() <br>fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>), facecolor=<span class="hljs-string">&#x27;white&#x27;</span>)<br>axs = axs.ravel()  <span class="hljs-comment"># 将2x2的数组展平以便循环 </span><br><span class="hljs-keyword">for</span> i, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(columns_to_analyze):<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(axs):  <span class="hljs-comment"># 确保不会超出子图的范围</span><br>        frequencies = prepare_data_for_piechart(df_2023, column)<br>        axs[i].pie(frequencies, labels=frequencies.index, autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>)<br>        axs[i].set_title(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;column&#125;</span> Precision Distribution&#x27;</span>)<br>        axs[i].axis(<span class="hljs-string">&#x27;equal&#x27;</span>)  <span class="hljs-comment"># 确保饼图是圆形</span><br><span class="hljs-comment"># 隐藏未使用的子图</span><br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(axs)):<br>    fig.delaxes(axs[j])<br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405281028472.png" alt="Fig.5 预测准确率分布饼图"></p><p>上图表明，高锰酸盐指数准确率超过 60%的比例占比 95.4%，总磷准确率准确率超过 60%的比例 91.7%。详细指标可见下表。</p><table><thead><tr><th></th><th>年平均准确率</th><th>预测天数</th><th>&gt;80%</th><th>80~ 60%</th></tr></thead><tbody><tr><td>高锰酸盐指数</td><td>84.78</td><td>327</td><td>83.2</td><td>14.1</td></tr><tr><td>总磷</td><td>79.52</td><td>327</td><td>70.6</td><td>21.1</td></tr><tr><td>氨氮</td><td>-186</td><td>321</td><td>0.9</td><td>4</td></tr><tr><td>氟化物</td><td>81.27</td><td>119</td><td>36.1</td><td>63.95</td></tr><tr><td><em>注：受站点运行情况影响，部分时段无数据。</em></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="直方图分析准确率分布"><a href="#直方图分析准确率分布" class="headerlink" title="直方图分析准确率分布"></a>直方图分析准确率分布</h3><p>直方图（Histogram）是一个更好的可视化选择，因为它能清晰地展示每个准确率区间内的数据点数量，非常适合观察数据分布特征，如中心趋势、偏斜程度及异常值等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>bin_width = <span class="hljs-number">10</span><br>bins = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">110</span>, bin_width)) + [<span class="hljs-number">100</span>]  <span class="hljs-comment"># 包含100%的边界</span><br><span class="hljs-comment"># 创建一个2x2的子图网格</span><br>fig, axs = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">10</span>))<br><span class="hljs-comment"># 遍历每个因子，并绘制其准确率的直方图</span><br><span class="hljs-keyword">for</span> i, column <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(df_2023.columns):<br>    row = i // <span class="hljs-number">2</span><br>    col = i % <span class="hljs-number">2</span><br>    <span class="hljs-comment"># 绘制直方图</span><br>    axs[row, col].hist(df_2023[column], bins=bins, edgecolor=<span class="hljs-string">&#x27;black&#x27;</span>, alpha=<span class="hljs-number">0.7</span>)<br>    axs[row, col].set_title(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;column&#125;</span> Accuracy Distribution&#x27;</span>)<br>    axs[row, col].set_xlabel(<span class="hljs-string">&#x27;Accuracy (%)&#x27;</span>)<br>    axs[row, col].set_ylabel(<span class="hljs-string">&#x27;Frequency&#x27;</span>)<br><span class="hljs-comment"># 如果因子少于4个，隐藏多余的子图</span><br><span class="hljs-keyword">for</span> ax <span class="hljs-keyword">in</span> axs.flat[<span class="hljs-built_in">len</span>(df_2023.columns):]:<br>    ax.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><span class="hljs-comment"># 紧凑布局</span><br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405281046534.png" alt="Fig.6 预测精度分布直方图"><br>直方图能清晰的看出高锰酸盐指数、总磷预测准确率更好，且分布更集中。</p><p>本模型氨氮预测准确率低的原因是：该目标站点氨氮指标长期较低。月均值波动在 0<del>0.2 之间，小时值可能长期处于 0</del>0.1 之间，即使较小的波动，准确率的值波动也很大。同时氨氮指标该站点与上游站点的关系不密切，只有较大的污染传递才能引起轻微升高。<br>经过长期观察，氨氮并非该站点的重点污染指标。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>机理模型在某站点高锰酸盐指数、总磷、氟化物等指标 2023 年的预测均有较好的表现。以准确率（归一化绝对误差的逆）评价，累计分别为 84.78%、79.52%、81.27%。</li><li>由于氨氮值较低，且与上游站点变化较弱，对于氨氮指标的预测准确率不高。也因为氨氮值较低并非重点关注对象，若要考虑提高预测精度，可选择大数据模型，如 LSTM、prophet 等。</li><li>准确率（归一化绝对误差的逆）并不是水质模型精度评价的必选指标，只是因为其较为通俗易懂，而受用户认可，仍需注意其具有一定的局限性，作为一个模型评价的参考指标即可，不宜过分求高，水质模型是否准确，应考虑其预测水质变化的能力，水质影响（峰值、污染持续时间）等，是否能够知道业务需要，才是水质模型最重要的指标。</li></ol><p>综上所述，本研究构建的机理模型在多数水质指标预测上展现了良好的效果，尤其在高锰酸盐指数、总磷和氟化物的预测上取得了显著成绩。然而，氨氮预测的挑战凸显了模型对低浓度污染物处理能力的局限，后续将结合先进的机器学习技术以增强特定条件下的预测能力。水质模型的终极目标不仅是追求高精度数值，更重要的是能否有效指导水环境管理和应对策略，确保模型服务于实际的环境治理需求。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>时间序列模型</tag>
      
      <tag>生态环境</tag>
      
      <tag>机理模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian Excalidraw 更换字体 最新</title>
    <link href="/2024/05/26/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20excaildraw%20%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/"/>
    <url>/2024/05/26/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20excaildraw%20%E6%9B%B4%E6%8D%A2%E5%AD%97%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>​<meta name="referrer" content="no-referrer" /></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Excalidraw 是 obsidian 中最厉害的插件之一，长期霸占插件排行榜第一。以其强悍的性能和灵活的可塑性受到大家的喜爱，可默认的字体对中文并不友好，网上大多数教程要不是过时了，要不是错的，还有就是太复杂，因此本文介绍如何更换本地字体，参考的是 obsidian 官方 YouTube 教程。<br><strong>Obsidian 版本：v 1.5.12</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8ae99ee9eb4634ff04bc243d04d67421.png" alt="默认字体效果预览">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>默认字体效果预览</p><h2 id="文件链接设置"><a href="#文件链接设置" class="headerlink" title="文件链接设置"></a>文件链接设置</h2><p>首先打开设置-文件与链接-开启检测所有类型文件</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bca4ebd36084209275591a06cf1fd35d.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><h2 id="下载并存放本地字体"><a href="#下载并存放本地字体" class="headerlink" title="下载并存放本地字体"></a>下载并存放本地字体</h2><p>下载喜欢的字体，一开始我随便下载字体，比如 <strong>霞鹜文楷</strong>开源字体，但是设置不能生效。 折腾了很久后发现，只能用 Google fonts 网站下载的字体文件才可以。 这个 Google fonts网站真的良心，秒杀国内一众广告字体网站。<br>打开网站，语言选择中文简体，我用的 MaShanZheng 这个字体。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6f61b35846239ff3eb82a36c07a7e0e7.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><p>文件下载好后，放在 obsidian 任意文件夹下，最好放在Excaildraw 相关文件，便于管理，文件夹命名为 Fonts，obsidian 会自动识别字体。</p><h2 id="修改-excaildraw-设置"><a href="#修改-excaildraw-设置" class="headerlink" title="修改 excaildraw 设置"></a>修改 excaildraw 设置</h2><p>重启 obsidian，打开设置-第三方插件 excalidraw-非 excalildraw 官方支持的特性-自定义字体-开启自定义-选择字体。如果没有看到字体则重启 obsidian</p><p><img src="https://img-blog.csdnimg.cn/img_convert/271ff7c764d3757a3f852a6522d30e4f.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><p>成功。文字元素会对一些功能，可以选择本地字体。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c4d8e2d61e872494e1779bae876f70f0.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d72dfdf7238ae5b7d6fec3e3da106daf.png" alt="image.png">​</p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" title="点击并拖拽以移动">编辑</p><p>image.png</p><p>希望本文能帮组到你，别忘了点赞，关注，留言哦。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
      <tag>经验分享</tag>
      
      <tag>excaildraw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>markdown 文件渲染工具推荐 obsidian publish</title>
    <link href="/2024/05/24/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/markdown%20%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%20obsidian%20publish/"/>
    <url>/2024/05/24/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/markdown%20%E6%96%87%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90%20obsidian%20publish/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p> Markdown 是一种轻量级的标记语言，最开始使用它是觉得码字非常方便，从一开始的 word 排版到 markdown ，还不太不习惯，用了 obsidian 把一些文字发在网上后，才逐渐发现他的厉害之处。</p><ol><li>让人更加专注于内容本身，markdown 可以轻松转为 HTML，意味着可以直接生成博客。</li><li>可以配置元数据，无缝对接博客设置标签</li><li>跨平台、易学习，版本控制优化，利用 Git 等版本控制系统，能有效地追踪和管理文档变更。</li><li>Markdown 可以直接转为带有 css 格式的文字，可以直接复制粘贴就是一篇排版精美的文字。也就是今天要推荐的工具。</li><li>很多社区、笔记软件都支持 markdown，意味着你的笔记可以任意迁移，任意传播，不需要多次修改格式。</li><li>有了 markdown 和码字工具 obsidian，那么就可以建立一个丝滑的工作流。</li></ol><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>![[写作流程]]<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405242138321.png" alt="image.png"></p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><p>要实现快速丝滑的发表在各个平台上，之前都是直接复制 markdown 源码，这也是我喜欢发 CSDN 的原因。<br>近来开了个公众号，才发现，公众号的编辑器是真的拉胯，居然衍生了诸如 96 编辑器、秀米、135 编辑器等诸多编辑器工具，编辑格式费时、费力，违背了重视内容的初衷。</p><p>可总有前辈做了改变的工作，一开始尝试了 B 站大佬孙博士研究所的 obsidian 插件。</p><p><a href="https://github.com/sunbooshi/note-to-mp">https://github.com/sunbooshi/note-to-mp</a></p><p>存在 2 个问题，一是代码超过 10 条数字就异常，二是复制进入公众号后，页面会很窄。</p><p>通过查找，发现了今天的主角。<br><a href="https://md.openwrite.cn/">微信 Markdown 编辑器 (openwrite.cn)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405242146512.png" alt="image.png"></p><p>该编辑器支持 Markdown 语法，实时预览，支持代码高亮，自带样式效果已经够用。</p><p>希望对你有所帮助，通过这些工具建立自己的写作工作流。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QGIS DEM数据快速获取</title>
    <link href="/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/QGIS%20DEM%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96/"/>
    <url>/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/QGIS%20DEM%E6%95%B0%E6%8D%AE%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Dem 是非常重要的数据，30 m 的精度也是最容易获取的，目前有很多种方式可以获取，比如地理空间数据云，今天介绍用 QGIS插件获取。<br>这种方式的最大优势是方便快捷，当我们有评价区域范围图层时，更加方便。</p><h2 id="插件下载与安装"><a href="#插件下载与安装" class="headerlink" title="插件下载与安装"></a>插件下载与安装</h2><p>插件-管理并安装插件-搜索下载<br>OpenTopography DEM Downloader<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221855383.png" alt="image.png"></p><p>注册账号并获取 key<br>操作非常简单，没有限制，国内能访问，但有点慢。<br><a href="https://portal.opentopography.org/myopentopo">myOpenTopo Workbench (opentopography.org)</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221845374.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221844472.png" alt="image.png"></p><h2 id="下载-dem"><a href="#下载-dem" class="headerlink" title="下载 dem"></a>下载 dem</h2><p>选着你要下载的区域，点击插件图标<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221846162.png" alt="image.png"><br>选择 dem 类型，推荐 30 m，选择下载范围，然后输入 key，就可以了。<br>选择下载方式可以通过图层、显示范围及手动画范围等三种方式。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221848829.png" alt="image.png"></p><p>成功，注意网站下载的默认是 wgs 84 坐标系，其他坐标系需要自己转换。<br>下载后导入 ArcGIS 使用时，需要定义坐标系。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221850911.png" alt="image.png"></p><p>转换投影建议在 ArcGIS 中操作<br>搜索投影栅格，选择合适的投影坐标系即可。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406181607135.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>arcgis</tag>
      
      <tag>水文分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解ArcGIS 水文分析模型构建</title>
    <link href="/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%20%E6%B0%B4%E6%96%87%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/"/>
    <url>/2024/05/22/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%20%E6%B0%B4%E6%96%87%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在地理信息系统（GIS）领域，水文分析是一项至关重要的任务，它涉及到对地表水流动路径、河流网络、流域划分等关键水文特征分析。这些分析对于水资源管理、洪水预警、环境规划以及城市排水系统设计等众多领域都具有重要的应用价值。</p><p>本文旨在探讨ArcGIS中水文分析的全过程，并展示如何构建一个可复用的水文分析模型。通过本文的学习和实践，读者将能够深入了解ArcGIS在水文分析方面的应用，掌握从数据预处理到模型构建、从模型运行到结果输出的整个流程。此外，本文还将介绍如何将ArcGIS模型脚本化，以提高模型的复用性和自动化程度。</p><p>在接下来的章节中，我们将详细介绍水文分析的各个步骤，包括资料背景的准备、操作中可能出现的问题及注意事项、分析框架的梳理、水文模型的搭建、模型思维和图形化界面的构建等。通过这些内容的学习，读者将能够全面掌握 ArcGIS 水文分析的相关知识和技能。</p><h2 id="项目环境、条件"><a href="#项目环境、条件" class="headerlink" title="项目环境、条件"></a>项目环境、条件</h2><ul><li>ArcGIS 10.8 中文包</li><li>已开启 Spatial Analyst Tools 分析工具</li><li>Win 10<br>理论上 ArcGIS 10.2 也几乎一样，部分工具可能由翻译问题，建议初学者完全按照本文的文档结构进行。</li></ul><h2 id="Dem-数据预览"><a href="#Dem-数据预览" class="headerlink" title="Dem 数据预览"></a>Dem 数据预览</h2><p> <strong>DEM</strong>（Digital Elevation Model，数字高程模型）是一种用于表示地表地形起伏的数字模型。它通过规则格网的矩阵形式，记录每个格网单元的高程值，从而在计算机中构建出地形的三维模型。DEM 是地理信息系统（GIS）中重要的空间数据类型之一，广泛应用于地形分析、水文模拟、城市规划、地质灾害评估等多个领域。<br> Dem 可以通过地理空间数据云、QGIS 插件、CAD 地形文件生产等多种方式获取。此前有介绍，本文不多赘述。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221924998.png" alt="image.png"></p><h2 id="ArcGIS模型构建器"><a href="#ArcGIS模型构建器" class="headerlink" title="ArcGIS模型构建器"></a>ArcGIS模型构建器</h2><p><strong>ArcGIS模型构建器</strong>是Esri公司开发的ArcGIS软件中的一个强大工具，它允许用户通过图形化界面来创建、编辑和运行一系列自动化的GIS分析模型。模型构建器的核心优势在于能够将复杂的GIS分析流程简化为一系列可视化的步骤，使得用户无需编写代码即可完成复杂的空间分析任务。<br>可以在空白文件夹下，点击按钮打开，也可以在文件夹内，右键打开。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231055335.png" alt="image.png"><br>建议像笔者一样，建立好文件夹框架，依次新建文件数据库-工具集-模型。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231057487.png" alt="image.png"><br>在模型构建器中，数据类型如下，本文将用到项目数据、工具、派生数据和值等类型。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231059219.png" alt="image.png"><br>将数据、工具等可以直接拖入模型界面中，非常方便。</p><h2 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h2><h3 id="填洼"><a href="#填洼" class="headerlink" title="填洼"></a>填洼</h3><p>dem-填洼-fill<br><strong>填洼</strong>（Fill）是去除 dem 中的洼地（sinks）或凹陷（depressions）。这些洼地在地形分析中可能会导致错误的水流方向和流域划分，需要通过填洼操作来纠正。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221609608.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221926917.png" alt="image.png"></p><h3 id="流向"><a href="#流向" class="headerlink" title="流向"></a>流向</h3><p>fill-流向-FlowDirection<br>注意选着 fill 时需要选择蓝色循环的那个，为变量值。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221614049.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221618226.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221930624.png" alt="image.png"></p><h3 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h3><p>FlowDirection-流量-fillacc<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221620132.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221620254.png" alt="image.png"><br>根据栅格数值大小隐约能看出河流的线条。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221934241.png" alt="image.png"><br>点击栅格可以查询该处的数值，通过这种方法判断最小径流的值，后面有用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221937003.png" alt="image.png"></p><h3 id="河流长度"><a href="#河流长度" class="headerlink" title="河流长度"></a>河流长度</h3><p>FlowDirection-河流长度-flowlength 测量方向选择 upstream，<br>水流长度工具的主要用途是计算给定盆地内最长水流的长度。该度量值常用于计算盆地的聚集时间。这可使用 UPSTREAM 选项来完成。该工具也可通过将权重栅格用作下坡运动的阻抗，来创建假设降雨和径流事件的距离-面积图。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221949623.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230838124.png" alt="image.png"></p><h3 id="栅格计算器"><a href="#栅格计算器" class="headerlink" title="栅格计算器"></a>栅格计算器</h3><p>栅格计算器 或者条件函数<br>栅格计算器（Raster Calculator）  条件函数 Con(FlowAccu&gt;R,1)<br>目的是将流量栅格数据中提取河流的部分，公式为”flowacc” &gt;&#x3D; 1000。<br>在模型构建器中使用左右%代表变量。新增一个变量，作为流量限值 R，建议通过流量栅格 (flowacc), 点击查询河流的最小栅格，我这里根据实际情况，选择输入 1000。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230842687.png" alt="image.png"></p><p>具体公式以自己实验为准，添加变量后，修改为”%fillacc%” &gt;&#x3D;  “%任意值%”<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221641559.png" alt="image.png"><br>记得点击任意值，添加 1000，这样以后只需要修改这个值，就可以调整河流长度了。<br>Acc 1000 结果，可见满足条件的，也就是河流为 1，不满足的为 0.<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230854890.png" alt="image.png"></p><h3 id="河流链接"><a href="#河流链接" class="headerlink" title="河流链接"></a>河流链接</h3><p>acc1000+FlowDirection&#x3D;Streamlink<br>by 河流链接<br>河流链接的作用有：<strong>构建连续的河流网络</strong>：河流链接工具能够识别并连接相邻的河流段，确保河流网络在空间上是连贯和正确的。<strong>分配唯一标识符</strong>：给河流网络中的每个部分分配唯一的 ID，便于管理和进一步分析。这有助于区分不同的河流分支和主流，以及分析它们各自的属性（如流量、长度等）。<strong>优化数据结构</strong>，减少在模型中处理大量独立线段时的复杂性。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221642956.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230924178.png" alt="image.png"></p><h3 id="河网分级"><a href="#河网分级" class="headerlink" title="河网分级"></a>河网分级</h3><p>acc1000+FlowDirection&#x3D;StreamOrder<br>by 河网分级<br>河网结构用于识别河流上下级，常见的河网分级方法有斯特拉勒（Strahler）、希科特（Horton）和谢内（Shreve）等。斯特拉勒法是最常用的，它基于河流交汇规则来分配等级，即每次支流汇入时，如果两支流的等级相同，则合并后的河段等级加1；如果不同，则高等级保持不变。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221635748.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230928380.png" alt="image.png"></p><h3 id="栅格河网矢量化"><a href="#栅格河网矢量化" class="headerlink" title="栅格河网矢量化"></a>栅格河网矢量化</h3><p>StreamOrder+FlowDirection&#x3D;StreamOrder1000<br>by 栅格河网矢量化<br>顾名思义，栅格河网矢量化就是将河流网络的栅格数据转换成矢量数据格式，便于分析、可视化及水文建模应用。注意如果要增加河流长度等字段，需要在投影坐标系下进行。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221824966.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230932035.png" alt="image.png"></p><h3 id="绘制倾泻点"><a href="#绘制倾泻点" class="headerlink" title="绘制倾泻点"></a>绘制倾泻点</h3><p>StreamOrder 1000+end&#x3D;FeatureVert_1000<br>By要素折点转点<br><strong>倾泻点</strong>是指汇流区域中具有最低高程的边界象元。它标志着水从一个流域流向另一个流域的出口点，或者是水流离开一个封闭流域（如盆地）的地点。<br>可以通过要素折点转点生成，也可以根据自己手工增加，形式是一些离散的点。<br>要素折点转点，顾名思义，指通过矢量线的折点或转点然后生成点，有 all、mindle、end、start、both_ends、dangle（悬挂点，指离散点） 等类型，绘制倾泻选择 end 。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221825292.png" alt="image.png"><br>倾泻点非常关键，是汇水区分析的重要参数，除了自动生成的点外，可以根据实际需要，添加、删除点。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230948266.png" alt="河流与倾泻点"></p><h3 id="栅格流域提取"><a href="#栅格流域提取" class="headerlink" title="栅格流域提取"></a>栅格流域提取</h3><h6 id="集水区"><a href="#集水区" class="headerlink" title="集水区"></a>集水区</h6><p>集水区也就是分水岭，根据流向和倾泻点一起做的汇水范围。有倾泻点的会比盆域分析更细，他与倾泻点的点位有很大关系。<br>FlowDirection+FeatureVert_1000&#x3D;倾泻点字段为空&#x3D;watersh</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221645662.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230956061.png" alt="image.png"></p><h4 id="盆域分析"><a href="#盆域分析" class="headerlink" title="盆域分析"></a>盆域分析</h4><p>流向 FlowDirection 盆域分析&#x3D; basin<br>盆域分析，也就是流域分析，可以理解为没有倾泻点的大范围流域分析。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221647107.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230957148.png" alt="image.png"></p><p>运行模型-成功<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221731875.png" alt="image.png"></p><h3 id="栅格转面"><a href="#栅格转面" class="headerlink" title="栅格转面"></a>栅格转面</h3><p>上述流域栅格，转为矢量图层。用于可视化和计算，作用与栅格河网矢量化类似。<br> basin&#x2F;watersh 栅格转面 RasterT_basin &#x2F;RasterT_watersh</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221727096.png" alt="image.png"><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405230955132.png" alt="子流域范围.png"></p><p>至此，水文分析基本结束。<br>调试模型，运行成功。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405221742623.png" alt="image.png"></p><p>调整模型架构，让连接线不交叉。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231005860.png" alt="image.png"></p><h2 id="模型应用"><a href="#模型应用" class="headerlink" title="模型应用"></a>模型应用</h2><h3 id="导出-py-文件"><a href="#导出-py-文件" class="headerlink" title="导出 py 文件"></a>导出 py 文件</h3><p>可以导出 py 文件，进行模型复用。在 ArcGIS 环境中导入脚本，注意导入前修改绝对地址注意保持一致。另外它基于 ArcPy 模块，一个专为 ArcGIS 设计的空间分析和数据处理库。因此，它的运行环境依赖于 ArcGIS，使用 ArcGIS Python 2.X 环境编写的。不能用于 python 3 中。<br>经过测试，代码并不能直接使用，需要重新编译后才能使用，后续会出一期 python 水文分析的文章。</p><h3 id="完善脚本"><a href="#完善脚本" class="headerlink" title="完善脚本"></a>完善脚本</h3><ol><li>将 dem 输入变为变量，方法为新增变量-栅格数据集，然后选择对应的 dem 位置。</li><li>重命名，将 dem 命名为输入 dem。双精度命名为输入流量下限值。</li><li>完善模型参数，模型-模型属性-参数将输入 dem、输入流量下限值作为必填项</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231021444.png" alt="image.png"></p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p>点击模型打开，输入 dem 和下限值，点击运行。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231038360.png" alt="1716431898456.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231039764.png" alt="image.png"><br>运行成功，结果输出在模型内指定的文件夹。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405231040644.png" alt="image.png"><br>重新运行将会替换结果文件，运行一次后，结果移动出来，再次使用。总之，非常方便。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文通过详细探讨ArcGIS水文分析的全过程，不仅展示了如何利用ArcGIS模型构建器来创建一个高效、可复用的水文分析模型，还深入介绍了模型构建器的图形化界面和强大功能。通过本文的学习，读者可以清晰地看到，即使是GIS编程新手，也能通过模型构建器实现复杂的空间分析任务，而无需深入代码层面。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>arcgis</tag>
      
      <tag>水文分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝藏网站推荐-封面图片生成器</title>
    <link href="/2024/05/21/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2024/05/21/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%AE%9D%E8%97%8F%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90-%E5%B0%81%E9%9D%A2%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />  <p>封面图片生成器：<a href="https://spacexcode.com/coverview">封面图生成器 | 太空编程 (spacexcode.com)</a><br>最近爱上了写文案，在网上冲浪的时候发现一个宝藏网站。Spacecode，一个大神维护的个人网站，含有前端知识库、个人博客及他做的开源项目。<br>其中封面图片生成器简单好用，完全免费，自来水一下。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211851977.png" alt="image.png"><br>其他作品，如毛玻璃效果生成器、代码图片生成器、文字卡片等等，都非常棒。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211852301.png" alt="image.png"><br>作者项目做的很好，从他的简介也可以看出，是个很棒的家伙，向他学习。Build in public，learn in public。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从 CAD 到 ArcGIS：高精度DEM 数字高程文件生成</title>
    <link href="/2024/05/21/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%E5%AF%BC%E5%85%A5autoCAD%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%95%B4%E7%90%86/"/>
    <url>/2024/05/21/02%20%E7%94%9F%E6%80%81%E7%8E%AF%E5%A2%83/ArcGIS%E5%AF%BC%E5%85%A5autoCAD%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在日常工作中，我们常需要对特定区域地形进行深入分析。易于获得的地形数据为 30 m 精度，有时无法满足项目要求，需要更高精度的地形资料，而这些资料通常以 AutoCAD 文件的形式存在。<br>这些数据需经过 GIS 系统处理，以生成所需的 dem 数据。本篇文章将循序渐进，从 CAD 地形图层常用名称开始，详尽阐述在 ArcGIS 平台上，如何处理 AutoCAD 地形文件，最终产出高精度的 DEM（数字高程模型），希望对你有所帮助。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="DEM"><a href="#DEM" class="headerlink" title="DEM"></a>DEM</h3><p><strong>DEM（Digital Elevation Model）</strong>：即数字高程模型，是通过有限的地形高程数据实现对地面地形的数字化模拟。是数字地形模型（Digital Terrain Model，简称 DTM）的一个分支。狭义的 dem 是栅格数据，在水文分析中，dem 数据可以用来生成坡向、坡度、水系、分水岭、泄水点等信息。</p><h3 id="TIN"><a href="#TIN" class="headerlink" title="TIN"></a>TIN</h3><p><strong>TIN（Triangular Irregular Network）</strong>：即不规则三角网，是基于矢量的数字地理数据的一种形式，通过将一系列折点组成的三角形来构建。各折点通过由一系列边进行连接，最终形成一个三角网。TIN 是一种更为精细的表示方法，适用于复杂地形的精确表示和分析。</p><h3 id="CAD-图层常用名称"><a href="#CAD-图层常用名称" class="headerlink" title="CAD 图层常用名称"></a>CAD 图层常用名称</h3><p>以下是常用的 CAD 地形图常用图层名称。</p><ol><li>DGX–等高线</li><li>DLSS–道路设施</li><li>DLDW–独立地物</li><li>DMTZ–地貌特征</li><li>GCD–高程点</li><li>JMD–居民地</li><li>SXSS–水系设施</li><li>ZBTZ–植被特征</li><li>GXYZ–管线设施</li><li>TK–图框</li></ol><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><p>新建 ArcGIS 项目，不要在已有坐标系的文件中添加。<br>在导入前，设置好坐标系，这需要问资料来源方。<br>右键-属性-常规-编辑，选择合适的坐标系。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211514712.png" alt="image.png"><br>将 CAD 文件拖入 ArcGIS。</p><h3 id="确定要保留的图层"><a href="#确定要保留的图层" class="headerlink" title="确定要保留的图层"></a>确定要保留的图层</h3><p>导入 CAD 文件后，会发现有很多文件，<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211516876.png" alt="image.png"><br>分别为：</p><ul><li>Annotation 注释</li><li>Point 点</li><li>Polyline 多段线</li><li>Polygon 多边形</li><li>MultiPatch 3 D 几何图形<br>一般需要关注的是 Polyline 、Point、Polygon 根据自己的需要整理对应的数据。地形数据在 Polyline 中，通过查询工具，点击对应的图层可以查询其图层名称。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211526491.png" alt="image.png"><br>比如，地形图层为 DGX。<br>右键 Polyline-属性-绘制图层-选择 DGX。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211528230.png" alt="image.png"><br>右键 Polyline-打开属性表-点击表选项-按属性选择, 输入表达式<br>“Elevation” &gt;0，可根据自己的文件属性，定义筛选表达式。</li></ul><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211531228.png" alt="image.png"><br>导出数据，右键 Polyline-数据-导出数据，导出所选要素。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211534372.png" alt="image.png"><br>可以用同样的方法将需要的图层导出 GIS 图层数据。<br>如地貌特征（DMTZ） 、水系设施（SXSS）、居民地（JMD）、道路设施（DLSS）等, 选择不同的图层时，记得提前在显示区域右键-清楚所选区域。<br>在本文示例文件中，因为是农业区域地貌特征和等高线都有高程信息，为提高精度，将两者合并导出图层精细分析。</p><h3 id="创建-TIN"><a href="#创建-TIN" class="headerlink" title="创建 TIN"></a>创建 TIN</h3><p>工具搜索-创建 TIN，高度字段输入 Elevation，注意在创建之前，最好打开属性表，观察 Elevation 值的范围，从 CAD 导入的数据可能存在异常。因此需要用前面表达式筛选的方式，选择合适的等高线范围。例如本示例需要将 Elevation 控制在 0-500 之间，500 以上的异常值去掉。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211629026.png" alt="image.png"><br>点击属性-符号系统选择分区及配色。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211647927.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211707784.png" alt="image.png"></p><h3 id="TIN-转-dem"><a href="#TIN-转-dem" class="headerlink" title="TIN 转 dem"></a>TIN 转 dem</h3><p>使用 TIN 转栅格工具，转出的数据就是我们需要的 dem 数据。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211711236.png" alt="image.png"><br>得到区域 dem 数据如下，完成。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211711285.png" alt="image.png"></p><p>用查询工具点击 dem 可得到精度信息。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405211717057.png" alt="image.png"></p><p>有了 dem 数据，我们就能做很多工作了，如水文分析的河流水系、坡度、坡向、产流量、河流链接、分水岭、流域等等。后续也会整理 dem 水文分析的操作步骤。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>本方法实际精度与 DWG 文件质量关系很大，例如示例文件中，由于地貌特征图层文件，大部分高指为 0，无法参与 dem 结果生成，降低了最终生成文件的效果。若深入探究，还可以用克里金插值等方法，提高精度。<br>总之，以上就是用 CAD 文件生产 DEM 的过程，如果有帮助到你，请点赞关注。</p>]]></content>
    
    
    <categories>
      
      <category>生态环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>用心长文</tag>
      
      <tag>arcgis</tag>
      
      <tag>水文分析</tag>
      
      <tag>地形数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡片笔记写作法 精读笔记 02</title>
    <link href="/2024/05/20/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2002/"/>
    <url>/2024/05/20/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2002/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405271919838.png" alt="image.png"></p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 卡片笔记写作法：如何实现从阅读到写作</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/15/YueWen_39136896/t7_YueWen_39136896.jpg" alt=" 卡片笔记写作法：如何实现从阅读到写作|200"></li><li>书名： 卡片笔记写作法：如何实现从阅读到写作</li><li>作者： 申克·阿伦斯</li><li>简介： 卢曼的“盒中笔记”通常很简短，因为这些只是他庞大繁杂研究中的索引，等需要时，他会借由这些线头进行延伸思考，然后不断链接知识要点，从而形成自己的知识树。你也可以试试。</li><li>出版时间 2021-06-01 00:00:00</li><li>ISBN： 9787115564672</li><li>分类： 文学-语言文字</li><li>出版社： 人民邮电出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/3d8326d072552e803d87c41">https://weread.qq.com/web/reader/3d8326d072552e803d87c41</a></li></ul></blockquote><p>继续这本书后面的部分。</p><h3 id="关于写作，你需要具备的能力"><a href="#关于写作，你需要具备的能力" class="headerlink" title="关于写作，你需要具备的能力"></a>关于写作，你需要具备的能力</h3><p>构建一个<strong>不被干扰、专心思考的笔记系统</strong>。<br>工具箱</p><ul><li>书写工具纸、笔。</li><li>文献管理工具</li><li>卡片系统</li><li>编辑工具<br>目前用的是 obsidian、zotero，其中 obsidian 用的更频繁就是我的卡片盒。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405261639805.png" alt="我的笔记工具"></li></ul><h2 id="关于写作，你需要的注意的几个问题"><a href="#关于写作，你需要的注意的几个问题" class="headerlink" title="关于写作，你需要的注意的几个问题"></a>关于写作，你需要的注意的几个问题</h2><p>不要让卡片笔记盒，沦为思想的坟场，不要只有囤积癖，没有整理的习惯。<br>我自己深有体会，之前用印象笔记 -剪藏插件的时候，会收集很多笔记，然后再也没看过。<br>笔记系统逐渐臃肿，完全不能发挥作用。</p><h3 id="三类笔记的区别"><a href="#三类笔记的区别" class="headerlink" title="三类笔记的区别"></a>三类笔记的区别</h3><p>1.闪念笔记 (Fleeting Notes)：这类笔记只是对收集信息起提醒作用，可以用任何方式来写，最后会在一两天内被扔进垃圾桶。<br>2.永久笔记 (Permanent Notes)：这种笔记以一种永久可以理解的方式包含了必要的信息，并且永远不会被扔掉。它们总是以同样的方式存放在同一个地方，或者是在文献管理系统中，或者按出版标准写好放在卡片盒中。<br>3.项目笔记 (Project Notes)：它们只与某一特定项目有关，保存在特定项目的文件夹内，项目结束后即可丢弃或存档。只有将这三类笔记分开保存，才有可能实现卡片盒笔记的群聚效应，而对这些类别的混淆也是人们写作或发表作品不多的主要原因之一。<br>项目笔记相关内容：与项目有关的文献、大纲、草稿片段、备忘录、待办事项<br>当你结束一天的工作，你的桌面除了纸和笔，没有留下任何东西，说明你已经区分好了三种笔记类型。</p><h3 id="有效写作的四个原则"><a href="#有效写作的四个原则" class="headerlink" title="有效写作的四个原则"></a>有效写作的四个原则</h3><h4 id="写作是唯一重要的事"><a href="#写作是唯一重要的事" class="headerlink" title="写作是唯一重要的事"></a>写作是唯一重要的事</h4><p>没有私密知识，有了想法只有自己知道，就等于没有想法，无法重现的论据就算不上论据。<br>只有成果公布出来，供人阅读，才有意义。专注于写作，同时也要学习与交流。</p><h4 id="简洁是最重要的"><a href="#简洁是最重要的" class="headerlink" title="简洁是最重要的"></a>简洁是最重要的</h4><p>这里指的是卡片盒笔记系统相较于传统笔记的组织方式更简洁。区分好三类笔记，按照不同的处理方式处理，最后形成群聚效应。</p><h4 id="没有人完全从零开始写作"><a href="#没有人完全从零开始写作" class="headerlink" title="没有人完全从零开始写作"></a>没有人完全从零开始写作</h4><p>日常收集整理感兴趣的素材，形成素材库。写作是非线性的，不是自上而下的，功夫在诗外。</p><h4 id="让工作推动你前进"><a href="#让工作推动你前进" class="headerlink" title="让工作推动你前进"></a>让工作推动你前进</h4><p>建立一个良好的工作机制。让工作成为一个良性循环，热爱你从事的工作，做自己喜欢做的事情。不断的形成正反馈。这一点与最近看的&#x3D;&#x3D;《重来》（贾森、戴维）卸负篇&#x3D;&#x3D;-哪来的从错误中学习有联系，我们基本很少从失败中汲取经验，只有成功才能让我们成长。良性的正反馈，是我们不断前进的动力。这里的工作应该是广义的，做你喜欢的事，做好。<br>除了具备成长的心态外，需要周期性的给自己反馈，而不是间隔很长时间的反馈，太长时间难以坚持，短期的反馈更容易让人接受，更能加强理解和改进。</p><h2 id="成功写作的六个步骤"><a href="#成功写作的六个步骤" class="headerlink" title="成功写作的六个步骤"></a>成功写作的六个步骤</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405271912873.png" alt="image.png"></p><h3 id="明确区分独立而又相关联的任务"><a href="#明确区分独立而又相关联的任务" class="headerlink" title="明确区分独立而又相关联的任务"></a>明确区分独立而又相关联的任务</h3><p>不要一心多用<br>不同的任务需要不同的关注度，比如区分写作与校对，两者需要站在不同的角度去看待事物，校对应作为批评家，从逻辑、规范等等方面去思考文章的合理性。在不同的环节需要的关注度和耗费的精力不同。<br>结合自己的经验深有体会，我以前很难做好审稿这个角色，不光是对自己写的，还是同事写的，审查的时候总是很为难，不愿意做，也没有花更多的心思，当然做不好。<br>推而广之，精读与速读，概括与修改提纲都是需要区别对待的工作，都应该有自己的方法论，不应该因为相似就不去总结。<br>艺术和科学都需要“集中的注意力”与“漂浮的注意力”，大多数杰出的科学家也都具备切换不同注意力的能力。杰出科学家解决问题的行为可以在‘对特定概念的超常专注程度’和‘对想法的有趣探索’之间交替进行。这表明，要想成功解决问题，可能需要根据任务和需求灵活地选择应对策略。”<br>有时候我们需要天马行空，而有时候我们要细微严谨，对待不同任务要切换不同的应对策略。不要把自己局限死，以为自己不擅长，而懒得去做。</p><h4 id="做专家，不作计划制定者"><a href="#做专家，不作计划制定者" class="headerlink" title="做专家，不作计划制定者"></a>做专家，不作计划制定者</h4><p>人只有不断的实践，才能积累经验。<br><strong>德雷福斯的技能获取理论</strong>:人类在特定领域习得技能时，从低技能阶段到高技能阶段的认知转变过程，并将这个过程拆分为五个阶段：新手（Novice）、高级新手（Advanced Beginner）、胜任者（Competent）、精通者（Proficient）和专家（Expert）。<br>做详细计划是没有用的，如写什么，什么时候写，怎么写。只有在具体时间中才能形成洞见。<br>同样，&#x3D;&#x3D;《重来》（贾森、戴维）卸负篇&#x3D;&#x3D;-计划即瞎猜，也提到类似的观点，作者对长期计划是呲之以鼻的，建议最多只做周计划，长期计划只是猜想，写的越细致，越是浪费时间。</p><h4 id="写下来为大脑减负"><a href="#写下来为大脑减负" class="headerlink" title="写下来为大脑减负"></a>写下来为大脑减负</h4><p>蔡格尼克效应，即未完成的任务往往会占据我们的短期记忆，直到它们被完成。<br>GTD 的思想，也是把待办事项列出，好腾出精力，一件一件应对。<br>有了想法，或者遇到素材，立马作为笔记记录下来，随后再处理。</p><h4 id="减少做决定"><a href="#减少做决定" class="headerlink" title="减少做决定"></a>减少做决定</h4><p>一般情况下，或一个心理学猜想：我们的大脑存在以下局限性：</p><ol><li>一次只能专注的做一件事。</li><li>一次只能容纳七件事的短期记忆（我感觉我都记不住 7 件）。</li><li>驱动力及意志力有限，再次回复需要时间和休息（类似能量槽）。<br>为了节约有限的意志力资源，我们需要减少做决定，比如少在工具、形式上纠结，专注于记笔记本身。重点放在文章中什么更重要、什么不重要，判断笔记之间的联系，设计文本的结构等难点上。<br>推而广之，对于日常也是，减少对非核心问题的纠结与内耗。<br>休息不仅有助于恢复精力，也对学习至关重要，休息可以让大脑处理信息并将其移入长期记忆，从而可以接受新信息。散散步，甚至打个盹儿，都有助于学习和思考。</li></ol><h3 id="阅读和理解"><a href="#阅读和理解" class="headerlink" title="阅读和理解"></a>阅读和理解</h3><blockquote><p>阅读和理解“我建议你在阅读时手里拿支笔，在小本子上记下你觉得常见的或可能有用的简短提示，因为这将是把这种痕迹印在你的记忆中的最好方法。”——本杰明·富兰克林</p></blockquote><p><strong>好记性不如烂笔头，不记录和整理，任何想法都很快会消失，难以找寻和回溯。</strong></p><h4 id="阅读时要有笔"><a href="#阅读时要有笔" class="headerlink" title="阅读时要有笔"></a>阅读时要有笔</h4><p>如何阅读文献，摘录文件内容时，表明出处，并用自己的语句阐述上下文。<br>根据文献的复杂程度，笔记也要有区分，简单的内容只需要用关键词备注即可，复杂的需要结合上下文尽可能记录清楚。这是一个锻炼自己提炼信息能力的机会。<br>文献笔记的目的是为了变成永久笔记。<br>目前的工作流是通过 zotero 、微信读书结合 obsidian，作为论文、书籍的文献笔记记录方式。<br>在文献上标注、划线等先做文献笔记，然后整理为永久笔记。<br>文献笔记形式不重要，适合自己的即可，文献笔记应该简短、流畅，形式不应太复杂，而分散注意力。<br>重点在文献笔记转换为永久笔记的过程。</p><blockquote><p>如果你说不清楚，就表示你自己也不明白。——John Searle</p></blockquote><h4 id="保持开放的心态"><a href="#保持开放的心态" class="headerlink" title="保持开放的心态"></a>保持开放的心态</h4><p>确认偏差：指人们在处理信息时倾向于寻找、解释、记忆和重视与自己已有信念或假设相一致的信息，而忽略或轻视与之相矛盾的信息。这种偏差会导致人们在决策和评估信息时，无意识地保持自己的先入之见，从而影响客观判断。<br>确实我们很容易掉入这种认知错误中去，总带着一个预设的答案去寻找答案，固执己见、刚愎自用，都是这样的形成的。<br>保持开放的心态，是分析和学习的重要基调，广泛的收集意见（相关的或者矛盾的），审慎的考虑，避免掉入确认偏差，也不要沉浸信息茧房，多与他人讨论学习，认真倾听。<br>知难行易，认识到这个问题已经很重要了。</p><h4 id="推动项目进展的步骤"><a href="#推动项目进展的步骤" class="headerlink" title="推动项目进展的步骤"></a>推动项目进展的步骤</h4><ul><li>确认是否已分解任务，专注于理解阅读的文本或者课程讲解</li><li>为阅读理解的内容做好笔记</li><li>找到笔记的关联，并建立联系<br>我们对将要添加笔记盒的内容无法提前预知，只需要添加相关联的内容，并把他们串联起来就好。</li></ul><h3 id="培养抓住重点的能力"><a href="#培养抓住重点的能力" class="headerlink" title="培养抓住重点的能力"></a>培养抓住重点的能力</h3><blockquote><p>那些拥有大量思考工具并知道如何应用的人是拥有“普世智慧”的人。——查理芒格</p></blockquote><blockquote><p>“阅读学术文章的困难似乎在于短期记忆对我们没有帮助，我们需要长期记忆来提供参考资料，帮助我们区分什么事情重要、什么事情不重要，哪些信息是新的、哪些信息是重复的。但是除非死记硬背，不然我们不可能记住所有的东西。换句话说，我们必须在阅读方面有非常好的选择能力，并能够提取广泛且有联系的参考资料，必须能够跟踪反复出现的问题。只是，如果没有指导，那该如何掌握这样的能力呢？最好的方法可能不是摘录，而是做笔记，就是对所阅读的文本进行浓缩重写。对所阅读的材料进行重写，能够自动地训练人们把注意力转移到文本的框架、模式和类别中来，或者是转移到文本的条件或假设上面，注意到这些以后，你的表述就会变得与之前不同。有效的办法是在阅读过程中时刻谨记以下问题：当文章中提出某个主张时，作者想要说明的是什么，想要排除的又是什么？比如有人提到了‘人权’，他要对比的是什么？是‘没有人权’？还是‘义务’？是一种文化的对比？还是与历史上的那些没有人权概念却依然能和平相处的人们对比？对于这个问题，往往难以从文本中找到直接或明确的答案，只能依靠读者自己的理解。”——卢曼</p></blockquote><p>写作的目标：言简意赅、表达清晰、切中要害。辨别模式、质疑所用框架，并发现不同作品间差异的能力，是进行批判性思考并审视文本或谈话背后观点的先决条件。能够对问题、论断和信息进行重新构架，甚至比拥有广博的学识更重要，因为如果没有这种能力，我们就无法将知识用于实践。<br>只有刻意练习才能达到，快速抓住重点的能力，只有一篇篇笔记被记录，并进行总结和练习，才能逐渐形成这种能力。</p><h3 id="在阅读中学习"><a href="#在阅读中学习" class="headerlink" title="在阅读中学习"></a>在阅读中学习</h3><blockquote><p>只有去做才能学。——泰利·道尔</p></blockquote><p>自己制作大纲，思维导图，不要过分依赖别人总结好的内容，因为这部分工作正是学习的过程。<br>在学习过程中适当增加难度，如增加测试，情景练习，讲解输出等，反而有助于学习，单纯的重复阅读没有任何意义。提取强度比存储强度更有重要，以用促学，以教促学，与费曼学习法相通。<br>回顾毕业后的学习，很多时候真的是假学习，没有记录，没有练习，没有实践，纯粹浪费时间，没有思考的学习是无效的。</p><h2 id="记卡片笔记-养成习惯"><a href="#记卡片笔记-养成习惯" class="headerlink" title="记卡片笔记&#x2F;养成习惯"></a>记卡片笔记&#x2F;养成习惯</h2><h3 id="坚持每天记几条笔记"><a href="#坚持每天记几条笔记" class="headerlink" title="坚持每天记几条笔记"></a>坚持每天记几条笔记</h3><blockquote><p>卢曼的卡片盒里大约有 9 万条笔记，听起来是一个非常庞大的数字，但这仅仅意味着，从他开始使用卡片盒进行工作的那天起，直到他去世，每天也只要写 6 条笔记。</p></blockquote><p>养成记笔记的习惯，养成思考的习惯，相信时间的力量。<br>我计划在 CSDN 、公众号上发表永久笔记，每周 5 篇左右，至少2 篇有深度的文章，3 篇分享工作经验和工具推荐。</p><h3 id="在大脑之外思考"><a href="#在大脑之外思考" class="headerlink" title="在大脑之外思考"></a>在大脑之外思考</h3><p>没有作品是完全复制脑海中的想法形成的，需要转化，从一个语境到另外一个语境，从一种形式到另外一种形式。</p><blockquote><p>将想法写下来，再思考的意义在于，只有在书面形式下，我们才能以一定的距离从字面意思上看待一个论点。我们需要这种距离来思考一个论点，否则，论点本身就会占据我们审视论点所需要的心理资源。</p></blockquote><p>写作的过程就是一个审视想法的过程，有时候有一个想法觉得很好，很兴奋，但当我们实际整理的时候，却发现有很多不成熟的，矛盾的地方，写下来不仅是固定我们飘忽的想法，是让我们在大脑之外思考，更加平和的面对自己的想法，更关心执行。</p><blockquote><p>大脑是“一台能跳跃式得出结论的机器”——丹尼尔·卡尼曼</p></blockquote><h2 id="发展想法"><a href="#发展想法" class="headerlink" title="发展想法"></a>发展想法</h2><p>松散的记录，提纲挈领的总结，根据笔记内容设定主题，以笔记为参考网格，不断联系、丰富和完善。<br>笔记的集合会从复杂逐渐变成有秩序的。<br>谨慎的设置关键词和分类，定期回顾，建立索引，建立文件之间的链接。<br>比较、纠正和区分笔记。审视旧笔记本，有助于我们发展新的想法，纠正曾经错误的想法，事物总在不断发展和进步，以前的笔记很多时候错漏的，需要纠正并建立新的想法。<br>将卡片盒作为思考的工具箱<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405262139869.png" alt="有联系的笔记系统"></p><h2 id="分享你的洞见"><a href="#分享你的洞见" class="headerlink" title="分享你的洞见"></a>分享你的洞见</h2><p>放弃头脑风暴，从笔记中寻找灵感，在兴趣的驱动下完成任务，在完稿后反复修改自己的作品，并分享你的洞见。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>免费图片素材网站推荐</title>
    <link href="/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="免费图片素材网站推荐"><a href="#免费图片素材网站推荐" class="headerlink" title="免费图片素材网站推荐"></a>免费图片素材网站推荐</h2><p>最近在找一些免费的图片素材，收集整理如下：</p><ul><li><a href="https://wallpaperhub.app/">https://wallpaperhub.app/</a></li><li><a href="https://unsplash.com/">https://unsplash.com/</a></li><li><a href="https://www.pexels.com/">https://www.pexels.com/</a></li><li><a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></li></ul><p><strong>注意：如果要自己用最好是选择明确标注免费的图片。</strong></p><h3 id="wallpaperhub"><a href="#wallpaperhub" class="headerlink" title="wallpaperhub"></a>wallpaperhub</h3><p>支持不同尺寸下载</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192108439.png" alt="网站截图"></p><h3 id="Unsplash"><a href="#Unsplash" class="headerlink" title="Unsplash"></a>Unsplash</h3><p>下载速度快，包括照片、矢量图、图集等。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192116523.png" alt="网站截图"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192113133.jpg" alt="andrew-small-EfhCUc_fjrU-unsplash.jpg"></p><h2 id="Pexels"><a href="#Pexels" class="headerlink" title="Pexels"></a>Pexels</h2><p>中规中矩，下载速度较慢。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192119347.png" alt="image.png"></p><h3 id="Pixabay"><a href="#Pixabay" class="headerlink" title="Pixabay"></a>Pixabay</h3><p>加载较慢，支持不同尺寸下载，但是直接点下载并没有反应…<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192124520.png" alt="image.png"></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192129471.webp" alt="多彩窗户.webp"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后，如果这篇文章有帮助到你，记得收藏。<br>也欢迎关注我的个人微信公众号：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192215003.jpg" alt="qrcode_for_me.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>经验分享</tag>
      
      <tag>素材</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGLM 智能体 搭建属于自己的AI知识库</title>
    <link href="/2024/05/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/ChatGLM%20%E6%99%BA%E8%83%BD%E4%BD%93%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84AI%E7%9F%A5%E8%AF%86%E5%BA%93/"/>
    <url>/2024/05/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/ChatGLM%20%E6%99%BA%E8%83%BD%E4%BD%93%20%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84AI%E7%9F%A5%E8%AF%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看一本书《在线》，将所有数据都需要在线，才有生命力，那么我们的知识库也是。我们现在就可以用先进的大预言模型搭建属于自己的在线 AI 知识库，他就是 ChatGLM 智谱清言智能体。<br>它可以将自己的知识库与 ChatGLM 结合，成为某一方面的专业知识问答系统。当然，市面上有很多类似解决方案，但是智谱清言是我试过国内最好用的一个产品，整体知识库最多免费支持1000个文件（每个100MB），知识库总字数不超过1亿字。完全够用了，而且具备联网功能。</p><p>本文以搭建水文分析智能体为例，讲解如何快速搭建智能体。</p><h2 id="创建智能体"><a href="#创建智能体" class="headerlink" title="创建智能体"></a>创建智能体</h2><p>进入智谱清言，点击创建智能体。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122102223.png" alt="image.png"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>名称：简介、开场白随便填。<br>配置信息按照需求填，我的水质分析内容如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122104516.png" alt="image.png"><br>推荐问题随便填。<br>模型调用建议全点上。<br>知识库文件最关键，建议将你本地知识库全部上传，比如平常写的分析报告，标准导则等等，互联网已经有的文件不用传，文件类型也可以是 url。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122110778.png" alt="微信截图_20240512210752.png"><br>知识库设置可以选择显示段落来源，或者仅从知识库回答。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122111537.png" alt="image.png"><br>添加 API 可以选择一些开源的 API，或者自己创建 API，这里添加了天气查询的 API。那么就能实现查询城市天气的功能。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122112037.png" alt="image.png"></p><p>最后点击发布即可，发布方式可以用邀请的方式，可以定向分享，这样你不想公开的智能体，其他人就无法访问。</p><h2 id="测试智能体"><a href="#测试智能体" class="headerlink" title="测试智能体"></a>测试智能体</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122115270.png" alt="image.png"></p><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>现在的 AI 发展很快，我们只有不断学习才能跟上时代的脚步，就想这个智能体功能， ChatGLM 也更新的非常快，API 功能也是最近才上线的，感觉非常好用。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>经验分享</tag>
      
      <tag>AIGC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片识别公式神器推荐</title>
    <link href="/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB%E5%85%AC%E5%BC%8F%E7%A5%9E%E5%99%A8%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/05/19/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB%E5%85%AC%E5%BC%8F%E7%A5%9E%E5%99%A8%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>你是否遇到在某个资料上看到一个很复杂的公式，但有懒得在word 或者其他文件上打出来。<br>比如这个：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111841378.png" alt="image.png"><br>如果直接截图的话，只能说非常丑陋。</p><p>推荐一个网站 mathpix，点击 try for free，注册登录。<br><a href="https://mathpix.com/">Mathpix: AI-powered document automation</a></p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111843929.png" alt="image.png"><br>上传图片<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111844471.png" alt="image.png"></p><p>结果非常完美，中间是预览，右侧为 Latex 代码，复制在支持 Latex 的文本编辑器（比如 obsidian），可以直接用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111845938.png" alt="image.png"><br>真香。</p><p>右边的 code 是代码在不同场景的应用，说几个常用到的。</p><ul><li>Equation LaTeX<br>  LaTeX 代码</li><li>LaTeX block math (not numbered)<br>  LaTeX 代码含块儿符号，可直接复制进 markdown 编辑器，如 obsidian</li><li>LaTeX block math (numbered)<br>  LaTeX 代码含块儿符号，可直接复制进 word</li></ul><p>另外这个网站只能免费 10 次，再推荐一个类似的网站：<br><a href="https://simpletex.cn/ai/latex_ocr">https://simpletex.cn/ai/latex_ocr</a><br>功能一样，无需登录就能使用。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202406141338338.png" alt="image.png"></p><p>最后打个广告，我新开了微信公众号（环境猫 er），坚持发布 python 环境业务解决方案，python 办公自动化，GIS 作图经验，学习笔记，办公技巧，工具分享等内容。<br>坚持 Bulid in public ，希望与你一起加油，一同成长。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405102028570.jpg" alt="qrcode_for_gh_b2ae4cd1414a_258.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>知道做到 读书笔记</title>
    <link href="/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%9F%A5%E9%81%93%E5%81%9A%E5%88%B0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%9F%A5%E9%81%93%E5%81%9A%E5%88%B0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>[[知道做到：跃迁式学习]]</p><h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><blockquote><p>[!abstract] 知道做到：跃迁式学习</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/54/3300017554/t7_3300017554.jpg" alt=" 知道做到：跃迁式学习|200"></li><li>书名： 知道做到：跃迁式学习</li><li>作者： 彼得•霍林斯</li><li>简介： 学习是改善你的生活环境、成为你想成为的人的关键。科学的方法能加速学习进程，让你事半功倍。技能、信息和能力永远不会突然降临，需要你自己去寻找它们，这本书将手把手教你如何以效的方式做到这一点：清晰明了的学习思路，切实可行的学习建议，让你更聪明地学习，而不是更努力地学习。在本书中你将学习到：a.学习的理论和原则以及我们做错了什么；b.你的期望比你的才能更重要；c.如何制定计划，战略性地解构和分析信息、技能；d.如何在少工作的同时获得更好的结果；e.如何利用身边人和环境制造惊人的结果；f.自我练习、调整和纠正的艺术；g.如何积累你的技能，使其成为独一无二的资源。一本书带你快速训练大脑、发展肌肉记忆，了解潜在的心理学和生物学。</li><li>出版时间 </li><li>ISBN： 9787504689542</li><li>分类： 经济理财-管理</li><li>出版社： </li><li>PC 地址： <a href="https://weread.qq.com/web/reader/37032360813ab6d5bg014fdd">https://weread.qq.com/web/reader/37032360813ab6d5bg014fdd</a></li></ul></blockquote><h1 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h1><p>这是一本讲如何学习的书，不厚，很多老生常谈的东西，但对我有用就是好书。<br>读的过程中，我认真梳理了关于如何学习的知识，特意做了学习风格测试（所罗门-费尔德学习方式和偏好指数法）和 16 型人格测试（MBTI 测试），让我更了解自己的优缺点。人是可以改变的，所以我希望通过学习学习方法，提高自己。希望过几年测试我的状态更好。</p><h2 id="学习需要思考的内容"><a href="#学习需要思考的内容" class="headerlink" title="学习需要思考的内容"></a>学习需要思考的内容</h2><ol><li>做这件事对我有什么价值</li><li>做这件事要花费什么成本<ol><li>时间成本</li><li>金钱</li><li>投入产出比</li></ol></li><li>你想在这个领域达到怎样的效果</li><li>你有哪些可以依赖的外部资源<ol><li>[[如何利用环境]]</li><li>你没有的资源是否可以创造和争取</li></ol></li><li>你是否有这方面的天赋（一般以上）</li><li>当前的生活状态是否支持你做这项工作</li></ol><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p>再次之前我做了 2 个测试学习风格测试（所罗门-费尔德学习方式和偏好指数法）和 16 型人格测试（MBTI 测试）。我的学习风格偏好 VEPS（视觉、活跃、综合、感觉），人格为表演者-ESFP，荣格认知功能偏好为：主导功能：外倾感觉，辅助功能：内倾情感，第三功能：外倾思考，劣势功能：内倾直觉。测试结果基本符合我的状态，更倾向于外倾感觉，做事流于表面，并不深究。这对我的成长来说并不是好事，因为我也不可能真的成为一个表演者或者销售。因此我要在现有优势的基础上，不断提高自己的理性思考能力。</p><p>以下学习方法主要从书中总结，学习方法远不止于下面这些，以后会不断增加学习方法。我本人是认可费曼学习法的。</p><h3 id="学习金字塔"><a href="#学习金字塔" class="headerlink" title="学习金字塔"></a>学习金字塔</h3><p>学习金字塔理论，由美国学者、著名的学习专家爱德加·戴尔（Edgar Dale）在 1946 年提出，是一种现代学习方式的理论。该理论通过数字形式形象显示了采用不同的学习方式，学习者在两周以后还能记住内容（平均学习保持率）的多少。学习金字塔模型的核心思想在于强调不同学习活动对信息保留效率的影响，并提倡更加互动和主动的学习方法来提高学习效率和记忆持久度。这个模型通过一个逐级展示不同学习方法效果的形象金字塔，揭示了从被动接收到主动参与的学习方式对增强记忆保持的重要性。</p><p>听讲 5%<br>阅读 10%<br>视听 20%<br>演示 30%<br>讨论 50%<br>实践 75%<br>教授给他人 90%</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404121601505.png" alt="image.png"></p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>实际可能并没有那么绝对，应该是多重方法结合，知识教授他人更难，你必须掌握才能教，所以留存更长，另外一个就是坚持，反复练习。</p><h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404121708139.png" alt="image.png"></p><p>1. 选择学习目标与概念理解（Concept）<br>2. 回顾与知识梳理（Review）<br>    回顾所学内容，尝试在没有参考资料的情况下，用自己的语言和理解重新阐述该概念。<br>3. 简化与知识重构（Simplify）<br>4. 教给他人（tech）</p><h2 id="布鲁姆分类法"><a href="#布鲁姆分类法" class="headerlink" title="布鲁姆分类法"></a>布鲁姆分类法</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404121720005.png" alt="image.png"><br>类似于费曼。</p><h2 id="学习的四个具体操作方式"><a href="#学习的四个具体操作方式" class="headerlink" title="学习的四个具体操作方式"></a>学习的四个具体操作方式</h2><h3 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h3><p><strong>专注力决定信息吸收率</strong><br>刻意练习关键在于认真、<strong>专注</strong>、<strong>耐心</strong>，学习慢一点，再慢一点。<br>反复练习而不用心，也没有用，<strong>熟悉不等于掌握</strong><br>学习时，不要被既有经验束缚，以为了解就不深入学习<br>这也适用于健身</p><h4 id="真正的掌握需要不停的练习"><a href="#真正的掌握需要不停的练习" class="headerlink" title="真正的掌握需要不停的练习"></a>真正的掌握需要不停的练习</h4><p>制定 [[每日时刻表]]<br>利用零散的时间进行练习<br>番茄工作法</p><h3 id="交替练习"><a href="#交替练习" class="headerlink" title="交替练习"></a>交替练习</h3><p>将相近的知识交替学习，但要避免打断思考</p><h3 id="间隔重复"><a href="#间隔重复" class="headerlink" title="间隔重复"></a>间隔重复</h3><p>周期学习就像健身一样，每天固定时间点学习</p><h3 id="问题导向式学习法"><a href="#问题导向式学习法" class="headerlink" title="问题导向式学习法"></a>问题导向式学习法</h3><p>问题导向式学习法（Problem-based Learning，简称 PBL）<br>以解题的思路学习，可以是做项目，或者做应用题，然后向上追溯知识点<br>具体步骤：</p><ol><li>明确你的问题。</li><li>明确你已知的信息。</li><li>明确你需要但未知的内容，以及获得这些信息的途径</li><li>列出可行的解决方案，并选择成功几率最大的解决方案。</li><li>将方案<strong>分解</strong>为一个个行动（列出具体的时间计划通常很有用）。</li></ol><h2 id="学习心态调整"><a href="#学习心态调整" class="headerlink" title="学习心态调整"></a>学习心态调整</h2><h3 id="合理自我定位"><a href="#合理自我定位" class="headerlink" title="合理自我定位"></a>合理自我定位</h3><p>认识学习并不是一件简单的事，需要精心设定目标，制定计划。<br><strong>所有的半途而废，都是因为心态错位</strong><br>要乐观，但不要过于乐观<br>战略上藐视敌人，战术上重视敌人<br>饱和式打击，不作无准备之仗<br><strong>保持谦逊</strong>，stay hungry stay foolish<br>养成一个习惯需要 66 天，学习一个技能至少要 25-30 小时</p><h3 id="好奇心"><a href="#好奇心" class="headerlink" title="好奇心"></a>好奇心</h3><p>好奇心不是学习的充分条件，但是可以作为发起学习和自律力耗尽的时候拉你一把。</p><h3 id="提高困惑忍耐力"><a href="#提高困惑忍耐力" class="headerlink" title="提高困惑忍耐力"></a>提高困惑忍耐力</h3><p>当你学习越深入，不知道的越多，要提高困惑忍耐力。试着抽离出来，用全局观，或者短时间沉浸在局部利益，或者调动自己的好奇心，或者给自己打气，或者借助于朋友的宽慰，及时走出困惑沮丧的心境，重新开始学习，切记不要因此放弃当前的学习。这是你突破瓶颈的方法。</p><h2 id="深入学习的方法"><a href="#深入学习的方法" class="headerlink" title="深入学习的方法"></a>深入学习的方法</h2><h3 id="精细提问"><a href="#精细提问" class="headerlink" title="精细提问"></a>精细提问</h3><p>也可以用于讨论<br>六要素提问：who、what、where、when、why、how</p><h2 id="如何利用环境"><a href="#如何利用环境" class="headerlink" title="如何利用环境"></a>如何利用环境</h2><p>我作为一个外倾感觉型的人，非常容易受到环境的影响。<br><strong>与其挑战天性，不如利用环境最高级的自律，是让环境帮你做出正确决策</strong><br>主要是两个方面社会环境和个人环境（大环境和小环境）</p><h3 id="个体环境"><a href="#个体环境" class="headerlink" title="个体环境"></a>个体环境</h3><p>五官感受到的环境，屋子是否整齐，资料夹是否按顺序摆放等等。<br>第一，把资源放在触手可及的地方。<br>第二，把干扰因素关进另一个房间。<br>启动耗能&#x2F;活化能<br>对于较难的工作，即使切换到工作状态都耗费极大的精力。<br>主动抵御沉迷分心事物的冲动，把注意力转移到需要学习或实践的任务上。<br>《心流》（Flow）认为，这种改变环境的方法其实是改变了特定活动的“活化能”。<br>一般来说，对于心生向往的事情，你要降低活化能；对于讨厌的事情，你则要增加活化能。<br>启动学习和练习所需的活化能越少越好。<br>这本书很难做到，我目前也没有到达，只有坚持练习，希望能更丝滑的切换到工作和学习。</p><h3 id="社会环境"><a href="#社会环境" class="headerlink" title="社会环境"></a>社会环境</h3><p>朋友、社会关系<br>积极向上的氛围，相互鼓励的环境。<br>消除不良的氛围，原理刻意贬低和质疑你的人。<br>榜样的力量，向榜样学习<br>向优秀的人和群体靠拢</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卡片笔记写作法 精读笔记 01</title>
    <link href="/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/"/>
    <url>/2024/05/19/05%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E5%8D%A1%E7%89%87%E7%AC%94%E8%AE%B0%E5%86%99%E4%BD%9C%E6%B3%95%20%E7%B2%BE%E8%AF%BB%E7%AC%94%E8%AE%B0%2001/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="熟悉不等于理解"><a href="#熟悉不等于理解" class="headerlink" title="熟悉不等于理解"></a>熟悉不等于理解</h2><p><em>单纯的重复阅读没有任何意义，无论是对理解还是对学习都是如此。甚至，我们能不能将其称为“学习”都还值得商榷。</em></p><p>#感悟 熟悉不等于掌握，看书、听书、看电影、看视频都一样，看再多都没有用，包括做项目也一样，不总结没有用，就想我之前准备考试一样，不重复做题，不可以联系，不从大脑里提取是学不会知识的，学习必须动笔，必须动手。 ^9c54ce</p><h2 id="笔记的分类"><a href="#笔记的分类" class="headerlink" title="笔记的分类"></a>笔记的分类</h2><p>分为闪念笔记文献笔记和永久笔记<br>Titles： 卡片笔记写作法 精读笔记 01</p><hr><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><blockquote><p>[!abstract] 卡片笔记写作法：如何实现从阅读到写作</p><ul><li><img src="https://cdn.weread.qq.com/weread/cover/15/YueWen_39136896/t7_YueWen_39136896.jpg" alt=" 卡片笔记写作法：如何实现从阅读到写作|200"></li><li>书名： 卡片笔记写作法：如何实现从阅读到写作</li><li>作者： 申克·阿伦斯</li><li>简介： 卢曼的“盒中笔记”通常很简短，因为这些只是他庞大繁杂研究中的索引，等需要时，他会借由这些线头进行延伸思考，然后不断链接知识要点，从而形成自己的知识树。你也可以试试。</li><li>出版时间 2021-06-01 00:00:00</li><li>ISBN： 9787115564672</li><li>分类： 文学-语言文字</li><li>出版社： 人民邮电出版社</li><li>PC 地址： <a href="https://weread.qq.com/web/reader/3d8326d072552e803d87c41">https://weread.qq.com/web/reader/3d8326d072552e803d87c41</a></li></ul></blockquote><p>2024 年认真读书，第 2 本卡片笔记写作法，这本书干货很多，要分成很多期，我会慢慢整理。</p><h2 id="推荐序"><a href="#推荐序" class="headerlink" title="推荐序"></a>推荐序</h2><h3 id="认知与元认知"><a href="#认知与元认知" class="headerlink" title="认知与元认知"></a>认知与元认知</h3><p>认知为我们学到的内容，看到的事物；元认知是意识到我们学到的内容，看到的事物。元认知是认知的认知，就想方法论是方法的方法，有点像二阶求导。<br>在认知上层再加工，再连接，就是卡片学习法。</p><h3 id="卡片笔记的作用"><a href="#卡片笔记的作用" class="headerlink" title="卡片笔记的作用"></a>卡片笔记的作用</h3><p>增加了学习知识的效率，引出<strong>必要难度</strong>理论。<br>必要难度，人的记忆有两种机制，存储强度与提取强度，存储与提取负相关，也就是说，存入记忆越容易，提取出来越困难；反之，如果你有些吃力地存入，知识提取会更方便，越容易越难以掌握。<br>建立索引是增加必要难度的途径。<br>建立索引的理性分为</p><ol><li>主题索引</li><li>前后关联</li><li>临近关联</li><li>笔记关联<br>通过对笔记的组合、对比形成新的文章，新的见解。</li></ol><p><strong>未来已至，只是分布得不均匀。</strong></p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><p>高智商与成就没有决定性关系，而自律才是起最大作用的。<br>（Self-Discipline Outdoes IQ in Predicting Academic Performance of Adolescents）</p><h3 id="如何做到自律"><a href="#如何做到自律" class="headerlink" title="如何做到自律"></a>如何做到自律</h3><p>依靠意志力形成自绝没那么容易，意志力是一种有限的资源，它消耗得很快，而且从长期来看，也没有那么多手段快速提升意志力。但我们可以通过改变环境，来减少意志力的消耗。当周围没有巧克力棒的时候，自然不需要靠意志力来拒绝美食的诱惑。<br>如果一个人特别想做某件事，他也用不着靠意力去完成。长期利益和短期利益之间不存在冲突，所以每项有趣、有意义、明确的任务都会被完成，而且这样的任务每次都能比靠意志力完成得好。如果做一件事不是因为你有意志力，而是根本不需要使用意志力，那就意味着你离成功不远了。而组织写作和记笔记就能发挥这样的作用<br>所以如何做到自律，那就是把任务当作自己的兴趣，减少或者不使用意志力驱动。</p><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="关于写作，你需要知道的"><a href="#关于写作，你需要知道的" class="headerlink" title="关于写作，你需要知道的"></a>关于写作，你需要知道的</h3><p>邓宁—克鲁格效应 (Kruger and Dunning, 1999）成绩差但意识不到自己的不足。<br>“冒牌货综合征”，优秀的学生时常感到自己不能胜任某项工作。<br>思考：给自己清晰的定位，保持谦逊，保持好奇，要敢于去尝试，感兴趣的事情就放手去学，去做。</p><h4 id="GTD-的要义"><a href="#GTD-的要义" class="headerlink" title="GTD 的要义"></a>GTD 的要义</h4><p>戴维·艾伦 (David Allen)在《搞定》(Getting Things Done, 2001) 提出“GTD”<br>将所有要做的事情罗列出来，按照<strong>既定的方法</strong>处理，并<strong>定期回顾</strong>。</p><h4 id="GTD-的作用"><a href="#GTD-的作用" class="headerlink" title="GTD 的作用"></a>GTD 的作用</h4><p>使任务不占用心智，达到心如止水，内心平静，专注当下。提供了一种解决问题的框架，因为大多数注意力分散的情况并不是源于我们的环境，而是来自我们纷乱的想法。<br>即所谓想的太多，而做的太少。GTD 就是把想法归想法，执行归执行，通过回顾来联系。<br>GTD 适用于做事，而不能简单的适用于写作，因为写作无法准确的分解下一步。需要一个新的系统-卡片笔记。</p><blockquote><p>卢曼语录：”我只做容易的事情，我只在马上知道要怎么写的时候才会写作。如果我有片刻的动摇，我就会把这件事放在一边，然后继续做别的事”</p></blockquote><p>思考: 这里的容易，并非真正的容易，而是只是否让自己处于心流状态的工作，跟随兴趣而出发，不同的时间，不同的状态，不断在不同的领域积累。</p><h4 id="卢曼笔记的工作原理"><a href="#卢曼笔记的工作原理" class="headerlink" title="卢曼笔记的工作原理"></a>卢曼笔记的工作原理</h4><ol><li>卡片分类管理，分为闪念笔记、文献笔记和永久笔记。</li><li>记录笔记时，不是照抄原文，而是加上自己的思考和转述，并表明出处。</li><li>思考与关联，与历史笔记的关联，通过建立大纲笔记、索引笔记串联笔记系统。</li><li>组合，相关笔记组合为新的笔记。</li><li>时常回顾，分析各个笔记之间的关联。</li></ol><h3 id="关于写作，你需要做的"><a href="#关于写作，你需要做的" class="headerlink" title="关于写作，你需要做的"></a>关于写作，你需要做的</h3><h4 id="写作的具体步骤"><a href="#写作的具体步骤" class="headerlink" title="写作的具体步骤"></a>写作的具体步骤</h4><ol><li>记闪念笔记。随时记录灵感，想法。想法来之不易，要珍惜，及时记录。及时整理回顾。建立自己的闪念笔记系统。</li><li>记录文献笔记。文献笔记要精读，要一遍记录一遍读，珍惜好作品的想法，用自己的语言进行阐述。语句简练，做好标记和来源。建立自己的文献管理系统。</li><li>记永久笔记。通过阅读闪联笔记和文献笔记，思考和兴趣所在的主题，将笔记进行组合和扩展，形成一篇主题项目的永久笔记。这种笔记上的思想不是为了收集，而是为了衍生想法、论点和讨论。及时清理闪念笔记，文献笔记及时归纳，不要让闪念笔记成为垃圾桶。</li><li>将永久笔记和文献笔记建立关联，建立双链笔记。</li><li>对笔记进行扩展，比如某个主题差什么环节，有什么新的进展。</li><li>一个主题足够丰富，对主题内的笔记进行整理排序，剔除，改进。</li><li>将主题整理一篇连贯的文章。</li><li>校对，审核，发表</li></ol>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>用心长文</tag>
      
      <tag>读书笔记</tag>
      
      <tag>方法论</tag>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在excel中使用python 快速作图示例</title>
    <link href="/2024/05/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8python%20%E5%BF%AB%E9%80%9F%E4%BD%9C%E5%9B%BE%E7%A4%BA%E4%BE%8B/"/>
    <url>/2024/05/19/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E5%9C%A8excel%E4%B8%AD%E4%BD%BF%E7%94%A8python%20%E5%BF%AB%E9%80%9F%E4%BD%9C%E5%9B%BE%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Excel 中可以使用 python 算是一个旧闻了，是 python 之父 Guido van Rossum 加入微软的重要产品。刚出来的第一时间我也尝鲜了，最近作图的时候，再次使用了这个功能，感觉非常方便，推荐大家也用一下。<br><strong>优点：</strong></p><ol><li>Python 在云端运行，无需部署环境。</li><li>可以编写脚本来自动化日常的 Excel 任务，如数据整理、图表生成等，提高工作效率。</li><li>快速响应，可视化选择数据，调整原始数据方便，所见即所得，比 jupyter notebook 更丝滑。<br><strong>缺点：</strong><br>云端运行的 python，对网速要求高，不方便加载除了标准库以外的第三方库。<br>好的，那我们就以日常工作中水质折线图为例，探究下 Excel 中使用 python 的魅力。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405170912976.png" alt="在excel中使用python.png"></li></ol><h2 id="基础条件"><a href="#基础条件" class="headerlink" title="基础条件"></a>基础条件</h2><p>支持 python 的 excel 版本。我是用的是 office 365。<br><em>Excel 中的 Python 目前为预览版，可能会根据反馈进行更改。若要使用此功能，请加入 <a href="https://insider.microsoft365.com/join/windows">Microsoft 365 会员计划</a>，并选择“<strong>Beta 版频道</strong>”预览体验成员级别。</em><br>Excel 中的 Python 包括 anaconda 提供的一些标准 Python 库，用于提高数据分析和数据可视化能力。包括 Matplotlib、NumPy、Pandas、Seaborn、Statsmodels 等。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161838543.png" alt="image.png"></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>一组在线水质检测数据，包括水质站点监测值和监测时间。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161843018.png" alt="image.png"></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>一、选择一个空单元格，点击公式-插入 python<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161845518.png" alt="image.png"></p><p>二、数据结构预览<br>单元格输入以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df=xl(<span class="hljs-string">&quot;A1:G98&quot;</span>, headers=<span class="hljs-literal">True</span>)<br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><span class="hljs-comment"># 确保时间列是索引</span><br>df.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>df.describe()<br></code></pre></td></tr></table></figure><p>按快捷键 crtl+enter 得到数据集结果。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161847142.png" alt="image.png"><br>仔细看下 excel 界面:<br>1 为代码输入区，可以调整宽度，自带代码高亮和代码提示。<br>2 为选择输出类型切换，包括值和 python 对象。<br>3 为结果展示区域，包括图片或者其他信息，图片的话需要调整单元格宽度。<br>4 为诊断信息，就像 python 的命令结果窗口，会给出成功或者报错信息。<br>可以说是一个简单的 IDE，五脏俱全。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161853316.png" alt="image.png"><br>三、绘图<br>选择一个较大的区域，最好是合并单元格，点击公式-插入 python。<br>单元格输入以下代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&quot;font.sans-serif&quot;</span>] = [<span class="hljs-string">&quot;Simhei&quot;</span>]  <br>plt.rcParams[<span class="hljs-string">&quot;axes.unicode_minus&quot;</span>] = <span class="hljs-literal">False</span><br><span class="hljs-comment"># 将监测时间列转换为datetime类型</span><br>df=xl(<span class="hljs-string">&quot;A1:G98&quot;</span>, headers=<span class="hljs-literal">True</span>)<br>df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br><span class="hljs-comment"># 确保时间列是索引</span><br>df.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 使用matplotlib绘制折线图</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># 设置图表大小</span><br><span class="hljs-keyword">for</span> column <span class="hljs-keyword">in</span> df.columns:<br>    plt.plot(df.index, df[column], label=column)  <span class="hljs-comment"># 绘制每列的折线图</span><br><span class="hljs-comment"># 添加标准值线（值为6），蓝色虚线</span><br>plt.axhline(<span class="hljs-number">6</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, label=<span class="hljs-string">&#x27;标准值&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;5月各站点高锰酸盐指数变化趋势图&#x27;</span>)  <span class="hljs-comment"># 设置图表标题</span><br><span class="hljs-comment"># plt.xlabel(&#x27;监测时间&#x27;)  # 设置x轴标签</span><br>plt.ylabel(<span class="hljs-string">&#x27;监测值：mg/L&#x27;</span>)  <span class="hljs-comment"># 设置y轴标签</span><br>plt.xticks(rotation=<span class="hljs-number">0</span>)  <br>plt.tight_layout()  <span class="hljs-comment"># 自动调整子图参数，使之填充整个图像区域</span><br><span class="hljs-comment"># 修改图例位置</span><br>plt.legend(loc=<span class="hljs-string">&#x27;lower left&#x27;</span>, bbox_to_anchor=(<span class="hljs-number">0</span>, -<span class="hljs-number">0.15</span>), ncol=<span class="hljs-built_in">len</span>(df.columns), frameon=<span class="hljs-literal">False</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>结果如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405161903435.png" alt="image.png"><br>利用 python 的 matplotlib 库绘图，就是这么丝滑。如果下次需要再次绘图，那么就不需要重复设置了，直接修改数据就好了。发现数据存在异常，修改异常值也是快速更新结果，非常方便。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>这只是 excel 中使用 python 的一个小小示例，相信它能做的还有更多。有点担心 vba 的地位了。<br>最后，如果这篇文章有帮助到你，记得点赞，关注哦。<br>也欢迎关注我的微信公众号：环境猫 er。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405192215003.jpg" alt="qrcode_for_me.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>excel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>忍痛分享一个标签页插件</title>
    <link href="/2024/05/13/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%BF%8D%E7%97%9B%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%8F%92%E4%BB%B6/"/>
    <url>/2024/05/13/03%20%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/%E5%BF%8D%E7%97%9B%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>如果你想要一个自定义收藏页面的标签页插件，他没有广告，而且支持很多插件，如股票、时间、倒计时、备忘录，那么我必须推荐你一个插件了。</p><p>itab 标签页。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131938405.png" alt="微信截图_20240513193649.png"></p><p>标签页可以分组，可以自定义图标，很多都能自动识别 logo。这类产品很多，但是完成度最高的目前就是 itab，不是广告，纯粹自来水。</p>]]></content>
    
    
    <categories>
      
      <category>工具推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>浏览器插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prophet时间序列模型水质预测应用</title>
    <link href="/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此前已经分析了，ARIMA 模型在水质预测中的应用，今天用 prophet 模型测试下再水质预测中的效果。</p><h2 id="Prophet-简介"><a href="#Prophet-简介" class="headerlink" title="Prophet 简介"></a>Prophet 简介</h2><p>Prophet 是 Facebook 于2017年开源的一个时间序列预测框架，特别适合于处理具有明显趋势性和季节性的数据。该模型设计初衷是为了让非专业的数据科学家也能轻松上手进行复杂的时间序列分析，同时也能满足专业人士对于模型灵活性和准确性的需求，总之，就很香。</p><h2 id="Prophet-模型特点"><a href="#Prophet-模型特点" class="headerlink" title="Prophet 模型特点"></a>Prophet 模型特点</h2><p><strong>易用性</strong>：Prophet 提供了一个高度封装的 API，用户只需要提供时间戳（ds，通常为日期）和观测值（y，即随时间变化的目标变量），就可以快速构建预测模型，而无需深入理解复杂的统计或机器学习理论。<br><strong>自动特征提取</strong>：模型自动识别并处理时间序列中的趋势（长期增长或下降）、季节性（如周、月、年等周期性模式）以及节假日效应。用户可以轻松地添加自定义的季节性模式和节假日信息。<br><strong>灵活性</strong>：模型允许用户调整多种参数来控制预测的行为，比如趋势的平滑程度、季节性模式的复杂度等，以适应不同数据的特点。<br><strong>异常值和缺失值处理</strong>：Prophet模型对于数据中的异常值和缺失值具有一定的鲁棒性，能够在不影响整体预测的情况下处理这些问题。<br><strong>changepoints</strong>：模型能够自动检测并适应时间序列中的变化点，即数据中的非平稳部分，这对于预测具有突然变化的时间序列尤为重要。<br><strong>可视化</strong>：Prophet还提供了丰富的可视化工具，帮助用户直观地理解模型的各个组成部分（如趋势、季节性）以及预测结果，便于模型诊断和结果解释。<br><strong>Python 和 R 支持</strong>：Prophet 在 Python 和 R 两种语言中都有实现，方便不同背景的用户使用。</p><p>从上面的特点看出，完美适配水质预测。</p><h2 id="Prophet-python-安装"><a href="#Prophet-python-安装" class="headerlink" title="Prophet python 安装"></a>Prophet python 安装</h2><p>在网上能看到很多奇奇怪怪的安装指令，比如 fbprophet 库，已经不能用了，以我为准哈，下面是最新可用的安装方法。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install prophet<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131841729.png" alt="image.png"></p><h2 id="Python-Prophet-实践"><a href="#Python-Prophet-实践" class="headerlink" title="Python Prophet 实践"></a>Python Prophet 实践</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <br><span class="hljs-keyword">from</span> prophet <span class="hljs-keyword">import</span> Prophet  <br><span class="hljs-keyword">from</span> prophet.plot <span class="hljs-keyword">import</span> add_changepoints_to_plot  <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><p>每个项目的数据准备不一样，可以是在线数据，也可以是本地数据，具体略过。<br>数据结构为时间和值，Prophet 格式形式为 ds 和 y。</p><h3 id="数据粒径和数据集尺寸"><a href="#数据粒径和数据集尺寸" class="headerlink" title="数据粒径和数据集尺寸"></a>数据粒径和数据集尺寸</h3><p>Prophet 非常适合做周期数据，也适应多种粒径，所以无需担心他无法识别小时或者日的尺度，<br>还有因为他适合做周期数据，因此给数据集时，应给他至少一个周期的数据，不然预测出来效果差很多。<br>比如同一个站点，同一个因子，给一个月的数据集和一年的数据集结果分别如下图所示：<br><strong>一个月的数据集预测结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131854796.png" alt="Figure_5.png"><br><strong>一年的数据结果</strong><br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131855235.png" alt="Figure_2.png"></p><p>由上面 2 个图可以看出，完全是天差地别，也能看出这个模型非常厉害，处理周期波动数据非常精准，在一年的尺度下准确的预测了 4 月后水质将继续升高，并没有被短期下降数据而干扰。</p><h2 id="原始数据集预览"><a href="#原始数据集预览" class="headerlink" title="原始数据集预览"></a>原始数据集预览</h2><p>综上，我们选择一年的数据集，开始预测。原始数据如下：<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131858976.png"><br>可以看到数据集质量一般，这也是实际生成环境中的数据，但是 Prophet 能够识别异常值，不用担心他会报错。</p><h2 id="模型搭建预览结果"><a href="#模型搭建预览结果" class="headerlink" title="模型搭建预览结果"></a>模型搭建预览结果</h2><p>模型接口非常简单，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化Prophet模型  </span><br>model = Prophet()  <br><span class="hljs-comment"># 拟合模型  </span><br>model.fit(df)  <br><span class="hljs-comment"># 定义未来预测的时间段，例如预测未来7天的水质  </span><br>future = model.make_future_dataframe(periods=<span class="hljs-number">7</span>)  <span class="hljs-comment"># 7天预测期  </span><br>future.tail()  <span class="hljs-comment"># 查看预测数据框的末尾几行以确认预测时间段  </span><br><span class="hljs-comment"># 进行预测  </span><br>forecast = model.predict(future)  <br><span class="hljs-comment"># 绘制预测结果  </span><br>fig1 = model.plot(forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 添加变化点到图表中（如果需要）  </span><br>fig2 = model.plot(forecast)  <br>ax = fig2.gca()  <br>add_changepoints_to_plot(ax, model, forecast)  <br>plt.title(<span class="hljs-string">&#x27;Water Quality Prediction with Changepoints&#x27;</span>)  <br>plt.show()  <br><span class="hljs-comment"># 打印预测数据框查看预测详情  </span><br><span class="hljs-built_in">print</span>(forecast[[<span class="hljs-string">&#x27;ds&#x27;</span>, <span class="hljs-string">&#x27;yhat&#x27;</span>, <span class="hljs-string">&#x27;yhat_lower&#x27;</span>, <span class="hljs-string">&#x27;yhat_upper&#x27;</span>]])<br></code></pre></td></tr></table></figure><p>预测结果为图 2 所示，变化点如下图，模型将每次突变点都标记出来了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131902308.png" alt="Figure_3.png"></p><p>预测结果 forecast<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131913145.png" alt="image.png"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>相比 arima，Prophet 更加简单易用，且成熟接口更多，出图预览更方便，本文还没有对添加节假日进行测试，但已经非常够用了。<br>对比 LSTM，预测时间少非常多，配置也更简单，真的很不错，如果有兴趣可以深入尝试。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/" title="ARIMA时间序列模型水质预测应用">ARIMA时间序列模型水质预测应用</a><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405131915810.jpg" alt="pexels-pixabay-50677.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
      <tag>时间序列模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集方法合集 第2期</title>
    <link href="/2024/05/12/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC2%E6%9C%9F/"/>
    <url>/2024/05/12/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC2%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>好的，我们继续讲所有信息的收集方法，今天讲百度文库、淘豆网、豆丁网、道客巴巴、原创力文档及专利的获取，还包括搜索信息的注意事项。如果有帮助到你，非常荣幸，我会坚持分享我的学习、工作经验。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111825908.png" alt="image.png"></p><h2 id="其他文档"><a href="#其他文档" class="headerlink" title="其他文档"></a>其他文档</h2><p>这里泛指所有上传在百度文库、淘豆网、豆丁网、道客巴巴、原创力文档等网站上的文件，也是使用比较高频的一个方法，这里先叠个甲，我并非不尊重知识产权，只是这些网站的内容大多是在公开资料上爬取然后展示的内容，包括很多标准等等，在用于学习的情况下，下载下来无可厚非，如果以下方法，有侵害到平台权利，我就删掉这篇文章，相信信息只有流转才能产生价值。<br>好的我们继续。</p><p>打开浏览器应用商店，推荐 edge 、chrome浏览器，安装 tampermonkey 插件，点击插件获取新脚本，在 greasy fork 脚本商店中搜索文库下载器，一定要是 waahah 这个做这的脚本，其他也有一些下载脚本，但是我推荐这个是亲测可用的，当然也鼓励大家自己多尝试。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111426186.png" alt="image.png"></p><p>安装好后，打开想要下载的网站，当脚本检测到对应的网站后，会在左上角悬浮蓝色的工具栏，在非百度文库下，先点击自动展开，带文件全部展开后，然后点击导出 PDF。注意如果导出 pdf 效果不好，可以直接在浏览器点击打印, 用虚拟打印机保存为 pdf。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111431609.png" alt="image.png"></p><h2 id="专利"><a href="#专利" class="headerlink" title="专利"></a>专利</h2><p>专利之星只需要注册账号就可以查看公开专利内容，非常好用。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111415055.png" alt="image.png"></p><h2 id="常规搜索方法"><a href="#常规搜索方法" class="headerlink" title="常规搜索方法"></a>常规搜索方法</h2><p>比如在谷歌、百度上搜索，如果精确搜索的话，要想要关键词。比如制定文件格式可以用<br>filetype: pdf 关键词（pdf 可以替换 doc、ppt、jpg 等）<br>还有很多其他比较复杂的搜索关键词，其实用的频率并不高，这里我就不多赘述。<br>谷歌搜索注意用对地址，一般 vpn 的话会默认 vpn 代理地址，下面这个链接可以<br><a href="http://www.google.com/ncr">www.google.com/ncr</a><br>想要查询政府文件或者公开文件，应该熟悉他们的公文结构，了解固定的关键词。<br>比如查询环评原文则在某某报告后面加上”受理”、”公示”字样。</p><p>AI 搜索<br>推荐秘塔搜索，用做主体学习非常不错，可以选择学术、网页、播客三种类型，除了生成分析内容外，更重要的是将相关来源标出，让我们更准确的获取信息。如果<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405122017540.png" alt="image.png"></p><p>我获取信息的方法就是这些了，新人一枚，如果有帮助到你，请点赞关注收藏，谢谢！</p><p>最后打个广告，我新开了微信公众号（环境猫 er），坚持发布 python 环境业务解决方案，python 办公自动化，GIS 作图经验，学习笔记，办公技巧，工具分享等内容。<br>坚持 Bulid in public ，希望与你一起加油，一同成长。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405102028570.jpg" alt="qrcode_for_gh_b2ae4cd1414a_258.jpg"></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC1%E6%9C%9F/" title="信息收集方法合集 第1期">信息收集方法合集 第1期</a>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>用心长文</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集方法合集 第1期</title>
    <link href="/2024/05/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC1%E6%9C%9F/"/>
    <url>/2024/05/11/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC1%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在工作中，经常被问到某个文件怎么下载，原文来自哪里。索性把我知道的所有信息收集方法全部整理一遍，希望对大家有用，如果有帮助到你，非常荣幸，我会坚持分享我的学习、工作经验。</p><p><strong>信息种类</strong>：包括法律法规、标准导则、中英文论文、书籍、专利、环评、验收报告以及其他公开的资料。<br>信息收集框架结构如下图，我会分两期介绍所有信息的获取方法，第一期讲法律法规标准导则、论文、书籍等资料的获取，第二期讲百度文库、淘豆网、豆丁网、道客巴巴、原创力文档及专利的获取，还包括搜索信息的注意事项。随后会持续出关于文献知识库管理的内容，欢迎关注哦。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111825908.png" alt="image.png"></p><h3 id="法律法规、标准导则"><a href="#法律法规、标准导则" class="headerlink" title="法律法规、标准导则"></a>法律法规、标准导则</h3><p>通常这些内容是公开的，在政府网站上可以查到，这里推荐在聚合的网站上去下载，比如环评云助手、国家标准全文公开系统、环保小智等，这些网站不光可以查文件，还可是查询是否有效。</p><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111432139.png" alt="image.png"></p><h3 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h3><p>论文也是我们获取高质量信息的来源，中文文献一般是知网、万方、维普等平台最多，但这些网站一旦出了大学获取就比较困难，这里推荐一个网站，书童图书馆，需要购买账号，可以很低价的方式获得一个长期的会员，可以下载所有的文献。<br>推荐之前先叠个甲，这部分属于灰色地带，但从学习的角度讲，文献公开是对学习研究环境非常有利的，不管政策怎么变，及时这个网址可能被 ban，也有千万个网站出来，就像是 Z-library 一样。</p><p>英文文献推荐 Sci-hub 和 Arxiv。英文文献的获取难度要低于中文，甚至很多文献可以找到代码和数据集，国内做的相对较差。<br>SCI-HUB<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111749350.png" alt="image.png"></p><p>Arxiv 是本是存放物理学、数学、计算机科学、生物学与数理经济学的论文预印本的网站，是没有被同行审议过的文章都先上传在上面，后面上传的论文越来越多人，影响越来越大，目前已经是非常重要的论文网站了。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111759563.png" alt="image.png"></p><h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><p>获取电子书的方法也很多，首推 Z-library。经常被 ban，目前仍在坚强运营。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111802327.png" alt="image.png"></p><p> Z-library 经常变动网址，有时候需要魔法，嫌麻烦可以用鸠摩搜书先检索，一般书都有。<br>然后是 GitHub，有些开源项目的书会发布在 GitHub 上，比如鸢尾花系列，Python 工匠等。<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405111804169.png" alt="image.png"><br>最后强烈推荐微信读书，原因有：</p><ol><li>微信读书包含的出版书籍很多，且支持导入 PDF；</li><li>很多出版社做了真人朗读，听书非常方便，</li><li>读书送时长和书币让你基本不需要花钱，让你直接拥有一个图书馆。</li><li>读书笔记与 obsidian 等软件有联动，方便总结归纳，</li><li>多平台适配，书籍无需过多整理，减轻负担。<br>我已经成为微信读书的重度用户了，也欢迎喜欢微信读书的朋友，留言交流，一同进步。</li></ol><p>新人一枚，如果有帮助到你，请点赞关注，非常感谢。</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/12/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E6%B3%95%E5%90%88%E9%9B%86%20%E7%AC%AC2%E6%9C%9F/" title="信息收集方法合集 第2期">信息收集方法合集 第2期</a>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>经验分享</tag>
      
      <tag>用心长文</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARIMA时间序列模型水质预测应用</title>
    <link href="/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/"/>
    <url>/2024/05/09/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/ARIMA%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="ARIMA-时间序列模型简介"><a href="#ARIMA-时间序列模型简介" class="headerlink" title="ARIMA 时间序列模型简介"></a>ARIMA 时间序列模型简介</h2><p>时间序列是研究数据随时间变化而变化的一种算法，是一种预测性分析算法。它的基本出发点就是事物发展都有连续性，按照它本身固有的规律进行。ARIMA(p,d,q)模型全称为差分自回归移动平均模型  (Autoregressive Integrated Moving Average Model,简记 ARIMA). 是比较成熟且简单的时间预测模型之一。其中 AR 为自回归, I 为差分, MA 为移动平均。<br>趋势参数：</p><ul><li>p：趋势自回归阶数。</li><li>d：趋势差分阶数。</li><li>q：趋势移动平均阶数。</li></ul><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>差分（difference）又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数f(x) 映射到f(x+a)-f(x+b) 。差分运算，相应于微分运算，是微积分中重要的一个概念。总而言之，差分对应离散，微分对应连续。差分又分为前向差分、向后差分及中心差分三种。<br>通常情况下我们用到的是前向差分公式如下：<br>xk&#x3D;x0+kh,(k&#x3D;0,1,…,n)<br>△f(xk)&#x3D;f(xk+1)−f(xk)<br>差分的阶<br>称为阶的差分，即前向阶差分 ，如果数学运用根据数学归纳法，有其中，为二项式系数。特别的，有前向差分有时候也称作数列的二项式变换</p><h2 id="在高锰酸盐指数序列预测可行性的说明"><a href="#在高锰酸盐指数序列预测可行性的说明" class="headerlink" title="在高锰酸盐指数序列预测可行性的说明"></a>在高锰酸盐指数序列预测可行性的说明</h2><p>通过观察水质变化趋势，高锰酸盐指数波动不剧烈，存在明显的中心波动规律。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658496447043-88b405af-1be8-4102-9e18-08920fc56b01.png"></p><h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> warnings<br><span class="hljs-keyword">import</span> pymysql<br><br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)  <br><span class="hljs-comment"># 忽略警告，不然一大堆警告，多是python及对应包升高导致，不影响使用</span><br><span class="hljs-keyword">from</span> IPython.core.interactiveshell <span class="hljs-keyword">import</span> InteractiveShell<br>InteractiveShell.ast_node_interactivity = <span class="hljs-string">&quot;all&quot;</span><br><span class="hljs-keyword">from</span> matplotlib.pylab <span class="hljs-keyword">import</span> style  <span class="hljs-comment"># 自定义图表风格</span><br>style.use(<span class="hljs-string">&#x27;ggplot&#x27;</span>)<br><br><span class="hljs-comment"># 解决中文乱码问题</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;Simhei&#x27;</span>]<br><span class="hljs-comment"># 解决坐标轴刻度负号乱码</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># pip install statsmodels</span><br><br><span class="hljs-keyword">from</span> statsmodels.graphics.tsaplots <span class="hljs-keyword">import</span> plot_acf, plot_pacf  <span class="hljs-comment"># 自相关图、偏自相关图</span><br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller <span class="hljs-keyword">as</span> ADF  <span class="hljs-comment"># 平稳性检验</span><br><span class="hljs-keyword">from</span> statsmodels.stats.diagnostic <span class="hljs-keyword">import</span> acorr_ljungbox  <span class="hljs-comment"># 白噪声检验</span><br><span class="hljs-keyword">import</span> statsmodels.api <span class="hljs-keyword">as</span> sm  <span class="hljs-comment"># D-W检验,一阶自相关检验</span><br><span class="hljs-keyword">from</span> statsmodels.graphics.api <span class="hljs-keyword">import</span> qqplot  <span class="hljs-comment"># 画QQ图,检验一组数据是否服从正态分布</span><br><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br></code></pre></td></tr></table></figure><h3 id="连接数据"><a href="#连接数据" class="headerlink" title="连接数据"></a>连接数据</h3><p>通过数据库，excel 都可以，列名为监测时间、设备名称、设备因子、监测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conn_sql</span>():<br>    conn = pymysql.connect(host=<span class="hljs-string">&quot; &quot;</span>,<br>                   port= ,<br>                   user=<span class="hljs-string">&quot; &quot;</span>,<br>                   password=<span class="hljs-string">&quot; &quot;</span>,<br>                   db=<span class="hljs-string">&quot; &quot;</span>,<br>                   charset=<span class="hljs-string">&quot;utf8&quot;</span>)<br>    sql = <span class="hljs-string">&quot;&quot;</span><br>    read_sql = pd.read_sql(sql, conn)<br>    <span class="hljs-keyword">return</span> read_sql<br>read_sql=conn_sql()<br></code></pre></td></tr></table></figure><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nseri</span>(<span class="hljs-params">s,y </span>):<br>    aidunqiao = read_sql.loc[read_sql[<span class="hljs-string">&#x27;设备名称&#x27;</span>] == s, :]<br>    ai_cod = aidunqiao.loc[read_sql[<span class="hljs-string">&#x27;监测因子&#x27;</span>] == y, :]<br>    ai_cod_mn = ai_cod.loc[:, [<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&#x27;监测值&#x27;</span>]]<br>    baseline = ai_cod.loc[:, [<span class="hljs-string">&quot;监测时间&quot;</span>, <span class="hljs-string">&#x27;监测值&#x27;</span>]]<br><br>    ai_cod_mn.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    interp_cod_mn = ai_cod_mn[<span class="hljs-string">&quot;监测值&quot;</span>].interpolate()<br>    ai_cod_mn[<span class="hljs-string">&quot;cod&quot;</span>] = interp_cod_mn<br>    starttime = baseline.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    rows = baseline.shape[<span class="hljs-number">0</span>]<br>    endtime = baseline.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br>    year_month_day = pd.date_range(starttime, endtime, freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<span class="hljs-string">&quot;%Y%m%d%h%m%s&quot;</span>)<br>    a_ser = pd.DataFrame(&#123;<span class="hljs-string">&#x27;监测时间&#x27;</span>: year_month_day&#125;)<br>    a_ser.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df = pd.concat([a_ser, ai_cod_mn], axis=<span class="hljs-number">0</span>, join=<span class="hljs-string">&quot;outer&quot;</span>)<br>    df = df.reset_index(drop=<span class="hljs-literal">False</span>)<br>    df[<span class="hljs-string">&#x27;监测时间&#x27;</span>] = pd.to_datetime(df[<span class="hljs-string">&#x27;监测时间&#x27;</span>])<br>    df1 = df.drop_duplicates(subset=<span class="hljs-string">&quot;监测时间&quot;</span>, keep=<span class="hljs-string">&quot;last&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2 = df1.sort_values(by=<span class="hljs-string">&quot;监测时间&quot;</span>, ignore_index=<span class="hljs-literal">True</span>)<br>    df2[<span class="hljs-string">&quot;cod&quot;</span>] = df2[<span class="hljs-string">&quot;监测值&quot;</span>].interpolate()<br>    df2.drop(columns=<span class="hljs-string">&quot;监测值&quot;</span>, inplace=<span class="hljs-literal">True</span>)<br>    df2.set_index(<span class="hljs-string">&#x27;监测时间&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> df2<br></code></pre></td></tr></table></figure><p>主要是 将数据生成无空连续的逐小时 时间序列数据 插值方法为线性插值</p><h3 id="数据解读"><a href="#数据解读" class="headerlink" title="数据解读"></a>数据解读</h3><h4 id="查看acf"><a href="#查看acf" class="headerlink" title="查看acf"></a>查看acf</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = df2.dropna()<br><span class="hljs-comment"># 解决有nan的问题</span><br>plot_acf(df2,lags=<span class="hljs-number">50</span>).show()<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658496966248-a9f853f2-55b2-4728-8ae7-83c26ec56dd7.png"></p><p>解读 拖尾为p 。基本大于0.5 现在和未来有很强的相关性</p><h4 id="单位根检验"><a href="#单位根检验" class="headerlink" title="单位根检验"></a>单位根检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;原始序列的ADF检验结果为：&#x27;</span>,ADF(df2.cod))<br></code></pre></td></tr></table></figure><p>原始序列的ADF检验结果为： (-7.19465930048855, 2.452407467867345e-10, 37, 9199, {‘1%’: -3.431061069214289, ‘5%’: -2.8618542472812902, ‘10%’: -2.5669372687639176}, 11281.50483165621)</p><p>解读：P值小于显著性水平α（0.05），不接受原假设（非平稳序列），说明原始序列是平稳序列。</p><h4 id="白噪声检验"><a href="#白噪声检验" class="headerlink" title="白噪声检验"></a>白噪声检验</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一阶差分序列的白噪声检验结果为：&#x27;</span>,acorr_ljungbox(df2,lags=<span class="hljs-number">1</span>,return_df =<span class="hljs-built_in">bool</span>))<br></code></pre></td></tr></table></figure><p>一阶差分序列的白噪声检验结果为： lb_stat lb_pvalue 1 7467.631465 0.0</p><p>p值为0小于0.05，不是白噪声</p><p><strong>综上可以采用 arima 模型</strong></p><h4 id="定阶-人工识图"><a href="#定阶-人工识图" class="headerlink" title="定阶 人工识图"></a>定阶 人工识图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#一阶差分，我们不需要这么做，看下代码怎么写的。</span><br>df2_mn=df2.diff(periods=<span class="hljs-number">1</span>, axis=<span class="hljs-number">0</span>).dropna()<br><span class="hljs-comment">#自相关图</span><br>plot_acf(df2,lags=<span class="hljs-number">20</span>).show()<br><span class="hljs-comment">#解读：拖尾 有长期相关性 p 取1 </span><br><span class="hljs-comment">#偏自相关图 </span><br>plot_pacf(df2,lags=<span class="hljs-number">20</span>).show()<br><span class="hljs-comment">#偏自相关图</span><br>plot_pacf(df2,lags=<span class="hljs-number">50</span>).show()<br><span class="hljs-comment">#解读：自相关图，0阶拖尾；偏自相关图，截尾。则ARIMA(p,d,q)=ARIMA(1,0,n)</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497358538-342dc80a-d890-4386-bc8e-ca67ca811fef.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497368903-f3dccfbb-c6e0-4aa7-a86c-e78aab590f93.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497380496-184e826a-d4c3-40a3-aa69-f2413617af0a.png"></p><h4 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h4><p>AIC调优</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br>aic_matrix=[]<br><span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    tmp=[]<br>    <span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">try</span>:<br>            tmp.append(ARIMA(df2,order=(p,<span class="hljs-number">0</span>,q)).fit().aic)<br>        <span class="hljs-keyword">except</span>:<br>            tmp.append(<span class="hljs-literal">None</span>)<br>    aic_matrix.append(tmp)<br>aic_matrix<br><br><span class="hljs-comment"># p,q=aic_matrix.stack().idxmin() #最小值的索引</span><br><span class="hljs-comment"># 手动查找最小值 同样为1，0，4</span><br></code></pre></td></tr></table></figure><p>也可以用BIC调优 不再赘述</p><h3 id="模型建立"><a href="#模型建立" class="headerlink" title="模型建立"></a>模型建立</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = ARIMA(df2, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>result_arima = model.fit()<br></code></pre></td></tr></table></figure><h3 id="模型预测"><a href="#模型预测" class="headerlink" title="模型预测"></a>模型预测</h3><p>定义画图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pic1</span>(<span class="hljs-params">result_arima,df2</span>):<br>    t1 = <span class="hljs-string">&quot;2022/7/6 00:00:00&quot;</span><br>    t2 = <span class="hljs-string">&quot;2022/7/8 00:00:00&quot;</span><br>    predict_more=result_arima.predict(t1 ,t2 )<br>    t = pd.date_range(t1, t2 , freq=<span class="hljs-string">&quot;h&quot;</span>).strftime(<span class="hljs-string">&quot;%y%m%d%h%m%s&quot;</span>)<br>    new_ticks = pd.date_range(t1, t2 , freq=<span class="hljs-string">&quot;d&quot;</span>).strftime(<span class="hljs-string">&quot;%y%m%d%h%m%s&quot;</span>)<br>    axc.clear()<br>    axc.set_title(<span class="hljs-string">&quot;局部历史值与真实值对比&quot;</span>)<br>    axc.plot(t,df2[t1 :t2],linestyle = <span class="hljs-string">&quot;--&quot;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    axc.plot(t,predict_more,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>    axc.legend([<span class="hljs-string">&#x27;真实值&#x27;</span>,<span class="hljs-string">&#x27;预测值&#x27;</span>])<br>    axc.set_xticks(new_ticks)   <br><br>    <span class="hljs-comment"># 创建画布控件</span><br>    canvas = FigureCanvasTkAgg(fig1, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497922337-e1e6f543-0dbb-409b-ac68-05a72ef2423a.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fore_picture</span>(<span class="hljs-params">result_arima,df2</span>):<br>    df3 = df2.reset_index(drop=<span class="hljs-literal">False</span>)<br>    rows = df3.shape[<span class="hljs-number">0</span>]<br>    endtime = df3.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    forecast = pd.Series(result_arima.forecast(<span class="hljs-number">48</span>), index=pd.date_range(endtime, periods=<span class="hljs-number">48</span>, freq=<span class="hljs-string">&#x27;H&#x27;</span>))<br>    df_last = df2.iloc[-<span class="hljs-number">48</span>:]    <br>    data = pd.concat((df_last, forecast), axis=<span class="hljs-number">0</span>)<br>    data.columns = [<span class="hljs-string">&#x27;监测值浓度&#x27;</span>, <span class="hljs-string">&#x27;未来48小时&#x27;</span>]<br>    axc2.clear()<br>    axc2.set_title(<span class="hljs-string">&quot;未来48小时预测&quot;</span>)<br>    axc2.plot(data) <br>    <br>        <span class="hljs-comment"># 创建画布控件</span><br>    canvas = FigureCanvasTkAgg(fig2, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">600</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497941233-d0387b16-c1dd-4ec5-a2a4-4162e3be9eec.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare2</span>(<span class="hljs-params">result_arima,df2</span>):<br>    df3 = df2.reset_index(drop=<span class="hljs-literal">False</span>)<br>    rows = df3.shape[<span class="hljs-number">0</span>]<br>    endtime = df3.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>    starttime = df3.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>    predict=result_arima.predict(starttime , endtime)<br>    axc3.clear()<br>    axc3.set_title(<span class="hljs-string">&quot;全部预测值真实值对比&quot;</span>)<br>    axc3.plot(df2.index,df2[<span class="hljs-string">&#x27;cod&#x27;</span>],linestyle = <span class="hljs-string">&quot;--&quot;</span>,alpha=<span class="hljs-number">0.5</span>)<br>    axc3.plot(df2.index,predict,linestyle = <span class="hljs-string">&quot;:&quot;</span>)<br>    axc3.legend([<span class="hljs-string">&#x27;真实值&#x27;</span>,<span class="hljs-string">&#x27;预测值&#x27;</span>])<br>    canvas = FigureCanvasTkAgg(fig3, master=root)  <span class="hljs-comment"># A tk.DrawingArea.</span><br>    canvas.draw()<br>    canvas.get_tk_widget().place(x=<span class="hljs-number">1200</span>,y=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658497956069-1c995a76-08cb-44b0-a0b2-9173af977365.png"></p><h3 id="模型可视化及GUI初探"><a href="#模型可视化及GUI初探" class="headerlink" title="模型可视化及GUI初探"></a>模型可视化及GUI初探</h3><p>用Tkinter 实现自动选择站点及因子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 副本</span><br><span class="hljs-keyword">from</span> tkinter.ttk <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span>  tkinter <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> matplotlib<br>matplotlib.use(<span class="hljs-string">&#x27;TkAgg&#x27;</span>)<br><span class="hljs-keyword">from</span> matplotlib.backends.backend_tkagg <span class="hljs-keyword">import</span> FigureCanvasTkAgg<br><span class="hljs-keyword">from</span> matplotlib.figure <span class="hljs-keyword">import</span> Figure<br><br>root = Tk()<br>root.title(<span class="hljs-string">&quot;ARIMA预测模型&quot;</span>)<br>root.geometry(<span class="hljs-string">&quot;1800x900+50+50&quot;</span>)  <span class="hljs-comment"># 长x宽+x*y</span><br>           <br>lb1 = Label(root,text=<span class="hljs-string">&#x27;站点选择&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br>lb2 = Label(root,text=<span class="hljs-string">&#x27;因子选择&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br>lb3 = Label(root,text=<span class="hljs-string">&#x27;预测结果（48h）&#x27;</span>,fg=<span class="hljs-string">&#x27;black&#x27;</span>, font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">2</span>,  relief=FLAT)<br><span class="hljs-comment"># lb4 = Label(root,text=&#x27;历史预测对比&#x27;,fg=&#x27;black&#x27;, font=(&#x27;微软雅黑&#x27;,15),  height=2,  relief=FLAT)</span><br><br><span class="hljs-comment"># lb5 = Label(root,text=comb1.get(),fg=&#x27;black&#x27;, font=(&#x27;微软雅黑&#x27;,15),  height=2,  relief=FLAT)</span><br>lb1.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">20</span>)<br>lb2.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">20</span>)<br>lb3.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">110</span>)<br><span class="hljs-comment"># lb4.place(x=510,y=110)</span><br><span class="hljs-comment"># lb5.place(x=820,y=110)</span><br>var1 = StringVar()<br>comb1= Combobox(root,textvariable=var1,values = site)<br>comb1.place(x=<span class="hljs-number">63</span>,y=<span class="hljs-number">80</span>)<br>var2 = StringVar()<br>comb2= Combobox(root,textvariable=var2,values=factor)<br>comb2.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">80</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_device</span>(<span class="hljs-params">event</span>):<br>    s = comb1.get()<br>    <span class="hljs-built_in">print</span>(s)<br>    <span class="hljs-keyword">return</span> s<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">select_factor</span> (event):<br>    y = comb2.get()<br>    <span class="hljs-built_in">print</span>(y)<br>    <span class="hljs-keyword">return</span> y<br><br>comb1.bind(<span class="hljs-string">&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;</span>, select_device)<br>comb2.bind(<span class="hljs-string">&quot;&lt;&lt;ComboboxSelected&gt;&gt;&quot;</span>, select_factor)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">click</span>(<span class="hljs-params">event</span>):<br>    s = comb1.get()<br>    y = comb2.get()<br>    df2 = nseri(s,y )<br>    model = ARIMA(df2, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>    result_arima = model.fit()<br>    <br>    fig1 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc = fig1.add_subplot(<span class="hljs-number">111</span>)<br>    axc.clear()<br>    pic1(result_arima,df2)<br><br>    fig2 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc2 = fig2.add_subplot(<span class="hljs-number">111</span>)<br>    axc2.clear()<br>    fore_picture(result_arima,df2)<br><br>    fig3 = Figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), dpi=<span class="hljs-number">120</span>)<br>    axc3 = fig3.add_subplot(<span class="hljs-number">111</span>)<br>    axc3.clear()<br>    compare2(result_arima,df2)    <br>    <br><br>but1 = Button(root, text=<span class="hljs-string">&#x27;计算&#x27;</span>,font=(<span class="hljs-string">&#x27;微软雅黑&#x27;</span>,<span class="hljs-number">15</span>),  height=<span class="hljs-number">1</span>)<br>but1.place(x=<span class="hljs-number">300</span>,y=<span class="hljs-number">110</span>)  <br><br>but1.bind(<span class="hljs-string">&quot;&lt;Button-1&gt;&quot;</span>,click)<br><br>root.mainloop()<br></code></pre></td></tr></table></figure><p>结果预览<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405092131490.png" alt="111.png"></p><h3 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h3><p>模型评价方法： 浓度准确率， 等级准确率</p><p>浓度准确率</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498060055-471dd8e9-e287-4a75-b360-d508cdf45eea.png"></p><p>等级准确率：实测的类别与预测的类别相同时，则视为预测正确，预测正确的个数占预测的总个数的百分比，即为模型预测准确率。指标预测准确率的详细计算方法如下式：<img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202405092145737.png" alt="image.png"></p><p>Pi为类别相对误差，T 为验证期内实测值的时间点数，t为实测值与预测值对应的时刻，pit为实测的类别与模拟的类别相比值，如果类别相同则为1，否则为0。</p><h3 id="结果提取"><a href="#结果提取" class="headerlink" title="结果提取"></a>结果提取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">format1</span>(<span class="hljs-params">df2</span>):<br>    df7=pd.Series()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">180</span>) :<br>        df3= df2[:-<span class="hljs-number">4</span>*(<span class="hljs-number">1</span>+i)]        <br>        model = ARIMA(df3, order=(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br>        result_arima1 = model.fit()<br>        df4 = df3.reset_index(drop=<span class="hljs-literal">False</span>)<br>        rows = df4.shape[<span class="hljs-number">0</span>]<br>        endtime = df4.iloc[rows - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        forecast = pd.Series(result_arima1.forecast(<span class="hljs-number">5</span>), index=pd.date_range(endtime, periods=<span class="hljs-number">5</span>, freq=<span class="hljs-string">&#x27;H&#x27;</span>))<br>        df8 = forecast.tail(<span class="hljs-number">1</span>)    <br>        df7 = pd.concat((df7,df8),axis=<span class="hljs-number">0</span>,join=<span class="hljs-string">&#x27;inner&#x27;</span>)<br>    <span class="hljs-keyword">return</span> df7 <br>f2 =format1(df2)<br>f2.to_excel(<span class="hljs-string">&quot;forceful.xls&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>时间原因用的excel 分析</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498412727-7339ba7d-dbd3-407b-ac06-2261972c967d.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1658498435576-efb265aa-9f0e-452f-84fa-e70509215452.png"></p><p>对比了6月21日~2022&#x2F;7&#x2F;15 高指真实值与预测值的结果，浓度预测准确率为84.61%，等级准确率40.74%，等级准确率偏低的原因为实际监测结果在6附近波动，为Ⅲ类水质标准。<br>预测对比时间窗口存在降雨，实际结果有一定波动，浓度预测准确率能到达84.6%，有一定的推广价值。</p><h3 id="ARIMA-summary-解读"><a href="#ARIMA-summary-解读" class="headerlink" title="ARIMA .summary() 解读"></a>ARIMA .summary() 解读</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/681168/1670242073687-2d564dde-6f19-4ae7-9283-b3341ec7dae9.png"></p><ol><li>左上 为模型基本信息，Dep. Variable（需要预测的变量）、Model（模型及其参数）、Date、Time、Sample（样本数据）、No. Observations（观测数据的数量）</li><li>右上 Log Likelihood（对数似然函数）标识最适合采样数据的分布。虽然它很有用，但AIC和BIC会惩罚模型的复杂性，这有助于使我们的ARIMA模型变得简洁。赤池的信息准则（AIC）有助于确定线性回归模型的强度。AIC 会惩罚添加参数的模型，因为添加更多参数将始终增加最大似然值。贝叶斯信息准则（BIC）与 AIC 一样，BIC 也会惩罚模型的复杂性，但它也包含数据中的行数。Hannan-Quinn信息标准（HQIC），与AIC和BIC一样是模型选择的另一个标准；但是它在实践中并不常用。AIC 、BIC 越小越好</li><li>中部 确保模型中的每个项在统计意义上是否显著。若p值大于0.05，则项不显著。</li><li>下部：Ljung-Box（modified Box-Pierce test）测试错误是白噪音 Ljung-Box (L1) (Q) 为Lag1的LBQ检验统计量，其Prob(Q)为 0.01，p值为0.94。由于p值高于0.05，因此我们不能拒绝零假设（误差是白噪音）</li></ol><h3 id="讨论与总结"><a href="#讨论与总结" class="headerlink" title="讨论与总结"></a>讨论与总结</h3><ol><li>ARIMA 模型在高锰酸盐指数上的预测效果超过80%,经过初步研究，适用于水质在线站点。</li><li>模型可用于单站点单因子预测，不需要其他参数，约束小，预测精度高。</li><li>模型对波动剧烈的因子，预测效果不好，不适用于所有因子，所有站点。</li><li>对于新的数据集需要做平稳性检验，白噪声检验。</li><li>需要采用数据人工识图+自动的方式实现定阶，选择最优的 p，d，q。</li><li>可以继续在 ARIMAX（多元时间序列模型）等方面深入研究。</li></ol><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><a href="/2024/05/13/01%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/prophet%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%A8%A1%E5%9E%8B%E6%B0%B4%E8%B4%A8%E9%A2%84%E6%B5%8B%E5%BA%94%E7%94%A8/" title="prophet时间序列模型水质预测应用">prophet时间序列模型水质预测应用</a>]]></content>
    
    
    <categories>
      
      <category>时间序列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间序列</tag>
      
      <tag>水环境分析</tag>
      
      <tag>python</tag>
      
      <tag>用心长文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian 图床配置  PicGo+ gitee 精简版</title>
    <link href="/2024/04/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%9B%BE%E5%BA%8A/"/>
    <url>/2024/04/15/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="图床的作用"><a href="#图床的作用" class="headerlink" title="图床的作用"></a>图床的作用</h2><p>图床（Image Hosting Service）是一种在线服务，用于存储和托管用户上传的图片文件。用户可以将图片上传到图床服务器，并获得一个可访问的图片链接，然后可以在网页、博客、论坛等地方使用这个链接来展示图片。<br>通过 PicGo+ gitee 可以搭建免费属于自己的免费图床，当然这里有个风险就是他是开源的可能有资料泄密的风险。</p><h3 id="资料准备"><a href="#资料准备" class="headerlink" title="资料准备"></a>资料准备</h3><p>Node. Js<br>Gitee<br>PicGo<br>Obsidian<br>Obsidian 插件 Image auto Upload<br>参考<br><a href="https://blog.csdn.net/m0_72598806/article/details/135693863">picGo+gitee搭建Obsidian(Typora)图床，实现高效写作_obsidian 坚果云 图床-CSDN博客</a><br>具体步骤：</p><h2 id="1-下载-Node-Js"><a href="#1-下载-Node-Js" class="headerlink" title="1. 下载 Node. Js"></a>1. 下载 Node. Js</h2><p>一直下一步即可，注意确保勾选环境变量，一般为默认。<br><a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><h2 id="2-下载-PicGo"><a href="#2-下载-PicGo" class="headerlink" title="2. 下载  PicGo"></a>2. 下载  PicGo</h2><p>一直下一步。<br><a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn&#x2F;PicGo (github.com)</a></p><h2 id="3-配置gitee"><a href="#3-配置gitee" class="headerlink" title="3. 配置gitee"></a>3. 配置gitee</h2><p>新建仓库-配置开源<br>创建个人令牌</p><h2 id="4-配置-picgo"><a href="#4-配置-picgo" class="headerlink" title="4. 配置 picgo"></a>4. 配置 picgo</h2><p>安装插件 gitee-uplodaer<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202403151107812.png" alt="image.png"></p><p>图床设置 - gitee<br><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202403151108050.png" alt="image.png"></p><p>Repo 输入 gitee 仓库地址<br>Path 为图片文件夹<br>建议设置好后，在上传区上传测试是否成功。<br>Picgo 设置开启开机启动，开启时间戳重命名。<br>一般设置 server 保持默认即可</p><h2 id="5-配置-obsdian"><a href="#5-配置-obsdian" class="headerlink" title="5. 配置 obsdian"></a>5. 配置 obsdian</h2><p>下载安装插件 Image auto Upload<br>设置保持默认即可。</p><p>完成，你可以测试是否成功。</p><p>如果显示失败上传失败不要急。</p><ol><li>检查 picgo  直接上传是否正常</li><li>检查 picgo 设置路径是否正常 token 是否正确，不能有空格</li><li>检查个人仓库地址是否正常，可以测试完整路径或者后面的路径反复尝试。</li><li>重启 picgo 中的设置 server 先关闭后开启</li></ol><p>最后，祝你成功。</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
      <tag>经验分享</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian  微信读书 插件 weread 强烈推荐</title>
    <link href="/2024/04/09/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%20%E6%8F%92%E4%BB%B6%20weread%20%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/04/09/04%20%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/obsidian%20%20%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%20%E6%8F%92%E4%BB%B6%20weread%20%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在用 obsidian，一入 ob 深似海，从此语雀是路人。<br>今天强烈推荐喜欢用微信读书的人，使用它，1+1＞2。两大神级软件助你起飞。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>第三方软件搜索 weread ，点击下载、启用。</p><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404100917769.png" alt="image.png"></p><ol><li>微信登录账号</li><li>设置保存位置</li><li>设置文件名模板</li><li>设置文件夹分类</li><li>可自定义文件模板，我并没有修改。</li><li>点击同步左侧书籍按钮即可同步。</li></ol><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>现将使用效果写在前面。</p><ol><li>一键简单设置，只需要登录即可同步所有微信读书阅读笔记。</li><li>书籍按照分类自动新建笔记和文件夹，体验知识积累的快感</li><li>鼓励做书摘，做卡片笔记。让知识更好的沉淀，而不是写过之后就忘了。</li></ol><p><img src="https://gitee.com/chenwenmao/picbed/raw/master/img/202404100919162.png" alt="image.png"></p><p>看着自己阅读的书籍全部展示出来，成就感满满。</p><h2 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h2><p>在使用中也发现，不能直接修改同步的文字，因为一旦同步，写在本地的文字也会覆盖。<br>但我们可以通过在本地认真写好读书笔记后，在微信读书上发布，然后再同步，这样就可以两边都有了。</p>]]></content>
    
    
    <categories>
      
      <category>经验分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具推荐</tag>
      
      <tag>obsidian</tag>
      
      <tag>经验分享</tag>
      
      <tag>微信读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
